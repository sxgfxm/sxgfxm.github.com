<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Ios | Light's Blog]]></title>
  <link href="http://sxgfxm.github.io/blog/categories/ios/atom.xml" rel="self"/>
  <link href="http://sxgfxm.github.io/"/>
  <updated>2017-12-02T18:11:26+08:00</updated>
  <id>http://sxgfxm.github.io/</id>
  <author>
    <name><![CDATA[Light]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[iOS知识小集-171127]]></title>
    <link href="http://sxgfxm.github.io/blog/2017/12/02/ioszhi-shi-xiao-ji-171127/"/>
    <updated>2017-12-02T18:08:07+08:00</updated>
    <id>http://sxgfxm.github.io/blog/2017/12/02/ioszhi-shi-xiao-ji-171127</id>
    <content type="html"><![CDATA[<h2>ContentInset</h2>

<p>内容偏移，可用于下拉刷新调整界面位置。</p>

<h2>嵌套UINavigationController的UIViewController设置preferredStatusBarStyle无效</h2>

<p>如果<code>UIViewController</code>有<code>UINavigationController</code>，则会先调<code>UINavigationController</code>的<code>childViewControllerForStatusBarStyle</code>方法，该方法默认返回nil，所以子<code>UIViewController</code>设置的<code>preferredStatusBarStyle</code>无效。<br/>
解决办法，继承<code>UINavigationController</code>，并重写<code>childViewControllerForStatusBarStyle</code>方法：<br/>
<code>objective-c
- (UIViewController *)childViewControllerForStatusBarStyle{
    return self.topViewController;
}
</code></p>

<!-- more -->


<h2>Present可Push的ViewController</h2>

<p>需要在present之前用<code>UINavigationController</code>包装一下待present的<code>UIViewController</code>。</p>

<h2>UITableView insert or delete or move cell</h2>

<pre><code class="objective-c">#pragma mark - Edit
- (BOOL)tableView:(UITableView *)tableView canEditRowAtIndexPath:(NSIndexPath *)indexPath{
  return YES;
}

- (UITableViewCellEditingStyle)tableView:(UITableView *)tableView editingStyleForRowAtIndexPath:(NSIndexPath *)indexPath{
  return indexPath.section ? UITableViewCellEditingStyleInsert : UITableViewCellEditingStyleDelete;
}

- (void)tableView:(UITableView *)tableView commitEditingStyle:(UITableViewCellEditingStyle)editingStyle forRowAtIndexPath:(NSIndexPath *)indexPath{
  switch (editingStyle) {
    case UITableViewCellEditingStyleDelete:{
      NSString *item = self.selectCategoies[indexPath.row];
      [self.selectCategoies removeObject:item];
      [tableView deleteRowsAtIndexPaths:@[indexPath] withRowAnimation:UITableViewRowAnimationFade];
      [self.unselectCategoies insertObject:item atIndex:0];
      [tableView insertRowsAtIndexPaths:@[[NSIndexPath indexPathForRow:0 inSection:1]] withRowAnimation:UITableViewRowAnimationFade];
      break;
    }
    case UITableViewCellEditingStyleInsert:{
      NSString *item = self.unselectCategoies[indexPath.row];
      [self.unselectCategoies removeObject:item];
      [tableView deleteRowsAtIndexPaths:@[indexPath] withRowAnimation:UITableViewRowAnimationFade];
      [self.selectCategoies addObject:item];
      [tableView insertRowsAtIndexPaths:@[[NSIndexPath indexPathForRow:self.selectCategoies.count - 1 inSection:0]] withRowAnimation:UITableViewRowAnimationFade];
      break;
    }
    case UITableViewCellEditingStyleNone:
      break;
  }
  [self uploadCategorySetting];
}

- (NSString *)tableView:(UITableView *)tableView titleForDeleteConfirmationButtonForRowAtIndexPath:(NSIndexPath *)indexPath{
  return @"删除";
}

#pragma mark - Move
- (BOOL)tableView:(UITableView *)tableView canMoveRowAtIndexPath:(NSIndexPath *)indexPath{
  if (indexPath.section == 0) {
    return YES;
  }else{
    return NO;
  }
}

- (void)tableView:(UITableView *)tableView moveRowAtIndexPath:(NSIndexPath *)sourceIndexPath toIndexPath:(NSIndexPath *)destinationIndexPath{
  [self.selectCategoies exchangeObjectAtIndex:sourceIndexPath.row withObjectAtIndex:destinationIndexPath.row];
  [tableView exchangeSubviewAtIndex:sourceIndexPath.row withSubviewAtIndex:destinationIndexPath.row];
  [self uploadCategorySetting];
}
</code></pre>

<h2>CLLocation逆向地理编码</h2>

<p>逆向地理编码是一个异步操作，如需使用解析后的地址，需要在block回调时添加代码，而不是在<code>-locationManager:didUpdateLocations:</code>时添加代码。</p>

<pre><code>- (void)reverseGeocodeLocation:(CLLocation *)location {
  // 逆向地理编码
  CLGeocoder *geocoder = [[CLGeocoder alloc] init];
  [geocoder reverseGeocodeLocation:location
                 completionHandler:^(NSArray *placemarks, NSError *error) {
                   CLLocationCoordinate2D coordinate = location.coordinate;
                   // 中国坐标转换
                   if (![TQLocationConverter isLocationOutOfChina:coordinate]) {
                     coordinate = [TQLocationConverter transformFromWGSToGCJ:coordinate];
                     coordinate = [TQLocationConverter transformFromGCJToBaidu:coordinate];
                   }

                   if (error == nil &amp;&amp; [placemarks count] &gt; 0) {
                     CLPlacemark *placemark = [placemarks objectAtIndex:0];
                     [self.currentLocation setLocationInfoWithPlacemark:placemark
                                                               latitude:coordinate.latitude
                                                              longitude:coordinate.longitude];
                   } else {
                     DDLogInfo(@"No results were returned.");
                     [self.currentLocation setLocationInfoWithPlacemark:nil
                                                               latitude:coordinate.latitude
                                                              longitude:coordinate.longitude];
                   }

                   DDLogInfo(@"获取逆向地理编码成功 : %@", [self.currentLocation commaSeparatedAddress]);
                 }];
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS知识小集-171120]]></title>
    <link href="http://sxgfxm.github.io/blog/2017/11/27/ioszhi-shi-xiao-ji-171120/"/>
    <updated>2017-11-27T11:25:53+08:00</updated>
    <id>http://sxgfxm.github.io/blog/2017/11/27/ioszhi-shi-xiao-ji-171120</id>
    <content type="html"><![CDATA[<h2>iOS 10.3之后删除线失效解决办法</h2>

<p>iOS 10.3之前写法：</p>

<pre><code class="objective-c">[attr addAttributes:@{
    NSStrikethroughStyleAttributeName: @(NSUnderlineStyleSingle)
  }
              range:NSMakeRange(0, string.length)];
</code></pre>

<p>iOS 10.3之后写法：</p>

<pre><code class="objective-c">[attr addAttributes:@{
    NSStrikethroughStyleAttributeName: @(NSUnderlineStyleSingle),
    NSBaselineOffsetAttributeName: @(NSUnderlineStyleNone)
  }
              range:NSMakeRange(0, string.length)];
</code></pre>

<!-- more -->


<h2>设置状态栏style</h2>

<p>在<code>info.plist</code>文件中设置<code>View controller-based status bar appearance</code>为<code>YES</code>。<br/>
在对应ViewController中添加下面的方法：</p>

<pre><code class="objective-c">- (UIStatusBarStyle)preferredStatusBarStyle {
  return UIStatusBarStyleLightContent;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS知识小集-171113]]></title>
    <link href="http://sxgfxm.github.io/blog/2017/11/17/ioszhi-shi-xiao-ji-171113/"/>
    <updated>2017-11-17T17:28:01+08:00</updated>
    <id>http://sxgfxm.github.io/blog/2017/11/17/ioszhi-shi-xiao-ji-171113</id>
    <content type="html"><![CDATA[<h2>include vs. import vs. class</h2>

<h3>include</h3>

<p>C语言中引用头文件的语法，无法防止重复引用头文件。</p>

<h3>import</h3>

<p>OC中引用头文件的语法，可以防止重复引用头文件，无法防止循环引用头文件。</p>

<h3>class</h3>

<p>使用<code>@class</code>告知编译器有这样一个类，书写代码时不要报错，真正调用该类的方法时，再<code>#import</code>该类。
可以防止循环引用头文件。</p>

<p>一般来讲，头文件中使用<code>@class</code>引用其他类，在源文件中<code>#import</code>该类。</p>

<!-- more -->


<h2>目录结构</h2>

<p>工程目录结构看出技术水平。<br/>
高内聚，低耦合原则。</p>

<h2>Group vs. Folder</h2>

<p>Group创建引用，并不会创建实际文件夹，方便工程内移动；<br/>
Folder会创建实际文件夹，方便磁盘文件与工程文件对应；</p>

<h2>下拉刷新</h2>

<p><code>-scrollViewDidScroll:</code>，下拉播放header view的动画；<br/>
<code>-scrollViewDidEndDragging:willDecelerate:</code>，松手后请求数据；<br/>
数据返回后切换到正在状态。</p>

<h2>AFNetworking 内存泄露</h2>

<p>如果在一个ViewController中发起网络请求，在数据返回之前退出ViewController，网络请求持有的两个block不会被释放。</p>

<h2>UIBaselineAdjustment</h2>

<p>当文字缩放时的对齐方法：<br/>
<code>UIBaselineAdjustmentNone</code>：top和top对齐；<br/>
<code>UIBaselineAdjustmentAlignBaselines</code>：top和centerY对齐；<br/>
<code>UIBaselineAdjustmentAlignCenters</code>：centerY和centerY对齐。</p>

<h2>Generated duplicate UUIDs</h2>

<p>解决CocoaPods 重复生成 UUID。<br/>
在<code>Podfile</code>中添加<code>install! 'cocoapods', :deterministic_uuids =&gt; false</code>。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS知识小集-171106]]></title>
    <link href="http://sxgfxm.github.io/blog/2017/11/10/ioszhi-shi-xiao-ji-171106/"/>
    <updated>2017-11-10T17:01:04+08:00</updated>
    <id>http://sxgfxm.github.io/blog/2017/11/10/ioszhi-shi-xiao-ji-171106</id>
    <content type="html"><![CDATA[<h2>UIViewController modalPresentationStyle</h2>

<p>当present controller时，可以设置这个属性来控制present时的效果，可用于透明显示被遮盖的conroller，此情况下被遮盖的conroller不会调用viewDidDisappear。</p>

<!-- more -->


<h2>UIPageViewController vs. UIScrollView</h2>

<p>两者都可添加controller，实现滑动切换conroller切换的效果。<br/>
UIPageViewController支持子controller生命周期函数调用，添加到UIScrollView上的controller滑动时不会调用生命周期函数。<br/>
UIPageViewController便于代码分离。<br/>
UIPageViewController没有暴露bounces属性，无法通过系统API禁用，需要特殊操作才可以，这一点UIScrollView有优势。<br/>
UIPageViewController滑动时获取的contentOffset不够准确，需要特殊处理，这一点UIScrollView有优势。<br/>
特殊处理方法：</p>

<pre><code class="objective-c">//  设置UIPageViewController的scrollView的代理为self
for (id view in self.pageController.view.subviews) {
    if ([view isKindOfClass:[UIScrollView class]]) {
      UIScrollView *scrollView = (UIScrollView *)view;
      scrollView.delegate = self;
    }
 }
</code></pre>

<pre><code class="objective-c">- (void)setOffset:(CGFloat)offset {
    _offset = offset;
    //  Do something with offsetX
}

- (void)scrollViewDidScroll:(UIScrollView *)scrollView {
    CGFloat width = scrollView.bounds.size.width;
    CGFloat offset = self.offset;
    NSInteger childCount = self.childControllers.count;
    // 将当前滑动显示的view 的坐标 =&gt; self.view 的坐标
    for (UIViewController *vc in self.childControllers) {
      CGPoint p = [vc.view convertPoint:CGPointMake(0, 0) toView:self.view];
      if (p.x &gt; 0 &amp;&amp; p.x &lt; width) {
        NSInteger index = [self.childControllers indexOfObject:vc];
        offset = index * width - p.x;
      }
    }
    if (offset &gt;= (childCount - 1) * width) {
      CGPoint p = [self.childControllers.lastObject.view convertPoint:CGPointMake(0, 0) toView:self.view];
      offset = (childCount - 1) * width - p.x;
    }
    self.offset = offset;
}

- (void)scrollViewDidEndDecelerating:(UIScrollView *)scrollView {
    CGFloat width = scrollView.bounds.size.width;
    NSInteger index = round(self.offset / width);
    if (index &lt; 0) {
      index = self.childControllers.count - 1;
    }
    self.offset = index * width;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS知识小集-171030]]></title>
    <link href="http://sxgfxm.github.io/blog/2017/11/10/ioszhi-shi-xiao-ji-171030/"/>
    <updated>2017-11-10T16:39:04+08:00</updated>
    <id>http://sxgfxm.github.io/blog/2017/11/10/ioszhi-shi-xiao-ji-171030</id>
    <content type="html"><![CDATA[<h2>ReactiveObjC</h2>

<p>To be finished.</p>
]]></content>
  </entry>
  
</feed>

<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Ios | Light's Blog]]></title>
  <link href="http://sxgfxm.github.io/blog/categories/ios/atom.xml" rel="self"/>
  <link href="http://sxgfxm.github.io/"/>
  <updated>2017-02-10T15:50:14+08:00</updated>
  <id>http://sxgfxm.github.io/</id>
  <author>
    <name><![CDATA[Light]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Export Music From Itunes to Local App's Sandbox on iPhone]]></title>
    <link href="http://sxgfxm.github.io/blog/2017/02/10/export-music-from-itunes-to-local-apps-sandbox-on-iphone/"/>
    <updated>2017-02-10T15:31:20+08:00</updated>
    <id>http://sxgfxm.github.io/blog/2017/02/10/export-music-from-itunes-to-local-apps-sandbox-on-iphone</id>
    <content type="html"><![CDATA[<h2>Introduction</h2>

<p>本文主要介绍app如何获取iTunes中音乐列表，并把iTunes中音乐文件导出至app的沙盒目录下。</p>

<!--more-->


<h2>import</h2>

<p>导入所需的头文件。</p>

<pre><code class="c">#import &lt;AVFoundation/AVAssetExportSession.h&gt;
#import &lt;MediaPlayer/MediaPlayer.h&gt;
</code></pre>

<h2>注册通知</h2>

<p>注册<strong>MPMediaLibraryDidChangeNotification</strong>通知，当iTunes音乐库文件发生变化时，做出响应。</p>

<pre><code class="c">[[NSNotificationCenter defaultCenter]
    addObserver:self
    selector:@selector(mediaLibraryDidChange:)
    name:MPMediaLibraryDidChangeNotification
    object:nil];
</code></pre>

<h2>开启通知</h2>

<p>开启<strong>MPMediaLibrary</strong>通知。</p>

<pre><code class="c">[[MPMediaLibrary defaultMediaLibrary] beginGeneratingLibraryChangeNotifications];
</code></pre>

<h2>关闭通知</h2>

<p>关闭<strong>MPMediaLibrary</strong>通知。</p>

<pre><code class="c">[[MPMediaLibrary defaultMediaLibrary] endGeneratingLibraryChangeNotifications];
</code></pre>

<h2>MPMediaQuery</h2>

<p>通过<strong>MPMediaQuery</strong>获取iTunes中音乐列表，可以自定义列表类型，调用<code>-collection</code>方法，返回对应列表的数组。数组中元素为<strong>MPMediaItemCollection</strong>类型。</p>

<pre><code class="c">//  create
MPMediaQuery *mediaQuery = [MPMediaQuery playlistQuery];
//  groupType
mediaQuery.groupingType = MPMediaGroupingAlbumArtist;
//  query
NSArray&lt;MPMediaItemCollection *&gt; *mediaCollections = [mediaQuery collections];
</code></pre>

<h2>MPMediaItem</h2>

<p>通过<strong>MPMediaItemCollection</strong>获取对应的<strong>MPMediaItem</strong>，对应多媒体文件。通过<strong>MPMediaItem</strong>获取文件相关信息。导出时需要文件地址<strong>assetURL</strong>。</p>

<pre><code class="c">NSMutableArray&lt;MPMediaItem *&gt; mediaItems = [NSMutableArray array];
for (MPMediaItemCollection *collection in mediaCollections) {
  //  mediaItem
  MPMediaItem *mediaItem = [collection representativeItem];
  //  歌曲名称
  NSString *title = [mediaItem valueForProperty:MPMediaItemPropertyTitle];
  //  演唱者
  NSString *artist = [mediaItem valueForProperty:MPMediaItemPropertyArtist];
  //  歌曲封面
  MPMediaItemArtwork *artwork = [mediaItem valueForProperty:MPMediaItemPropertyArtwork];
  //  歌曲格式
  NSString *form = self.assetURL.pathExtension;
  //  歌曲地址，本地iTunes中地址，可用于导出歌曲
  NSURL *assetURL = [mediaItem valueForProperty:MPMediaItemPropertyAssetURL];
  //  add
  [mediaItems addObject:mediaItem];
}
</code></pre>

<h2>Play</h2>

<p>获取到<strong>MPMediaItemCollection</strong>后，可以选择使用iTunes直接播放该文件。</p>

<pre><code class="c">MPMediaItemCollection *mediaItemCollection = [mediaCollections firstObject];
MPMediaItem *selectedItem = [collection representativeItem];
[[MPMusicPlayerController iPodMusicPlayer] setQueueWithItemCollection:mediaItemCollection];
[[MPMusicPlayerController iPodMusicPlayer] setNowPlayingItem:selectedItem];
[[MPMusicPlayerController iPodMusicPlayer] play];
</code></pre>

<h2>Export Music to Local Sandbox</h2>

<p>导出音乐文件至本地沙盒目录下：</p>

<p>1、获取音乐文件名（title）及input地址（<strong>assetURL</strong>）；</p>

<p>2、获取沙盒目录，并创建output地址（<strong>outputURL</strong>）；</p>

<p>3、获取<strong>AVURLAsset</strong>；</p>

<p>4、使用<strong>AVAssetExportSession</strong>导出AVURLAsset。</p>

<pre><code class="c">for (MPMediaItem *musicItem in musicItems) {
    //  获取文件名及地址
    NSString *title = [mediaItem valueForProperty:MPMediaItemPropertyTitle];
    NSURL *assetURL = [mediaItem valueForProperty:MPMediaItemPropertyAssetURL];
    if (assetURL &amp;&amp; [self validIpodLibraryURL:assetURL]) {
      //  创建 output URL，存入沙盒目录下，以文件名为标识
      NSString *pathExtension = assetURL.pathExtension;
      NSArray *paths = NSSearchPathForDirectoriesInDomains(
          NSDocumentDirectory, NSUserDomainMask, YES);
      NSString *documentsDirectory = [paths firstObject];
      NSURL *outputURL =
          [[NSURL fileURLWithPath:[documentsDirectory
                                      stringByAppendingPathComponent:title]]
              URLByAppendingPathExtension:pathExtension];
      //  保证无重复路径
      [[NSFileManager defaultManager] removeItemAtURL:outputURL error:nil];
      //  获取Asset
      NSDictionary *options = [[NSDictionary alloc] init];
      AVURLAsset *asset = [AVURLAsset URLAssetWithURL:assetURL options:options];
      if (asset) {
        //  创建export session
        AVAssetExportSession *exportSession = [[AVAssetExportSession alloc]
            initWithAsset:asset
               presetName:AVAssetExportPresetPassthrough];
        if (exportSession) {
            //  导出类型
            if ([pathExtension compare:@"m4a"] == NSOrderedSame) {
              exportSession.outputFileType = AVFileTypeAppleM4A;
            } else if ([pathExtension compare:@"wav"] == NSOrderedSame) {
              exportSession.outputFileType = AVFileTypeWAVE;
            } else if ([pathExtension compare:@"aif"] == NSOrderedSame) {
              exportSession.outputFileType = AVFileTypeAIFF;
            } else if ([pathExtension compare:@"m4v"] == NSOrderedSame) {
              exportSession.outputFileType = AVFileTypeAppleM4V;
            }
            //  导出地址
            exportSession.outputURL = outputURL;
            //  导出
            [exportSession exportAsynchronouslyWithCompletionHandler:^{
              //  状态回调
              if (completion) {
                switch (exportSession.status) {
                case AVAssetExportSessionStatusFailed:
                  NSLog(@"Failed");
                  break;
                case AVAssetExportSessionStatusCancelled:
                  NSLog(@"Cancelled");
                  break;
                case AVAssetExportSessionStatusCompleted:
                  NSLog(@"Completed");
                  break;
                default:
                  break;
                }
              }
            }];
        }
      }
    }
  }
</code></pre>

<pre><code class="c">- (BOOL)validIpodLibraryURL:(NSURL *)url {
  NSString *IPOD_SCHEME = @"ipod-library";
  if (nil == url)
    return NO;
  if (nil == url.scheme)
    return NO;
  if ([url.scheme compare:IPOD_SCHEME] != NSOrderedSame)
    return NO;
  if ([url.pathExtension compare:@"aif"] != NSOrderedSame &amp;&amp;
      [url.pathExtension compare:@"m4a"] != NSOrderedSame &amp;&amp;
      [url.pathExtension compare:@"wav"] != NSOrderedSame &amp;&amp;
      [url.pathExtension compare:@"m4v"] != NSOrderedSame) {
    return NO;
  }
  return YES;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Core Data Tutorial iOS 10]]></title>
    <link href="http://sxgfxm.github.io/blog/2017/01/23/core-data-tutorial-ios-10/"/>
    <updated>2017-01-23T16:40:01+08:00</updated>
    <id>http://sxgfxm.github.io/blog/2017/01/23/core-data-tutorial-ios-10</id>
    <content type="html"><![CDATA[<p>iOS 10 CoreData使用总结。</p>

<!--more-->


<h2>Include Core Data</h2>

<p>创建工程时选择包含CoreData，系统会自动生成相关文件。</p>

<h2>Add Entity</h2>

<p>在xcdatamodeld文件中，添加Entity。<br/>
Entity相当于表，其中Attributes相当于表中的记录，对应需要存储的数据。</p>

<h2>Create NSManagedObject Subclass</h2>

<p>创建Entity对应的model。<br/>
在Xcode8中，创建方式为Editor ———— Create NSManagedObject Subclass。<br/>
注意，创建之前需要将数据库的Codegen设置为Manual/None，否则会报duplicate错误。</p>

<h2>Get NSPersistentContainer Object</h2>

<p>iOS 10 对Core Data做了很大的优化和改进，大大简化了Core Data的使用。<br/>
NSPersistentContainer是新添加的类，从此大部分情况下无需再和NSManagedObjectContext、NSPersistentStoreCoordinator打交道。<br/>
获取NSPersistentContainer</p>

<pre><code class="objective-c">#import 'AppDelegate.h'

@interface ViewController ()

@property(nonatomic, strong) NSPersistentContainer *container;

@end

@implementation ViewController

-(void)viewDidLoad{
  [super viewDidLoad];
  self.container = ((AppDelegate *)[UIApplication sharedApplication].delegate).persistentContainer;
}

@end
</code></pre>

<h2>Add Record</h2>

<p>导入通过系统创建的Create NSManagedObject Subclass，通过NSEntityDescription增添记录。</p>

<pre><code class="objective-c">#import "People+CoreDataProperties.h"

#define kEntityName @"People"

-(void)addRecord{
  People *people = [NSEntityDescription insertNewObjectForEntityForName:kEntityName inManagedObjectContext:self.container.viewContext];
  people.name = @"Tom";
  people.sex = YES;
  people.age = 23;
}
</code></pre>

<h2>Fetch Record</h2>

<p>通过NSFetchRequest查询记录。</p>

<pre><code class="objective-c">-(void)fetchRecord{
  NSFetchRequest *fetchRequest = [NSFetchRequest fetchRequestWithEntityName:kEntityName];
  NSArray&lt;People *&gt; *results = [self.container.viewContext executeFetchRequest:fetchRequest error:nil];
  for (People *people in results) {
    NSLog(@"name %@", people.name);
    NSLog(@"sex  %@", people.sex);
    NSLog(@"age  %@", people.age);
  }
}
</code></pre>

<h2>Update Record</h2>

<p>先fetch需要修改的记录，然后直接修改即可。</p>

<pre><code class="objective-c">-(void)updateRecord{
  NSFetchRequest *fetchRequest = [NSFetchRequest fetchRequestWithEntityName:kEntityName];
  NSPredicate *predicate = [NSPredicate predicateWithFormat:@"name == %@", @"Tom"];
  fetchRequest.predicate = predicate;
  NSArray&lt;People *&gt; *results = [self.container.viewContext executeFetchRequest:fetchRequest error:nil];
  for (People *people in results) {
    people.name = @"Lily";
  }
}
</code></pre>

<h2>Delete Record</h2>

<p>先fetch需要删除的记录，然后通过NSManagedObjectContext删除即可。</p>

<pre><code class="objective-c">-(void)deleteRecord{
  NSFetchRequest *fetchRequest = [NSFetchRequest fetchRequestWithEntityName:kEntityName];
  NSPredicate *predicate = [NSPredicate predicateWithFormat:@"name == %@", @"Lily"];
  fetchRequest.predicate = predicate;
  NSArray&lt;People *&gt; *results = [self.container.viewContext executeFetchRequest:fetchRequest error:nil];
  for (People *people in results) {
    [self.container.viewContext deleteObject:people];
  }
}
</code></pre>

<h2>GitHub源码</h2>

<p><a href="https://github.com/sxgfxm/CoreDataDemo">CoreDataDemo</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Prevent Duplicate Clicks]]></title>
    <link href="http://sxgfxm.github.io/blog/2017/01/17/prevent-duplicate-clicks/"/>
    <updated>2017-01-17T16:19:36+08:00</updated>
    <id>http://sxgfxm.github.io/blog/2017/01/17/prevent-duplicate-clicks</id>
    <content type="html"><![CDATA[<p>在应用开发过程中，点击事件为耗时操作或者延时响应，例如请求服务器数据，push至下一个界面，如果不处理用户重复点击事件，将会重复触发事件。下面介绍几种简单的处理方法。</p>

<!--more-->


<h2>Button</h2>

<p>点击后button状态置为disabled；
操作完成后button状态置为enabled；</p>

<h2>View</h2>

<p>根据处理状态设置userInteractiveEnable。</p>

<h2>Push</h2>

<p>方法一：
    点击后button状态置为disabled；
    viewDidDisappear置为enabled；</p>

<p>方法二：在push前添加判断：如果和上一个视图控制器一样，隔绝此次操作。</p>

<pre><code class="objective-c">if ([self.navigationController.topViewController isKindOfClass:[MyViewController class]]) {
    return;
}
</code></pre>

<h2>时间监听类</h2>

<p>用一个静态变量记录上一次点击的时间，每次点击check时间间隔是否达到要求。</p>

<h2>Runtime</h2>

<p>使用Runtime监听点击事件，忽略重复点击。
添加一个eventTimeInterval属性，使其规定时间内只能响应一次点击事件。</p>

<p>参考<a href="http://www.cnblogs.com/wanxudong/p/5984941.html">iOS防止重复点击button</a></p>

<p>.h</p>

<pre><code>#import &lt;UIKit/UIKit.h&gt;

@interface UIButton (WXD)

/**
*  为按钮添加点击间隔 eventTimeInterval秒
*/
@property (nonatomic, assign) NSTimeInterval eventTimeInterval;

@end
</code></pre>

<p>.m</p>

<pre><code class="objective-c">#import "UIButton+WXD.h"
#import &lt;objc/runtime.h&gt;
#define defaultInterval 1  //默认时间间隔

@interface UIButton ()

/**
*  bool YES 忽略点击事件   NO 允许点击事件
*/
@property (nonatomic, assign) BOOL isIgnoreEvent;

@end

@implementation UIButton (WXD)

static const char *UIControl_eventTimeInterval = "UIControl_eventTimeInterval";
static const char *UIControl_enventIsIgnoreEvent = "UIControl_enventIsIgnoreEvent";


// runtime 动态绑定 属性
- (void)setIsIgnoreEvent:(BOOL)isIgnoreEvent
{
    objc_setAssociatedObject(self, UIControl_enventIsIgnoreEvent, @(isIgnoreEvent), OBJC_ASSOCIATION_RETAIN_NONATOMIC);
}
- (BOOL)isIgnoreEvent{
    return [objc_getAssociatedObject(self, UIControl_enventIsIgnoreEvent) boolValue];
}

- (NSTimeInterval)eventTimeInterval
{
  return [objc_getAssociatedObject(self, UIControl_eventTimeInterval) doubleValue];
}

- (void)setEventTimeInterval:(NSTimeInterval)eventTimeInterval
{
 objc_setAssociatedObject(self, UIControl_eventTimeInterval, @(eventTimeInterval), OBJC_ASSOCIATION_RETAIN_NONATOMIC);
}

+ (void)load
{
  // Method Swizzling
 static dispatch_once_t onceToken;
 dispatch_once(&amp;onceToken, ^{
       SEL selA = @selector(sendAction:to:forEvent:);
       SEL selB = @selector(_wxd_sendAction:to:forEvent:);
       Method methodA = class_getInstanceMethod(self,selA);
       Method methodB = class_getInstanceMethod(self, selB);

       BOOL isAdd = class_addMethod(self, selA, method_getImplementation(methodB), method_getTypeEncoding(methodB));

       if (isAdd) {
           class_replaceMethod(self, selB, method_getImplementation(methodA), method_getTypeEncoding(methodA));
       }else{
           //添加失败了 说明本类中有methodB的实现，此时只需要将methodA和methodB的IMP互换一下即可。
          method_exchangeImplementations(methodA, methodB);
      }
 });
}

- (void)_wxd_sendAction:(SEL)action to:(id)target forEvent:(UIEvent *)event
{
  self.eventTimeInterval = self.eventTimeInterval == 0 ? defaultInterval : self.eventTimeInterval;
  if (self.isIgnoreEvent){
      return;
  }else if (self.eventTimeInterval &gt; 0){
      dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(self.eventTimeInterval * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{
       [self setIsIgnoreEvent:NO];
       });
  }

  self.isIgnoreEvent = YES;
  // 这里看上去会陷入递归调用死循环，但在运行期此方法是和sendAction:to:forEvent:互换的，相当于执行sendAction:to:forEvent:方法，所以并不会陷入死循环。
  [self _wxd_sendAction:action to:target forEvent:event];
}  
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Smooth Gradient Polyline]]></title>
    <link href="http://sxgfxm.github.io/blog/2016/10/27/smooth-gradient-polyline/"/>
    <updated>2016-10-27T15:47:23+08:00</updated>
    <id>http://sxgfxm.github.io/blog/2016/10/27/smooth-gradient-polyline</id>
    <content type="html"><![CDATA[<h2>Introduction</h2>

<p>近年来，人们越来越注重运动锻炼，运动相关App层出不穷。其中运动路径追踪是一个重要的功能点。可以很容易的使用<strong>MKPolyline</strong>实现单色路径追踪。更进一步，如果想通过路径的不同颜色反映出运动过程中的速度变化，如<strong>Nike+</strong>类似的效果，需要更多的工作。本文主要讨论如何绘制<strong>平滑渐变</strong>的运动路径。</p>

<!-- more -->


<p><img src="http://ofj92itlz.bkt.clouddn.com/GradientPolyline:nike+.jpeg" alt="" /></p>

<p><img src="http://ofj92itlz.bkt.clouddn.com/GradientPolyline:ditongfilter.jpeg" alt="" /></p>

<p>上图为优化后的渐变色路径，图下方红色曲线为运动过程的速度曲线。</p>

<h2>主要流程</h2>

<ol>
<li>获取运动过程中GPS信息及对应的速度值；</li>
<li>使用<strong>低通滤波</strong>处理速度数据；</li>
<li>通过<strong>MKMapView</strong>转换坐标至对应大小的UIView；</li>
<li>使用<strong>CAGradientLayer</strong>及<strong>CAShaperLayer</strong>分段绘制渐变路径；</li>
</ol>


<h2>获取运动过程中GPS信息及对应的速度值</h2>

<p>可以使用<strong>CoreLocation</strong>获取GPS信息并计算对应的速度值。关于GPS坐标在中国大陆偏移及GPS坐标是否在中国大陆的判断方法，请参考<a href="https://sxgfxm.github.io/blog/2016/10/19/iospan-duan-gpszuo-biao-shi-fou-zai-zhong-guo/">另一篇博文</a>。本文着重探讨路径的绘制，所以模拟产生随机的GPS和速度数据。</p>

<h2>使用<strong>低通滤波</strong>处理速度数据</h2>

<p>因为所绘路径的颜色不同，所以只能分段绘制。</p>

<p>如果各分段为纯色，则绘制出的路径略显生硬，无法体现出过渡效果（如下图）。</p>

<p><img src="http://ofj92itlz.bkt.clouddn.com/GradientPolyline:pure.jpeg" alt="" /></p>

<p>如果根据速度直接绘制成渐变色，因为速度波动的原因，渐变效果并不理想（如下图）。</p>

<p><img src="http://ofj92itlz.bkt.clouddn.com/GradientPolyline:Gradient.jpeg" alt="" /></p>

<p>所以需要预先处理速度数据，使速度数据变得平滑，渐变的效果才好。本人分别使用了<strong>滑动窗口滤波</strong>和<strong>低通滤波</strong>，对比之下，<strong>低通滤波</strong>表现更好。</p>

<p><img src="http://ofj92itlz.bkt.clouddn.com/GradientPolyline:origin.jpeg" alt="" /></p>

<p>上图为原数据效果。</p>

<p><img src="http://ofj92itlz.bkt.clouddn.com/GradientPolyline:smoothwindow.jpeg" alt="" /></p>

<p>上图为滑动窗口平滑效果。</p>

<p><img src="http://ofj92itlz.bkt.clouddn.com/GradientPolyline:ditongfilter.jpeg" alt="" /></p>

<p>上图为低通滤波平滑效果，滤波参数可以根据需要调整。</p>

<h2>通过<strong>MKMapView</strong>转换坐标至对应大小的UIView</h2>

<p>首先需要说明的是，本文的方法将路径绘制在与MKMapView大小一致的UIView上，而非直接以MKOverlay的形式绘制在MKMapView上，所以只能看到路径大致的轮廓而不能像地图一样缩放。如果想要在地图上直接绘制渐变路径，需要自定义<strong>MKOverlayPathRenderer</strong>，如有需要我再放出来。</p>

<p>坐标转换方法，调用MKMapView的<code>convertCoordinate:toPointToView:</code>方法，即可把地图上的GPS坐标，转换为与地图大小相同的CGPoint，为绘制路径做准备。</p>

<h2>使用<strong>CAGradientLayer</strong>及<strong>CAShaperLayer</strong>分段绘制渐变路径</h2>

<h3>在<strong>CAGradientLayer</strong>上绘制对应的渐变颜色；</h3>

<p>1、渐变方向需要根据路径方向计算；</p>

<pre><code class="objective-c">gradientLayer.startPoint =
        CGPointMake(lastPoint.x / gradientView.frame.size.width,
                    lastPoint.y / gradientView.frame.size.height);
gradientLayer.endPoint =
        CGPointMake(newPoint.x / gradientView.frame.size.width,
                    newPoint.y / gradientView.frame.size.height);
</code></pre>

<p>2、渐变颜色为路径两端速度值映射后的颜色，推荐使用HSB颜色值映射；</p>

<pre><code class="objective-c">CGFloat hue = points[i].speed / self.maxSpeed * self.maxHue;
UIColor *newColor =
        [UIColor colorWithHue:hue saturation:1 brightness:1 alpha:1];
gradientLayer.colors =
        @[ (__bridge id)(lastColor.CGColor), (__bridge id)(newColor.CGColor) ];
</code></pre>

<p>3、渐变起止可按需要自行控制；</p>

<pre><code class="objective-c">gradientLayer.locations = @[ @(0.2), @(0.8) ];
</code></pre>

<h3>在<strong>CAShapeLayer</strong>上绘制对应的路径；</h3>

<p>1、路径的起止坐标为转换后的CGPoint；</p>

<p>2、注意设置<code>shapeLayer.lineCap = kCALineCapRound;</code>，否则路径会断；</p>

<p>3、注意<code>shapeLayer.strokeColor</code>不能为透明色，否则无法mask；</p>

<h3>设置<code>gradientLayer.mask = shapeLayer</code>；</h3>

<h2>总结</h2>

<p>绘制平滑渐变路径的关键在于速度数据的处理，大家可以尝试不同的滤波算法改进绘制效果。绘制路径的技巧也在文中列出，如有问题可以和我交流，大家共同探讨学习。</p>

<h2>Github源码</h2>

<p><a href="https://github.com/sxgfxm/SmoothGradientPolyline">SmoothGradientPolyline</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[XGChart_README]]></title>
    <link href="http://sxgfxm.github.io/blog/2016/10/25/xgchart-readme/"/>
    <updated>2016-10-25T19:52:46+08:00</updated>
    <id>http://sxgfxm.github.io/blog/2016/10/25/xgchart-readme</id>
    <content type="html"><![CDATA[<h2>Introduction</h2>

<p><a href="https://github.com/sxgfxm/XGChart">XGChart</a>是一个简洁的iOS 图表库，可以快速集成自定义折线图，曲线图和条形图。</p>

<!-- more -->


<h2>Install</h2>

<p>首先，下载<strong>XGChart</strong>，将<strong>XGChart</strong>文件夹拖入工程。</p>

<p><img src="http://ofj92itlz.bkt.clouddn.com/XGChart:import2.jpeg" alt="import" /></p>

<p>然后，导入<strong>XGChart.h</strong>头文件，配置参数，创建即可。</p>

<pre><code class="objective-c">#import "XGChart.h"
</code></pre>

<pre><code class="objective-c"> //  configuration
  XGChartConfiguration *configuration = [[XGChartConfiguration alloc] init];
  configuration.chartType = XGChartTypeLineChart;
  configuration.paddingTop = 20;
  configuration.paddingLeft = 20;
  configuration.paddingBottom = 20;
  configuration.paddingRight = 20;
  configuration.xGridCount = 3;
  configuration.yGridCount = 4;
  configuration.gridColor = [UIColor grayColor];
  configuration.xAxisLabelColor = [UIColor whiteColor];
  configuration.xAxisLabelFontSize = 12;
  configuration.yAxisLabelColor = [UIColor whiteColor];
  configuration.yAxisLabelFontSize = 12;
  NSMutableArray&lt;XGChartPoint *&gt; *chartPoints = [[NSMutableArray alloc] init];
  for (int i = 1; i &lt; 31; i++) {
    XGChartPoint *point =
        [[XGChartPoint alloc] initWithX:i andY:arc4random_uniform(100)];
    [chartPoints addObject:point];
  }
  configuration.chartPoints = chartPoints;
  configuration.strokeColor = [UIColor redColor];
  configuration.fillColor = [UIColor redColor];
  configuration.lineWidth = 3;
  //  line chart
  XGChart *lineChart = [[XGChart alloc]
      initWithFrame:CGRectMake(0, 64, self.view.bounds.size.width,
                               (self.view.bounds.size.height - 64) / 3)
      configuration:configuration];
  lineChart.backgroundColor = [UIColor blackColor];
  [self.view addSubview:lineChart];
</code></pre>

<h2>Result</h2>

<p><img src="http://ofj92itlz.bkt.clouddn.com/XGChart:result2.png" alt="" /></p>
]]></content>
  </entry>
  
</feed>

<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Ios | Light's Blog]]></title>
  <link href="http://sxgfxm.github.io/blog/categories/ios/atom.xml" rel="self"/>
  <link href="http://sxgfxm.github.io/"/>
  <updated>2017-06-09T10:11:31+08:00</updated>
  <id>http://sxgfxm.github.io/</id>
  <author>
    <name><![CDATA[Light]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[iOS知识小集-170529]]></title>
    <link href="http://sxgfxm.github.io/blog/2017/06/09/ioszhi-shi-xiao-ji-170529/"/>
    <updated>2017-06-09T10:08:09+08:00</updated>
    <id>http://sxgfxm.github.io/blog/2017/06/09/ioszhi-shi-xiao-ji-170529</id>
    <content type="html"><![CDATA[<h2>Open system wifi settings</h2>

<p><code>[[UIApplication sharedApplication] openURL:[NSURL URLWithString:@"App-Prefs:root=WIFI"]];</code></p>

<!-- more -->


<h2>UITextField</h2>

<pre><code>-(void)setupTextField{
  self.wifiNameTF =
      [[UITextField alloc] initWithFrame:CGRectMake(kScaleFrom_iPhone6_Desgin(16), 0,
                                                    self.view.bounds.size.width - kScaleFrom_iPhone6_Desgin(32),
                                                    kScaleFrom_iPhone6_Desgin(54))];
  self.wifiNameTF.placeholder = @"请输入Wi-Fi名称";
  self.wifiNameTF.font = [UIFont systemFontOfSize:kScaleFrom_iPhone6_Desgin(16)];
  self.wifiNameTF.textColor = UIColorFromRGBA(0xff16181d);
  self.wifiNameTF.clearButtonMode = UITextFieldViewModeWhileEditing;
  self.wifiNameTF.autocapitalizationType = UITextAutocapitalizationTypeNone;
  self.wifiNameTF.returnKeyType = UIReturnKeyDone;
  self.wifiNameTF.delegate = self;
  self.wifiNameTF.secureTextEntry = YES;
  self.wifiNameTF.rightView = secureBtn;
  self.wifiNameTF.rightViewMode = UITextFieldViewModeAlways;
  [self.view addSubview:self.wifiNameTF];
}
</code></pre>

<h2>Gradient flow animation</h2>

<p>两倍长度，添加左右移动动画，并添加左右两边覆盖层。</p>

<pre><code>  //  progress bar
  self.progressBar =
      [[UIView alloc] initWithFrame:CGRectMake((self.view.bounds.size.width - kScaleFrom_iPhone6_Desgin(120)) / 2,
                                               kScaleFrom_iPhone6_Desgin(360), kScaleFrom_iPhone6_Desgin(120),
                                               kScaleFrom_iPhone6_Desgin(4))];
  [self.view addSubview:self.progressBar];
  self.gradientLayer = [CAGradientLayer layer];
  self.gradientLayer.frame =
      CGRectMake(-kScaleFrom_iPhone6_Desgin(120), 0, kScaleFrom_iPhone6_Desgin(240), kScaleFrom_iPhone6_Desgin(4));
  self.gradientLayer.locations = @[ @0, @0.15, @0.3, @0.5, @0.65, @0.8, @1 ];
  self.gradientLayer.colors = @[
    (__bridge id)UIColorFromRGBA(0xff1af28f)
        .CGColor,
    (__bridge id)UIColorFromRGBA(0xff0de9c5).CGColor,
    (__bridge id)UIColorFromRGBA(0xff3293fe).CGColor,
    (__bridge id)UIColorFromRGBA(0xff1af28f).CGColor,
    (__bridge id)UIColorFromRGBA(0xff0de9c5).CGColor,
    (__bridge id)UIColorFromRGBA(0xff3293fe).CGColor,
    (__bridge id)UIColorFromRGBA(0xff1af28f).CGColor
  ];
  self.gradientLayer.startPoint = CGPointMake(0, 0);
  self.gradientLayer.endPoint = CGPointMake(1, 0);
  [self.progressBar.layer addSublayer:self.gradientLayer];
  CALayer *leftMask = [CALayer layer];
  leftMask.frame =
      CGRectMake(-kScaleFrom_iPhone6_Desgin(120), 0, kScaleFrom_iPhone6_Desgin(120), kScaleFrom_iPhone6_Desgin(4));
  leftMask.backgroundColor = [UIColor whiteColor].CGColor;
  [self.progressBar.layer addSublayer:leftMask];
  CALayer *rightMask = [CALayer layer];
  rightMask.frame =
      CGRectMake(kScaleFrom_iPhone6_Desgin(120), 0, kScaleFrom_iPhone6_Desgin(120), kScaleFrom_iPhone6_Desgin(4));
  rightMask.backgroundColor = [UIColor whiteColor].CGColor;
  [self.progressBar.layer addSublayer:rightMask];
  CABasicAnimation *moveAnimation = [CABasicAnimation animationWithKeyPath:@"position.x"];
  moveAnimation.fromValue = @(self.gradientLayer.position.x);
  moveAnimation.toValue = @(self.gradientLayer.position.x + kScaleFrom_iPhone6_Desgin(120));
  moveAnimation.repeatCount = 100;
  moveAnimation.duration = 2;
  moveAnimation.autoreverses = NO;
  [self.gradientLayer addAnimation:moveAnimation forKey:@"animation"];
</code></pre>

<h2>Alert with text field</h2>

<pre><code>- (void)changeName {
  // 修改昵称提示框
  UIAlertController *alertController =
      [UIAlertController alertControllerWithTitle:@"Title"
                                          message:nil
                                   preferredStyle:UIAlertControllerStyleAlert];
  // 添加输入框
  [alertController addTextFieldWithConfigurationHandler:^(UITextField *_Nonnull textField) {
    textField.placeholder = @"Please input";
  }];
  // 添加确定按钮
  [alertController addAction:[UIAlertAction actionWithTitle:@"Done"
                                                      style:UIAlertActionStyleDefault
                                                    handler:^(UIAlertAction *_Nonnull action) {
                                                      // 获得当前输入的字符串
                                                      NSString *name = alertController.textFields[0].text;
                                                      self.tichomeNameLbl.text = name;
                                                    }]];
  // 添加取消按钮
  [alertController addAction:[UIAlertAction actionWithTitle:@"Cancel"
                                                      style:UIAlertActionStyleCancel
                                                    handler:^(UIAlertAction *_Nonnull action){
                                                    }]];
  [self presentViewController:alertController animated:YES completion:nil];
}
</code></pre>

<h2>UISlider</h2>

<pre><code>-(void)setupSlider{
  self.volumeSlider = [UISlider new];
  [self.volumeSlider addTarget:self action:@selector(changeVolumeAction) forControlEvents:UIControlEventTouchUpInside];
  self.volumeSlider.minimumValueImage = [UIImage imageNamed:@"icVolumeDown"];
  self.volumeSlider.maximumValueImage = [UIImage imageNamed:@"icVolumeUp"];
  [self.volumeSlider setThumbImage:[UIImage imageNamed:@"icVolumeBtn"] forState:UIControlStateNormal];
  [self.volumeSlider setMinimumTrackImage:[UIImage imageNamed:@"minTrackBg"] forState:UIControlStateNormal];
  [self.volumeSlider setMaximumTrackImage:[UIImage imageNamed:@"maxTrackBg"] forState:UIControlStateNormal];
  [self.contentView addSubview:self.volumeSlider];
  [self.volumeSlider mas_makeConstraints:^(MASConstraintMaker *make) {
    make.centerX.equalTo(self.contentView.mas_centerX);
    make.bottom.equalTo(self.contentView.mas_bottom).offset(-kScaleFrom_iPhone6_Desgin(15));
    make.width.equalTo(@(kScaleFrom_iPhone6_Desgin(270)));
  }];
}
</code></pre>

<h2>UITextView</h2>

<pre><code>-(void)setupTextView{
  self.textView = [UITextView new];
  self.textView.backgroundColor = [UIColor clearColor];
  self.textView.text = @"placeholder";
  self.textView.textColor = [[UIColor whiteColor] colorWithAlphaComponent:0.2];
  self.textView.font = [UIFont systemFontOfSize:14];
  self.textView.delegate = self;
  self.textView.autocapitalizationType = UITextAutocapitalizationTypeNone;
  self.textView.returnKeyType = UIReturnKeyDone;
  [self.contentView addSubview:self.textView];
}

//  实现placeholder功能
- (BOOL)textViewShouldBeginEditing:(UITextView *)textView {
  if (self.isEmpty) {
    textView.textColor = [UIColor whiteColor];
    textView.text = @"";
    self.isEmpty = NO;
  }
  return YES;
}

- (void)textViewDidEndEditing:(UITextView *)textView {
  if (textView.text.length == 0) {
    self.isEmpty = YES;
    textView.text = @"placeholder";
    textView.textColor = [[UIColor whiteColor] colorWithAlphaComponent:0.2];
  }
  [textView resignFirstResponder];
}

//  实现换行替换为结束编辑
- (BOOL)textView:(UITextView *)textView shouldChangeTextInRange:(NSRange)range replacementText:(NSString *)text {
  if ([text isEqualToString:@"\n"]) {
    [textView resignFirstResponder];
    return NO;
  }
  return YES;
}
</code></pre>

<h2>IQActionSheetPickerView</h2>

<pre><code>-(void)setupPickerView{
  NSArray *dataSource = @[@"item1",@"item2",@"item3"];
  IQActionSheetPickerView *categoryPicker = [[IQActionSheetPickerView alloc] initWithTitle:@"选择" delegate:self];
  //  tool bar
  [categoryPicker setTitleFont:[UIFont systemFontOfSize:17]];
  [categoryPicker setTitleColor:[UIColor whiteColor]];
  [categoryPicker setToolbarTintColor:[UIColorFromRGBA(0xff26272e) colorWithAlphaComponent:0.6]];
  [categoryPicker setDoneButtonAttributes:@{
    kIQActionSheetAttributesForNormalStateKey : @{
      NSForegroundColorAttributeName : [[UIColor whiteColor] colorWithAlphaComponent:0.5],
      NSFontAttributeName : [UIFont systemFontOfSize:15]
    }
  }];
  [categoryPicker setCancelButtonAttributes:@{
    kIQActionSheetAttributesForNormalStateKey : @{
      NSForegroundColorAttributeName : [[UIColor grayColor] colorWithAlphaComponent:0.5],
      NSFontAttributeName : [UIFont systemFontOfSize:15]
    }
  }];
  //  component
  [categoryPicker setPickerViewBackgroundColor:UIColorFromRGBA(0xff1c1d24)];
  [categoryPicker setPickerComponentsFont:[UIFont systemFontOfSize:16]];
  [categoryPicker setPickerComponentsColor:[UIColor whiteColor]];
  //  data source
  [categoryPicker setTitlesForComponents:@[ dataSource ]];
  if (self.category) {
    [categoryPicker setSelectedTitles:@[ @"item2" ]];
  }
  //  show
  [categoryPicker show];
}

- (void)actionSheetPickerView:(IQActionSheetPickerView *)pickerView didSelectTitles:(NSArray *)titles {
  //  do something with selected item
}
</code></pre>

<h2>NSURLSession</h2>

<p>completion handler 并非在主线程回调。<br/>
UI相关操作必须在主线程执行。</p>

<h2>Protocol Buffers</h2>

<p>Protocol buffers – a language-neutral, platform-neutral, extensible way of serializing structured data for use in communications protocols, data storage, and more.<br/>
Protocol buffers have many advantages over XML for serializing structured data. Protocol buffers:<br/>
  are simpler<br/>
  are 3 to 10 times smaller<br/>
  are 20 to 100 times faster<br/>
  are less ambiguous<br/>
  generate data access classes that are easier to use programmatically</p>

<ol>
<li>protoc</li>
<li>build rules</li>
<li>build phases</li>
</ol>


<h2>Undefined symbols for architecture arm64</h2>

<p>build phases -> compile source</p>

<h2>NSError</h2>

<p>error.localizedDescription</p>

<h2>block</h2>

<p>循环引用。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS知识小集-170522]]></title>
    <link href="http://sxgfxm.github.io/blog/2017/06/09/ioszhi-shi-xiao-ji-170522/"/>
    <updated>2017-06-09T09:57:35+08:00</updated>
    <id>http://sxgfxm.github.io/blog/2017/06/09/ioszhi-shi-xiao-ji-170522</id>
    <content type="html"><![CDATA[<h2>Networking Concepts</h2>

<p><a href="https://developer.apple.com/library/content/documentation/NetworkingInternet/Conceptual/NetworkingConcepts/Introduction/Introduction.html#//apple_ref/doc/uid/TP40012487">Networking Concepts</a></p>

<!-- more -->


<h3>Networking Terminology</h3>

<p><strong>host</strong>: a host is any device that is connected to a network and provides an endpoint for networked communication.It is called a host because it hosts the applications and daemons that run on it.<br/>
<strong>nfrastructure device</strong>: an infrastructure device is any piece of equipment that is responsible for making the network function.
When one host sends data across a network, it divides the data into small pieces called packets.
A packet generally contains three basic parts: a <strong>header</strong> that tells where the packet should be sent, a <strong>payload</strong> that contains the actual data, and a <strong>trailer</strong> that contains checksum information to ensure that the packet was received correctly.<br/>
<strong>encapsulation</strong>: When one packet contains another packet (generally of a different type), this is called encapsulation.</p>

<h3>Networking Layers</h3>

<p><strong>Link Layer</strong>: The bottommost layer is the link layer, or <strong>physical layer</strong>.This layer of the networking stack involves the actual hardware used to communicate with nearby physically connected hosts.A network interface is a piece of hardware that provides a link-layer interconnect.<br/>
<strong>IP Layer</strong>: Sitting on top of the link layer is the IP layer. The IP layer provides packet transport from one host to another in such a way that the packets can pass across multiple physical networks. The path your packets take is called a route, and each link that the packets follow from one router to another along the route is called a hop.To hide this difference, the IP layer splits packets into multiple pieces—a process known as fragmentation—and reassembles them at the other end.<br/>
<strong>Transport Layer</strong>: On top of the IP layer, you’ll find several transport layers. The two most common protocols at this layer are the transmission control protocol (TCP) and the user datagram protocol (UDP). Both TCP and UDP provide basic data transport from one host to another, much like IP, but add the notion of port numbers.<br/>
<strong>UDP</strong><br/>
  No guarantee &mdash;- Like the layers below it, UDP provides no guarantee that the data will ever reach its destination.<br/>
  Low latency &mdash;- UDP may be a good choice for situations where low latency is required.<br/>
  Broadcast messages in IPv4 &mdash;- packets sent to a broadcast address are received by every host within its broadcast domain.<br/>
  Multicast messages &mdash;- UDP packets sent to a multicast address are sent out to any host that subscribes to them.<br/>
  Preservation of record (packet) boundaries &mdash;- With UDP, the receiver sees each message individually instead of as a continuous stream of bytes.<br/>
<strong>TCP </strong> <br/>
  Delivery guarantees &mdash;- Data transmitted using TCP is guaranteed to be received in the order in which it was sent and (connection failures notwithstanding) in its entirety.<br/>
  Congestion control &mdash;- Sending hosts back off the speed of transmission (and retransmission) if data is getting dropped along the way due to an over-utilized link.<br/>
  Flow control &mdash;- When busy, receiving hosts tell sending hosts to wait until they are ready to handle more data.<br/>
  Stream-based data flow &mdash;- Your software sees the data as a series of bytes instead of as a series of discrete records (messages, in UDP parlance)<br/>
  Path MTU discovery &mdash;- TCP chooses the largest packet size that avoids fragmentation en route.<br/>
<strong>Application Layer</strong>: The application layer sits at the top of the protocol stack. This layer includes such protocols as hypertext transfer protocol (HTTP) and file transfer protocol (FTP).</p>

<h3>Understanding Latency</h3>

<p>Latency refers to the round-trip time for a request. Every network has latency.<br/>
The minimum latency between two points on the earth can be calculated by dividing the distance by the speed at which light or electricity moves in a particular medium.<br/>
Routing delays.<br/>
Retransmission and exponential backoff.<br/>
Signal propagation delays within hardware that receives, transmits, forwards, or repeats packets.</p>

<h3>Addressing Schemes and Domain Names</h3>

<p>At every level of networking, each host is assigned one or more numeric identifiers that uniquely represent it within a particular network.<br/>
<strong>Link-Layer Addressing</strong>: At the link layer (physical layer), each network interface is usually identified by a globally unique hardware ID: Ethernet—MAC address etc.The hardware ID is used to determine whether a particular device should listen to a packet or ignore it.<br/>
<strong>IP-Layer Addressing</strong>: At the IP layer and above, hosts are identified by an IP address. An IP address can be in one of two forms: IPv4 or IPv6.<br/>
  <strong>IPv4</strong>: An IPv4 address consists of four bytes, and is usually represented to the user as a series of four numbers separated by decimal points.<br/>
  <strong>IPv6</strong>: An IPv6 address is a 128-bit value, and is usually written as eight groups of 16-bit hexadecimal numbers separated by colons. Leading zeros in each group can be omitted as long as there is at least one digit in each group.<br/>
<strong>Domain Name System (DNS)</strong>:
A domain name is a human-readable name that describes a particular host. Each domain name is made up of a series of parts separated by periods.<br/>
Features:<br/>
  Minimize service disruption when an IP address changes.<br/>
  Allow a host to be accessed by more than one address.<br/>
  Allow multiple physical hosts to pretend to be a single host.<br/>
  Can adapt to changes in the underlying technology.<br/>
  Being easier to remember.</p>

<h3>Packet Routing and Delivery</h3>

<p>Each packet contains a the link-layer address of its intended recipient.</p>

<h2>Networking Overview</h2>

<p><a href="https://developer.apple.com/library/content/documentation/NetworkingInternetWeb/Conceptual/NetworkingOverview/Introduction/Introduction.html#//apple_ref/doc/uid/TP40010220">Networking Overview</a></p>

<h2>Bonjour Overview</h2>

<p><a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/NetServices/Introduction.html#//apple_ref/doc/uid/10000119i">Bonjour Overview</a></p>

<p>The Bonjour zero-configuration networking architecture provides support for publishing and discovering TCP/IP-based services on a local area or wide area network.<br/>
Bonjour is Apple’s implementation of a suite of zero-configuration networking protocols. Bonjour is designed to make network configuration easier for users.</p>

<h2>NSNetServices and CFNetworkServices Programming Guide</h2>

<p><a href="https://developer.apple.com/library/content/documentation/Networking/Conceptual/NSNetServiceProgGuide/Introduction.html#//apple_ref/doc/uid/TP40002736">NSNetServices and CFNetworkServices Programming Guide</a></p>

<h2>DNS Service Discovery Programming Guide</h2>

<p><a href="https://developer.apple.com/library/content/documentation/Networking/Conceptual/dns_discovery_api/Introduction.html#//apple_ref/doc/uid/TP30000964">DNS Service Discovery Programming Guide</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS知识小集-170515]]></title>
    <link href="http://sxgfxm.github.io/blog/2017/05/17/ioszhi-shi-xiao-ji-170515/"/>
    <updated>2017-05-17T16:57:00+08:00</updated>
    <id>http://sxgfxm.github.io/blog/2017/05/17/ioszhi-shi-xiao-ji-170515</id>
    <content type="html"><![CDATA[<h2>更新cocoapods版本</h2>

<p>正式版：<code>sudo gem install cocoapods</code><br/>
开发版：<code>sudo gem install cocoapods --pre </code></p>

<!-- more -->


<h2>Get local bundle</h2>

<p>通过<code>frameworkName</code>和<code>bundleName</code>获取对应bundle。</p>

<pre><code class="c">+ (NSBundle *)getBundleWithFrameworkName:(NSString *)frameworkName bundleName:(NSString *)bundleName {
  NSString *tmpBundleName = [bundleName copy];
  if (![bundleName hasSuffix:@".bundle"]) {
    tmpBundleName = [NSString stringWithFormat:@"%@.bundle", tmpBundleName];
  }

  NSString *mainBundlePath = [[NSBundle mainBundle] resourcePath];
  NSString *bundlePath = [mainBundlePath stringByAppendingPathComponent:tmpBundleName];
  NSBundle *bundle = [NSBundle bundleWithPath:bundlePath];
  if (bundle) {
    return bundle;
  }

  NSString *tempFramework = [frameworkName copy];
  NSString *frameExtension = @".framework";
  if (![tempFramework hasSuffix:frameExtension]) {
    tempFramework = [tempFramework stringByAppendingString:frameExtension];
  }

  NSString *path = [[[NSBundle mainBundle] privateFrameworksPath] stringByAppendingPathComponent:tempFramework];
  return [NSBundle bundleWithPath:[path stringByAppendingPathComponent:tmpBundleName]];
}
</code></pre>

<h2>Localized string in cocoapods</h2>

<p>在自定义pod中添加语言本地化：<br/>
1. 为<code>MyPod</code>添加语言路径<code>MyPod/Languages/**/*</code>,pod中使用的不同语言的<code>.strings</code>存放在该目录下；<br/>
2. 在<code>MyPod.podspec</code>文件中添加语言bundle：<code>s.resource_bundles = {'LanguageBundle' =&gt; ['MyPod/Languages/**/*']}</code>；<br/>
3. 添加简便调用方法：</p>

<pre><code class="c">NSString *XGLocalizedString(NSString *key, NSString *comment) {
  return [XGFitnessLocalize localizedString:key];
}

+ (NSString *)localizedString:(NSString *)key {
  //  key == nil, return nil;
  if (!key) {
    return key;
  }
  //  system language
  NSUserDefaults *defaults = [NSUserDefaults standardUserDefaults];
  NSArray *languages = [defaults objectForKey:kAppleLanguageKey];
  NSString *language = [languages firstObject];
  //  set default language
  NSString *fileNamePrefix = language;
  if (!([fileNamePrefix isEqualToString:kLanguageEnglish] ||
        [fileNamePrefix isEqualToString:kLanguageSimplifiedChinese] ||
        [fileNamePrefix isEqualToString:kLanguageTraditionalChinese])) {
    fileNamePrefix = kDefaultLanguage;
  }
  //  language bundle
  NSBundle *languageBundle =
      [WWFitnessBundleUtil getBundleWithFrameworkName:kFrameworkName bundleName:kLanguageBundleName];
  //  lproj bundle
  NSString *path = [languageBundle pathForResource:fileNamePrefix ofType:@"lproj"];
  NSBundle *lprojBundle = [NSBundle bundleWithPath:path];
  //  localized string
  NSString *localizedString = [lprojBundle localizedStringForKey:key value:@"" table:@"Localizable"];
  if (!localizedString) {
    localizedString = key;
  }
  return localizedString;
}
</code></pre>

<h2>Image in cocoapods</h2>

<p>在自定义pod中添加图片步骤：<br/>
1. 为<code>MyPod</code>添加图片路径<code>MyPod/Assets/Images</code>,pod中使用的图片存放在该目录下；<br/>
2. 在<code>MyPod.podspec</code>文件中添加图片bundle：<code>s.resource_bundles = {'ImageBundle' =&gt; ['MyPod/Assets/Images/**/*']}</code>；<br/>
3. 为<code>UIImage</code>添加类别方法<code>bundleImageNamed:</code></p>

<pre><code class="objective-c">@implementation UIImage (BundleImage)

+ (UIImage *)bundleImageNamed:(NSString *)name {
  NSBundle *imageBundle = [WWFitnessBundleUtil getBundleWithFrameworkName:@"MyPod" bundleName:@"ImageBundle"];
  return [UIImage imageNamed:name inBundle:imageBundle compatibleWithTraitCollection:nil];
}

@end
</code></pre>

<h2>Font in cocoapods</h2>

<p>自定义字体无法静态添加到自定义pod中，需要动态注册字体才能使用。<br/>
1. 为<code>MyPod</code>添加字体路径<code>MyPod/Fonts</code>,pod中使用的字体存放在该目录下；<br/>
2. 在<code>MyPod.podspec</code>文件中添加字体bundle：<code>s.resource_bundles = {'FontBundle' =&gt; ['MyPod/Fonts/*']}</code>；<br/>
3. 创建注册字体方法，并在使用前仅调用一次。</p>

<pre><code class="objective-c">#import &lt;CoreText/CTFontManager.h&gt;

+ (void)registerFitnessFont {
  [self registerFitnessFont:@"DIN-Regular"];
  [self registerFitnessFont:@"DIN-Medium"];
  [self registerFitnessFont:@"DIN-Bold"];
}

+ (void)registerFitnessFont:(NSString *)fontName {
  NSBundle *fontBundle = [WWFitnessBundleUtil getBundleWithFrameworkName:@"MyPod" bundleName:@"FontBundle"];
  NSURL *fontURL = [fontBundle URLForResource:fontName withExtension:@"otf" /*or TTF*/];
  NSData *inData = [NSData dataWithContentsOfURL:fontURL];
  CFErrorRef error;
  CGDataProviderRef provider = CGDataProviderCreateWithCFData((CFDataRef)inData);
  CGFontRef font = CGFontCreateWithDataProvider(provider);
  if (!CTFontManagerRegisterGraphicsFont(font, &amp;error)) {
    CFStringRef errorDescription = CFErrorCopyDescription(error);
    NSLog(@"Failed to load font: %@", errorDescription);
    CFRelease(errorDescription);
  }
  CFSafeRelease(font);
  CFSafeRelease(provider);
}

void CFSafeRelease(CFTypeRef cf) {
  if (cf != NULL) {
    CFRelease(cf);
  }
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS知识小集-170508]]></title>
    <link href="http://sxgfxm.github.io/blog/2017/05/17/ioszhi-shi-xiao-ji-170508/"/>
    <updated>2017-05-17T16:52:43+08:00</updated>
    <id>http://sxgfxm.github.io/blog/2017/05/17/ioszhi-shi-xiao-ji-170508</id>
    <content type="html"><![CDATA[<h2>Carthage</h2>

<p>安装：<code>brew install carthage</code><br/>
添加：<code>Cartfile</code><br/>
运行：<code>carthage update</code><br/>
添加：<code>Carthage/Build/.framework</code></p>

<!-- more -->


<h2>防止重复push/present类型相同的controller</h2>

<ol>
<li>找到最上层view controller；</li>
<li>判断最上层view controller与待展示view controller是否类型相同；</li>
<li>如果类型不同，才进行操作。
获取最底层view controller：<code>[UIApplication sharedApplication].delegate.window.rootViewController</code>。<br/>
获取最上层view controller：</li>
</ol>


<pre><code>+ (UIViewController *)topViewController {
  return [self
      topViewControllerWithRootViewController:[UIApplication sharedApplication].delegate.window.rootViewController];
}

+ (UIViewController *)topViewControllerWithRootViewController:(UIViewController *)rootViewController {
  NSLog(@"root to top vc:%@", NSStringFromClass([rootViewController class]));
  if ([rootViewController isKindOfClass:[MMDrawerController class]]) {
    MMDrawerController *mmdVc = (MMDrawerController *)rootViewController;
    return [self topViewControllerWithRootViewController:mmdVc.centerViewController];
  } else if ([rootViewController isKindOfClass:[UITabBarController class]]) {
    UITabBarController *tabBarController = (UITabBarController *)rootViewController;
    return [self topViewControllerWithRootViewController:tabBarController.selectedViewController];
  } else if ([rootViewController isKindOfClass:[UINavigationController class]]) {
    UINavigationController *navigationController = (UINavigationController *)rootViewController;
    return [self topViewControllerWithRootViewController:navigationController.visibleViewController];
  } else if (rootViewController.presentedViewController) {
    UIViewController *presentedViewController = rootViewController.presentedViewController;
    return [self topViewControllerWithRootViewController:presentedViewController];
  } else {
    return rootViewController;
  }
}
</code></pre>

<h2>Create Groups vs Create Folder References</h2>

<p>Group：不创建文件夹，不能同名； <br/>
Folder：创建文件夹，可以重名；</p>

<h2>拉伸Image</h2>

<p>代码：<code>- (UIImage *)resizableImageWithCapInsets:(UIEdgeInsets)capInsets resizingMode:(UIImageResizingMode)resizingMode NS_AVAILABLE_IOS(6_0);</code><br/>
设置：Assets -> Attributes Inspector -> Slicing</p>

<h2>隐藏文件</h2>

<p>显示隐藏文件：<code>defaults write com.apple.finder AppleShowAllFiles -bool true</code><br/>
隐藏隐藏文件：<code>defaults write com.apple.finder AppleShowAllFiles -bool false</code>
重启finder：<code>killall Finder</code></p>

<h2>NavigationBar &amp; ScrollView</h2>

<p>自动：<code>contentOffset.y == -64</code><br/>
手动：<code>self.edgesForExtendedLayout = UIRectEdgeNone;</code>，y轴0点下移64。</p>

<h2>Objective-C static vs external</h2>

<p>static: In C and Objective-C, a static variable or function at global scope means that that symbol has internal linkage.<br/>
external: If you want to have a single global variable, you can&rsquo;t have it in class scope like in C++. One option is to create a global variable with external linkage: declare the variable with the extern keyword in a header file, and then in one source file, define it at global scope without the extern keyword.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS知识小集-170501]]></title>
    <link href="http://sxgfxm.github.io/blog/2017/05/17/ioszhi-shi-xiao-ji-170501/"/>
    <updated>2017-05-17T16:42:40+08:00</updated>
    <id>http://sxgfxm.github.io/blog/2017/05/17/ioszhi-shi-xiao-ji-170501</id>
    <content type="html"><![CDATA[<h1>ComponentKit Tutorial - CollectionView</h1>

<h2>Install</h2>

<p>通过 <strong>Carthage</strong> 安装，在 <strong>Cartfile</strong> 中添加<code>github "facebook/ComponentKit" ~&gt; 0.20</code>，然后运行<code>carthage update</code>，编译完成后，在 <strong>Embedded Binaries</strong> 添加<code>Carthage/Build/iOS/ComponentKit.framework</code>。所有需要使用ComponentKit的源文件需要修改后缀为 <strong>.mm</strong>。</p>

<h2>Philosophy</h2>

<p>Doing so this reverses the traditional approach for a <code>UICollectionViewDataSource</code>. Usually the controller layer will <strong>tell</strong> the <code>UICollectionView</code> to update and then the <code>UICollectionView</code> <strong>ask</strong> the datasource for the data. Here the model is  more Reactive, from an external prospective, the datasource is <strong>told</strong> what changes to apply and then <strong>tell</strong> the collection view to apply the corresponding changes.</p>

<!-- more -->


<h2>步骤</h2>

<h3>CKComponentProvider Protocol</h3>

<p>ViewController需要遵守<code>CKComponentProvider</code>协议，实现<code>+componentForModel: context:</code>方法，将model转换为component。<br/>
在该方法中，通过不同类型的model返回不同类型的component。</p>

<pre><code>+ (CKComponent *)componentForModel:(id&lt;NSObject&gt;)model
                           context:(id&lt;NSObject&gt;)context {
  if ([model isKindOfClass:[NewsModel class]]) {
    return [NewsComponent newWithNewsModel:model context:context];
  }
  return nil;
}
</code></pre>

<h3>FlowLayout</h3>

<pre><code>UICollectionViewFlowLayout *flowLayout = [[UICollectionViewFlowLayout alloc] init];
[flowLayout setScrollDirection:UICollectionViewScrollDirectionVertical];
[flowLayout setMinimumInteritemSpacing:0];
[flowLayout setMinimumLineSpacing:0];
</code></pre>

<h3>CollectionView</h3>

<pre><code>self.collectionView = [[UICollectionView alloc] initWithFrame:self.view.bounds collectionViewLayout:flowLayout];
self.collectionView.delegate = self;
self.collectionView.backgroundColor = [UIColor blackColor];
[self.view addSubview:self.collectionView];
</code></pre>

<h3>Item size range</h3>

<p>Item size range。通过设置<code>CKComponentSizeRangeFlexibleHeight</code>使item的高度自适应。</p>

<pre><code>const CKSizeRange sizeRange = [[CKComponentFlexibleSizeRangeProvider
      providerWithFlexibility:CKComponentSizeRangeFlexibleHeight]
     sizeRangeForBoundingSize:self.collectionView.bounds.size];
</code></pre>

<h3>Context</h3>

<p>Context可以是任何不可变对象，创建component时的不可变上下文信息，比如设备类型，图片下载器。<br/>
<code>MyContext *context = [MyContext new];</code><br/>
预先在主线程加载图片。</p>

<h3>Configuration</h3>

<p>DataSource的configuration，需要 <strong>ComponentProvider</strong>，<strong>sizeRange</strong>，<strong>context</strong> 三个参数。</p>

<pre><code>CKTransactionalComponentDataSourceConfiguration *configuration =
      [[CKTransactionalComponentDataSourceConfiguration alloc]
          initWithComponentProvider:[self class]
                            context:context
                          sizeRange:sizeRange];
</code></pre>

<h3>DataSource</h3>

<p>需要 <strong>collectionView</strong>，<strong>supplementaryViewDataSource</strong>，<strong>configuration</strong> 三个参数。</p>

<pre><code>self.dataSource = [[CKCollectionViewTransactionalDataSource alloc]
           initWithCollectionView:self.collectionView
      supplementaryViewDataSource:nil
                    configuration:configuration];
</code></pre>

<h3>Initial Changeset</h3>

<p>需要初始化DataSource，即向DataSource中添加Section。</p>

<pre><code>CKTransactionalComponentDataSourceChangeset *initialChangeset =
  [[[CKTransactionalComponentDataSourceChangesetBuilder
      transactionalComponentDataSourceChangeset]
      withInsertedSections:[NSIndexSet indexSetWithIndex:0]] build];
[self.dataSource applyChangeset:initialChangeset
                           mode:CKUpdateModeAsynchronous
                       userInfo:nil];
</code></pre>

<h3>insert/update items</h3>

<p>向DataSource中插入Items才能显示。</p>

<pre><code>NSMutableDictionary&lt;NSIndexPath *, NewsModel *&gt; *items = [NSMutableDictionary new];
for (NSInteger i = 0; i &lt; 50; i++) {
  NewsModel *newsModel = [[NewsModel alloc] init];
  newsModel.title = [NSString stringWithFormat:@"News Title: Title %ld", i];
  newsModel.category = @"科技";
  newsModel.updateTime = [NSDate date];
  newsModel.source = @"网易新闻";
  [items setObject:newsModel
            forKey:[NSIndexPath indexPathForRow:i inSection:0]];
}
CKTransactionalComponentDataSourceChangeset *changeset =
  [[[CKTransactionalComponentDataSourceChangesetBuilder
      transactionalComponentDataSourceChangeset]
      withInsertedItems:items] build];
[self.dataSource applyChangeset:changeset
                           mode:CKUpdateModeAsynchronous
                       userInfo:nil];
</code></pre>

<h3>UICollectionView delegate</h3>

<pre><code>- (CGSize)collectionView:(UICollectionView *)collectionView
                  layout:(UICollectionViewLayout *)collectionViewLayout
  sizeForItemAtIndexPath:(NSIndexPath *)indexPath {
  return [self.dataSource sizeForItemAtIndexPath:indexPath];
}

- (void)collectionView:(UICollectionView *)collectionView
       willDisplayCell:(UICollectionViewCell *)cell
    forItemAtIndexPath:(NSIndexPath *)indexPath {
  [self.dataSource announceWillDisplayCell:cell];
}

- (void)collectionView:(UICollectionView *)collectionView
  didEndDisplayingCell:(UICollectionViewCell *)cell
    forItemAtIndexPath:(NSIndexPath *)indexPath {
  [self.dataSource announceDidEndDisplayingCell:cell];
}
</code></pre>
]]></content>
  </entry>
  
</feed>

<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Ios | Light's Blog]]></title>
  <link href="http://sxgfxm.github.io/blog/categories/ios/atom.xml" rel="self"/>
  <link href="http://sxgfxm.github.io/"/>
  <updated>2017-05-17T16:54:59+08:00</updated>
  <id>http://sxgfxm.github.io/</id>
  <author>
    <name><![CDATA[Light]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[iOS知识小集-170508]]></title>
    <link href="http://sxgfxm.github.io/blog/2017/05/17/ioszhi-shi-xiao-ji-170508/"/>
    <updated>2017-05-17T16:52:43+08:00</updated>
    <id>http://sxgfxm.github.io/blog/2017/05/17/ioszhi-shi-xiao-ji-170508</id>
    <content type="html"><![CDATA[<h2>Carthage</h2>

<p>安装：<code>brew install carthage</code><br/>
添加：<code>Cartfile</code><br/>
运行：<code>carthage update</code><br/>
添加：<code>Carthage/Build/.framework</code></p>

<!-- more -->


<h2>防止重复push/present类型相同的controller</h2>

<ol>
<li>找到最上层view controller；</li>
<li>判断最上层view controller与待展示view controller是否类型相同；</li>
<li>如果类型不同，才进行操作。
获取最底层view controller：<code>[UIApplication sharedApplication].delegate.window.rootViewController</code>。<br/>
获取最上层view controller：</li>
</ol>


<pre><code>+ (UIViewController *)topViewController {
  return [self
      topViewControllerWithRootViewController:[UIApplication sharedApplication].delegate.window.rootViewController];
}

+ (UIViewController *)topViewControllerWithRootViewController:(UIViewController *)rootViewController {
  NSLog(@"root to top vc:%@", NSStringFromClass([rootViewController class]));
  if ([rootViewController isKindOfClass:[MMDrawerController class]]) {
    MMDrawerController *mmdVc = (MMDrawerController *)rootViewController;
    return [self topViewControllerWithRootViewController:mmdVc.centerViewController];
  } else if ([rootViewController isKindOfClass:[UITabBarController class]]) {
    UITabBarController *tabBarController = (UITabBarController *)rootViewController;
    return [self topViewControllerWithRootViewController:tabBarController.selectedViewController];
  } else if ([rootViewController isKindOfClass:[UINavigationController class]]) {
    UINavigationController *navigationController = (UINavigationController *)rootViewController;
    return [self topViewControllerWithRootViewController:navigationController.visibleViewController];
  } else if (rootViewController.presentedViewController) {
    UIViewController *presentedViewController = rootViewController.presentedViewController;
    return [self topViewControllerWithRootViewController:presentedViewController];
  } else {
    return rootViewController;
  }
}
</code></pre>

<h2>Create Groups vs Create Folder References</h2>

<p>Group：不创建文件夹，不能同名； <br/>
Folder：创建文件夹，可以重名；</p>

<h2>拉伸Image</h2>

<p>代码：<code>- (UIImage *)resizableImageWithCapInsets:(UIEdgeInsets)capInsets resizingMode:(UIImageResizingMode)resizingMode NS_AVAILABLE_IOS(6_0);</code><br/>
设置：Assets -> Attributes Inspector -> Slicing</p>

<h2>隐藏文件</h2>

<p>显示隐藏文件：<code>defaults write com.apple.finder AppleShowAllFiles -bool true</code><br/>
隐藏隐藏文件：<code>defaults write com.apple.finder AppleShowAllFiles -bool false</code>
重启finder：<code>killall Finder</code></p>

<h2>NavigationBar &amp; ScrollView</h2>

<p>自动：<code>contentOffset.y == -64</code><br/>
手动：<code>self.edgesForExtendedLayout = UIRectEdgeNone;</code>，y轴0点下移64。</p>

<h2>Objective-C static vs external</h2>

<p>static: In C and Objective-C, a static variable or function at global scope means that that symbol has internal linkage.<br/>
external: If you want to have a single global variable, you can&rsquo;t have it in class scope like in C++. One option is to create a global variable with external linkage: declare the variable with the extern keyword in a header file, and then in one source file, define it at global scope without the extern keyword.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS知识小集-170501]]></title>
    <link href="http://sxgfxm.github.io/blog/2017/05/17/ioszhi-shi-xiao-ji-170501/"/>
    <updated>2017-05-17T16:42:40+08:00</updated>
    <id>http://sxgfxm.github.io/blog/2017/05/17/ioszhi-shi-xiao-ji-170501</id>
    <content type="html"><![CDATA[<h1>ComponentKit Tutorial - CollectionView</h1>

<h2>Install</h2>

<p>通过 <strong>Carthage</strong> 安装，在 <strong>Cartfile</strong> 中添加<code>github "facebook/ComponentKit" ~&gt; 0.20</code>，然后运行<code>carthage update</code>，编译完成后，在 <strong>Embedded Binaries</strong> 添加<code>Carthage/Build/iOS/ComponentKit.framework</code>。所有需要使用ComponentKit的源文件需要修改后缀为 <strong>.mm</strong>。</p>

<h2>Philosophy</h2>

<p>Doing so this reverses the traditional approach for a <code>UICollectionViewDataSource</code>. Usually the controller layer will <strong>tell</strong> the <code>UICollectionView</code> to update and then the <code>UICollectionView</code> <strong>ask</strong> the datasource for the data. Here the model is  more Reactive, from an external prospective, the datasource is <strong>told</strong> what changes to apply and then <strong>tell</strong> the collection view to apply the corresponding changes.</p>

<!-- more -->


<h2>步骤</h2>

<h3>CKComponentProvider Protocol</h3>

<p>ViewController需要遵守<code>CKComponentProvider</code>协议，实现<code>+componentForModel: context:</code>方法，将model转换为component。<br/>
在该方法中，通过不同类型的model返回不同类型的component。</p>

<pre><code>+ (CKComponent *)componentForModel:(id&lt;NSObject&gt;)model
                           context:(id&lt;NSObject&gt;)context {
  if ([model isKindOfClass:[NewsModel class]]) {
    return [NewsComponent newWithNewsModel:model context:context];
  }
  return nil;
}
</code></pre>

<h3>FlowLayout</h3>

<pre><code>UICollectionViewFlowLayout *flowLayout = [[UICollectionViewFlowLayout alloc] init];
[flowLayout setScrollDirection:UICollectionViewScrollDirectionVertical];
[flowLayout setMinimumInteritemSpacing:0];
[flowLayout setMinimumLineSpacing:0];
</code></pre>

<h3>CollectionView</h3>

<pre><code>self.collectionView = [[UICollectionView alloc] initWithFrame:self.view.bounds collectionViewLayout:flowLayout];
self.collectionView.delegate = self;
self.collectionView.backgroundColor = [UIColor blackColor];
[self.view addSubview:self.collectionView];
</code></pre>

<h3>Item size range</h3>

<p>Item size range。通过设置<code>CKComponentSizeRangeFlexibleHeight</code>使item的高度自适应。</p>

<pre><code>const CKSizeRange sizeRange = [[CKComponentFlexibleSizeRangeProvider
      providerWithFlexibility:CKComponentSizeRangeFlexibleHeight]
     sizeRangeForBoundingSize:self.collectionView.bounds.size];
</code></pre>

<h3>Context</h3>

<p>Context可以是任何不可变对象，创建component时的不可变上下文信息，比如设备类型，图片下载器。<br/>
<code>MyContext *context = [MyContext new];</code><br/>
预先在主线程加载图片。</p>

<h3>Configuration</h3>

<p>DataSource的configuration，需要 <strong>ComponentProvider</strong>，<strong>sizeRange</strong>，<strong>context</strong> 三个参数。</p>

<pre><code>CKTransactionalComponentDataSourceConfiguration *configuration =
      [[CKTransactionalComponentDataSourceConfiguration alloc]
          initWithComponentProvider:[self class]
                            context:context
                          sizeRange:sizeRange];
</code></pre>

<h3>DataSource</h3>

<p>需要 <strong>collectionView</strong>，<strong>supplementaryViewDataSource</strong>，<strong>configuration</strong> 三个参数。</p>

<pre><code>self.dataSource = [[CKCollectionViewTransactionalDataSource alloc]
           initWithCollectionView:self.collectionView
      supplementaryViewDataSource:nil
                    configuration:configuration];
</code></pre>

<h3>Initial Changeset</h3>

<p>需要初始化DataSource，即向DataSource中添加Section。</p>

<pre><code>CKTransactionalComponentDataSourceChangeset *initialChangeset =
  [[[CKTransactionalComponentDataSourceChangesetBuilder
      transactionalComponentDataSourceChangeset]
      withInsertedSections:[NSIndexSet indexSetWithIndex:0]] build];
[self.dataSource applyChangeset:initialChangeset
                           mode:CKUpdateModeAsynchronous
                       userInfo:nil];
</code></pre>

<h3>insert/update items</h3>

<p>向DataSource中插入Items才能显示。</p>

<pre><code>NSMutableDictionary&lt;NSIndexPath *, NewsModel *&gt; *items = [NSMutableDictionary new];
for (NSInteger i = 0; i &lt; 50; i++) {
  NewsModel *newsModel = [[NewsModel alloc] init];
  newsModel.title = [NSString stringWithFormat:@"News Title: Title %ld", i];
  newsModel.category = @"科技";
  newsModel.updateTime = [NSDate date];
  newsModel.source = @"网易新闻";
  [items setObject:newsModel
            forKey:[NSIndexPath indexPathForRow:i inSection:0]];
}
CKTransactionalComponentDataSourceChangeset *changeset =
  [[[CKTransactionalComponentDataSourceChangesetBuilder
      transactionalComponentDataSourceChangeset]
      withInsertedItems:items] build];
[self.dataSource applyChangeset:changeset
                           mode:CKUpdateModeAsynchronous
                       userInfo:nil];
</code></pre>

<h3>UICollectionView delegate</h3>

<pre><code>- (CGSize)collectionView:(UICollectionView *)collectionView
                  layout:(UICollectionViewLayout *)collectionViewLayout
  sizeForItemAtIndexPath:(NSIndexPath *)indexPath {
  return [self.dataSource sizeForItemAtIndexPath:indexPath];
}

- (void)collectionView:(UICollectionView *)collectionView
       willDisplayCell:(UICollectionViewCell *)cell
    forItemAtIndexPath:(NSIndexPath *)indexPath {
  [self.dataSource announceWillDisplayCell:cell];
}

- (void)collectionView:(UICollectionView *)collectionView
  didEndDisplayingCell:(UICollectionViewCell *)cell
    forItemAtIndexPath:(NSIndexPath *)indexPath {
  [self.dataSource announceDidEndDisplayingCell:cell];
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS知识小集-170424]]></title>
    <link href="http://sxgfxm.github.io/blog/2017/05/17/ioszhi-shi-xiao-ji-170424/"/>
    <updated>2017-05-17T16:38:39+08:00</updated>
    <id>http://sxgfxm.github.io/blog/2017/05/17/ioszhi-shi-xiao-ji-170424</id>
    <content type="html"><![CDATA[<h1>ComponentKit Tutorial - Layout</h1>

<h2>Flexbox Layout</h2>

<p><strong>flex container</strong>：容器。<br/>
main axis：main start， main end。<br/>
cross axis：cross start， cross end。<br/>
<strong>flex item</strong>：成员。<br/>
main size。<br/>
cross size。</p>

<!-- more -->


<h2>Container Properties</h2>

<p>flex-direction：决定主轴方向。</p>

<pre><code>typedef NS_ENUM(NSUInteger, CKStackLayoutDirection) {
  //  垂直方向
  CKStackLayoutDirectionVertical,
  //  水平方向
  CKStackLayoutDirectionHorizontal,
};
</code></pre>

<p>flex-wrap：决定如何换行。<br/>
flex-flow：flex-direction和flex-wrap的简写形式。<br/>
<strong>justify-content</strong>：决定items在主轴上的对齐方式。</p>

<pre><code>/** If no children are flexible, how should this component justify its children in the available space? */
typedef NS_ENUM(NSUInteger, CKStackLayoutJustifyContent) {
  /**
   On overflow, children overflow out of this component's bounds on the right/bottom side.
   On underflow, children are left/top-aligned within this component's bounds.
   */
  //  左对齐
  CKStackLayoutJustifyContentStart,
  /**
   On overflow, children are centered and overflow on both sides.
   On underflow, children are centered within this component's bounds in the stacking direction.
   */
  //  居中
  CKStackLayoutJustifyContentCenter,
  /**
   On overflow, children overflow out of this component's bounds on the left/top side.
   On underflow, children are right/bottom-aligned within this component's bounds.
   */
  //  右对齐
  CKStackLayoutJustifyContentEnd,
};
</code></pre>

<p><strong>align-items</strong>：决定items在交叉轴上的对齐方式。</p>

<pre><code>typedef NS_ENUM(NSUInteger, CKStackLayoutAlignItems) {
  /** Align children to start of cross axis */
  //  交叉轴起点对齐
  CKStackLayoutAlignItemsStart,
  /** Align children with end of cross axis */
  CKStackLayoutAlignItemsEnd,
  //  交叉轴终点对齐
  /** Center children on cross axis */
  //  交叉轴居中对齐
  CKStackLayoutAlignItemsCenter,
  /** Expand children to fill cross axis */
  //  交叉轴方向拉伸
  CKStackLayoutAlignItemsStretch,
};
</code></pre>

<h2>Item Properties</h2>

<p>order：决定item排列顺序，数值越小，排位越靠前。<br/>
<strong>flex-grow</strong>：决定item主轴方向的放大比例，默认为0，即如果存在剩余空间，也不放大。<br/>
如果所有项目的flex-grow属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的flex-grow属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。<br/>
<strong>flex-shrink</strong>：决定item主轴方向的缩小比例，默认为1，即如果空间不足，该item将缩小。<br/>
如果所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小。如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小。<br/>
<strong>flex-basis</strong>：决定了在分配多余空间之前，item的main size大小，根据该值计算主轴是否有多余空间。<br/>
flex：flex-grow, flex-shrink 和 flex-basis的简写。<br/>
<strong>align-self</strong>：决定item单独的对齐方式，可以覆盖 <strong>align-items</strong> 属性。<br/>
默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。</p>

<pre><code>/**
 Each child may override their parent stack's cross axis alignment.
 @see CKStackLayoutAlignItems
 */
typedef NS_ENUM(NSUInteger, CKStackLayoutAlignSelf) {
  /** Inherit alignment value from containing stack. */
  CKStackLayoutAlignSelfAuto,
  CKStackLayoutAlignSelfStart,
  CKStackLayoutAlignSelfEnd,
  CKStackLayoutAlignSelfCenter,
  CKStackLayoutAlignSelfStretch,
};
</code></pre>

<h2>CKStackLayoutComponent</h2>

<p>A simple layout component that stacks a list of children vertically or horizontally.<br/>
动态创建children：</p>

<pre><code>static std::vector&lt;CKStackLayoutComponentChild&gt; createChildren(NSArray* list){
  std::vector&lt;CKStackLayoutComponentChild&gt; children;
  for (VPANewsModel*newsModel in list) {
    children.push_back({[VPANewsComponent newWithNewsModel:newsModel]});
  }
  return children;
}
</code></pre>

<h2>CKBackgroundLayoutComponent</h2>

<p>Lays out a single child component, then lays out a background component behind it stretched to its size.</p>

<pre><code>+ (instancetype)newWithComponent:(CKComponent *)component
                      background:(CKComponent *)background;
</code></pre>

<h2>CKStaticLayoutComponent</h2>

<p>A component that positions children at fixed positions.<br/>
Computes a size that is the union of all childrens' frames.</p>

<h2>CKCenterLayoutComponent</h2>

<p>Lays out a single child component and position it so that it is centered into the layout bounds.</p>

<pre><code>+ (instancetype)newWithCenteringOptions:(CKCenterLayoutComponentCenteringOptions)centeringOptions
                          sizingOptions:(CKCenterLayoutComponentSizingOptions)sizingOptions
                                  child:(CKComponent *)child
                                   size:(const CKComponentSize &amp;)size;
</code></pre>

<h2>CKRatioLayoutComponent</h2>

<p>For when the content should respect a certain inherent ratio but can be scaled (think photos or videos).
The ratio passed is the ratio of height / width you expect.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS知识小集-170417]]></title>
    <link href="http://sxgfxm.github.io/blog/2017/05/17/ioszhi-shi-xiao-ji-170417/"/>
    <updated>2017-05-17T16:33:08+08:00</updated>
    <id>http://sxgfxm.github.io/blog/2017/05/17/ioszhi-shi-xiao-ji-170417</id>
    <content type="html"><![CDATA[<h1>ComponentKit Tutorial - Component</h1>

<h2>CKComponent</h2>

<p>A component is an immutable object that specifies how to configure a view, loosely inspired by React.</p>

<pre><code>+ (instancetype)newWithView:(const CKComponentViewConfiguration &amp;)view
                       size:(const CKComponentSize &amp;)size;
</code></pre>

<p>Example:</p>

<pre><code>CKComponent *component = [CKComponent
    newWithView:{
        [UIView class],
        {
            {@selector(setBackgroundColor:),[UIColor redColor]},
            {@selector(setUserInteractionEnabled:), @YES},
            {CKComponentTapGestureAttribute(@selector(didTap))},
            {CKComponentViewAttribute::LayerAttribute(@selector(setCornerRadius:)), @10.0}
        }
    }
    size:{50,50}];

- (void)didTap{
  [self updateState:^(NSNumber *oldState){
    return [oldState boolValue] ? @NO : @YES;
  } mode:CKUpdateModeSynchronous];
}
</code></pre>

<!-- more -->


<h2>CKLabelComponent</h2>

<p>多行文字通过size.width控制。</p>

<pre><code>CKLabelComponent *titleComponent = [CKLabelComponent newWithLabelAttributes:{
    .string = newsModel.title,
    .color = [UIColor whiteColor],
    .alignment = NSTextAlignmentLeft,
    .font = [UIFont systemFontOfSize:20]
  }
  viewAttributes:{
    { @selector(setBackgroundColor:), [UIColor clearColor] }
  }
  size:{}];
</code></pre>

<h2>CKButtonComponent</h2>

<pre><code> CKButtonComponent *buttonComponent = [CKButtonComponent
    newWithTitles:{
      {UIControlStateNormal,@"button"}
    }
    titleColors:{
      {UIControlStateNormal,[UIColor whiteColor]}
    }
    images:{}
    backgroundImages:{}
    titleFont:[UIFont systemFontOfSize:17]
    selected:NO
    enabled:YES
    action:{@selector(tapAction)}
    size:{}
    attributes:{}
    accessibilityConfiguration:{}];
</code></pre>

<h2>CKImageComponent</h2>

<pre><code>CKImageComponent *image = [CKImageComponent newWithImage:
    [UIImage imageNamed:newsModel.imageURL]
    attributes:{
        { @selector(setBackgroundColor:), [UIColor whiteColor] },
        {CKComponentViewAttribute::LayerAttribute(@selector(setCornerRadius:)), @10.0}
    }
    size:{60, 60}];
</code></pre>

<h2>CKInsetComponent</h2>

<p>A component that wraps another component, applying insets around it.</p>

<pre><code>+ (instancetype)newWithView:(const CKComponentViewConfiguration &amp;)view
                     insets:(UIEdgeInsets)insets
                  component:(CKComponent *)component;

+ (instancetype)newWithInsets:(UIEdgeInsets)insets component:(CKComponent *)child;
</code></pre>

<p>Example:</p>

<pre><code>CKInsetComponent *insetComponent = [CKInsetComponent
    newWithInsets:{.top = 10,.left = 20,.right = 10,.bottom = 20}
    component:[CKComponent
        newWithView:{}
        size:{}]
    ];
</code></pre>

<h2>CKOverlayLayoutComponent</h2>

<p>This component lays out a single component and then overlays a component on top of it streched to its size.</p>

<pre><code>+ (instancetype)newWithComponent:(CKComponent *)component
                         overlay:(CKComponent *)overlay;
</code></pre>

<h2>State</h2>

<p>Simply ask three questions about each piece of data:<br/>
1. Is it passed in from a parent via props? If so, it probably isn&rsquo;t state.<br/>
2. Does it remain unchanged over time? If so, it probably isn&rsquo;t state.<br/>
3. Can you compute it based on any other state or props in your component? If so, it isn&rsquo;t state.</p>

<p>For each piece of state in your application:<br/>
1. Identify every component that renders something based on that state.<br/>
2. Find a common owner component (a single component above all the components that need the state in the hierarchy).<br/>
3. Either the common owner or another component higher up in the hierarchy should own the state.<br/>
4. If you can&rsquo;t find a component where it makes sense to own the state, create a new component simply for holding the state and add it somewhere in the hierarchy above the common owner component.</p>

<h2>Scope</h2>

<ol>
<li>Components that have state must have a scope.</li>
<li>Components that have a controller must have a scope.</li>
<li>Components that have child components with state or controllers may need a scope, even if they don’t have state or controllers.</li>
</ol>


<h2>ComponentController</h2>

<p>与component写在同一个文件里，系统自动创建。<br/>
用来处理代理、事件响应等，有持续的生命周期。<br/>
scope必须唯一，与controller一一对应。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS知识小集-170410]]></title>
    <link href="http://sxgfxm.github.io/blog/2017/05/17/ioszhi-shi-xiao-ji-170410/"/>
    <updated>2017-05-17T16:25:45+08:00</updated>
    <id>http://sxgfxm.github.io/blog/2017/05/17/ioszhi-shi-xiao-ji-170410</id>
    <content type="html"><![CDATA[<h1>ComponentKit Tutorial - Introduction</h1>

<h2>Philosophy</h2>

<p>Components are immutable objects that specify how to configure views.<br/>
<strong>Declarative</strong> : You declare the subcomponents of your component.<br/>
<strong>Functional</strong> : Data flows in one direction.<br/>
<strong>Composable</strong> : Reusing it is a one-liner.</p>

<!-- more -->


<h2>Flex box</h2>

<p><strong>main axis</strong>: The main axis of a flex container is the primary axis along which flex items are laid out. It extends in the main dimension.<br/>
<strong>main-start,main-end</strong>: The flex items are placed within the container starting on the main-start side and going toward the main-end side.<br/>
<strong>main size</strong>: The flex item’s main size property is either the width or height property, whichever is in the main dimension.<br/>
<strong>cross axis</strong>: The axis perpendicular to the main axis is called the cross axis. It extends in the cross dimension.<br/>
<strong>cross-start,cross-end</strong>: Flex lines are filled with items and placed into the container starting on the cross-start side of the flex container and going toward the cross-end side.<br/>
<strong>cross size</strong>: The cross size property is whichever of width or height that is in the cross dimension.</p>

<h2>Uses</h2>

<p><strong>Strengths</strong>:<br/>
Simple and Declarative: Just like React itself. Why React? sums up these benefits.<br/>
Scroll Performance: All layout is performed on a background thread, ensuring the main thread isn’t tied up measuring text.<br/>
View Recycling: By requiring all view configurations to be expressed declaratively, ComponentKit makes error-free view recycling automatic.<br/>
Composability: By encouraging heavy use of composition, it’s possible to build UIs as complex as News Feed without any single component exceeding 300 lines of code.<br/>
<strong>Considerations</strong>:<br/>
Interfaces that aren’t lists or tables aren’t ideally suited to ComponentKit since it is optimized to work well with a UICollectionView.<br/>
ComponentKit is fully native and compiled. React Native offers an alternative based on JavaScriptCore and React, including features like instant reload with no recompilation.<br/>
Dynamic gesture-driven UIs are currently hard to implement in ComponentKit; consider using AsyncDisplayKit.<br/>
ComponentKit is built on Objective-C++. There is no easy way to interoperate with Swift since Swift cannot bridge to C++.</p>

<h2>Component API</h2>

<pre><code>@interface CKComponent : NSObject

/** Returns a new component. */
+ (instancetype)newWithView:(const CKComponentViewConfiguration &amp;)view
                       size:(const CKComponentSize &amp;)size;

@end
</code></pre>

<p>Notes:<br/>
A component is totally immutable. For example, there is no <code>addSubcomponent:</code> method.<br/>
A component can be created on any thread. This helps keep all sizing and construction operations off the main thread.<br/>
The Objective-C idiom <code>+newWith...</code> is used for instantiation instead of the more typical <code>+alloc/-initWith...</code> This is mainly for brevity. Getting rid of noise is important to keep components code readable.</p>

<h2>Composite Components</h2>

<p>Avoid subclassing <code>CKComponent directly</code>. Instead, subclass <code>CKCompositeComponent</code>.<br/>
A “composite component” simply wraps another component, hiding its implementation details from the outside world.</p>

<pre><code>@implementation ShareButtonComponent

+ (instancetype)newWithArticle:(ArticleModel *)article
{
  return [super newWithComponent:
          [CKButtonComponent
           newWithTitles:...
           titleColors:...]];
}

- (void)shareTapped
{
  // Share the article
}

@end
</code></pre>

<h2>Views</h2>

<pre><code>struct CKComponentViewConfiguration {
  CKComponentViewClass viewClass;
  std::unordered_map&lt;CKComponentViewAttribute, id&gt; attributes;
};
</code></pre>

<p>The first field is a view class. Ignore <code>CKComponentViewClass</code> for now — in most cases you just pass a class like <code>[UIImageView class]</code> or <code>[UIButton class]</code>.<br/>
The second field holds a map of attributes to values: font, color, background image, and so forth. Again, ignore <code>CKComponentViewAttribute</code> for now; you can usually use a <code>SEL</code> as the attribute.</p>

<pre><code>[CKComponent
 newWithView:{
   [UIImageView class],
   {
     {@selector(setImage:), image},
     {@selector(setContentMode:), @(UIViewContentModeCenter)} // Wrapping into an NSNumber
   }
 }
 size:{image.size.width, image.size.height}];
</code></pre>

<p>In such situations, just pass {} for the view configuration and no view is created.</p>

<h2>Layout</h2>

<p><code>CKComponent</code> instances do not have any size or position information. Instead, ComponentKit calls the <code>layoutThatFits:</code> method with a given size constraint and the component must return a structure describing both its size, and the position and sizes of its children.</p>

<pre><code>struct CKComponentLayout {
  CKComponent *component;
  CGSize size;
  std::vector&lt;CKComponentLayoutChild&gt; children;
};

struct CKComponentLayoutChild {
  CGPoint position;
  CKComponentLayout layout;
};
</code></pre>

<p><strong>Layout Components</strong>:<br/>
<code>CKStackLayoutComponent</code>: It allows you to stack components vertically or horizontally and specify how they should be flexed and aligned to fit in the available space.<br/>
<code>CKInsetComponent</code>: Applies an inset margin around a component.<br/>
<code>CKBackgroundLayoutComponent</code>: Lays out a component, stretching another component behind it as a backdrop.<br/>
<code>CKOverlayLayoutComponent</code>: Lays out a component, stretching another component on top of it as an overlay.<br/>
<code>CKCenterLayoutComponent</code>: Centers a component in the available space.<br/>
<code>CKRatioLayoutComponent</code>: Lays out a component at a fixed aspect ratio.<br/>
<code>CKStaticLayoutComponent</code>: Allows positioning children at fixed offsets.<br/>
If the components above aren’t powerful enough, you can implement <code>computeLayoutThatFits:</code> manually.</p>

<h2>Responder Chain</h2>

<p>The ComponentKit responder chain is separate from UIView’s responder chain, so you must manually bridge over to the component responder chain if desired.<br/>
The easiest way to handle taps on UIControl views is to use <code>CKComponentActionAttribute</code>.</p>

<pre><code>@implementation SomeComponent

+ (instancetype)new
{
  return [self newWithView:{
    [UIButton class],
    {CKComponentActionAttribute(@selector(didTapButton))}
  }];
}

- (void)didTapButton
{
  // Aha! The button has been tapped.
}

@end
</code></pre>

<h2>Component Actions</h2>

<h2>State</h2>

<p><code>State</code>: Internal to the component, this holds implementation details that the parent should not have to know about.</p>

<pre><code>#import "CKComponentSubclass.h" // import to expose updateState:
@implementation MessageComponent

+ (id)initialState
{
  return @NO;
}

+ (instancetype)newWithMessage:(NSAttributedString *)message
{
  CKComponentScope scope(self);
  NSNumber *state = scope.state();
  return [super newWithComponent:
          [CKTextComponent
           newWithAttributes:{
             .attributedString = message,
             .maximumNumberOfLines = [state boolValue] ? 0 : 5,
           }
           viewAttributes:{}
           accessibilityContext:{}]];
}

- (void)didTapContinueReading
{
  [self updateState:^(id oldState){ return @YES; } mode:CKUpdateModeAsynchronous];
}

@end
</code></pre>

<h2>Scopes</h2>

<p><code>Scopes</code> give components a persistent, unique identity. They’re needed in three cases:<br/>
Components that have <code>state</code> must have a scope.<br/>
Components that have a <code>controller</code> must have a scope.<br/>
Components that have child components with state or controllers may need a scope, even if they don’t have state or controllers.<br/>
Use the <code>CKComponentScope</code> type to define a component scope at the top of a component’s <code>+new</code> method.</p>

<pre><code>+ (instancetype)newWithModel:(Model *)model
{
  CKComponentScope scope(self, model.uniqueID);
  ...
  return [super newWithComponent:...];
}
</code></pre>

<p>If your component doesn’t have a model object with a unique identifier, you can omit that parameter as long as there won’t be multiple siblings of the same type.</p>

<pre><code>CKComponentScope scope(self);
</code></pre>

<h2>Component Controllers</h2>

<p>Every time something changes, an entirely new component is created and the old one is thrown away.<br/>
This means components are short-lived, and their lifecycle is not under your control.<br/>
But sometimes, you do need <strong>an object with a longer lifecycle</strong>. Component controllers fill that role:<br/>
Components can’t be delegates because they are short-lived, but component controllers can be delegates.<br/>
Network downloads take time to complete; the component may have been recreated by the time the download completes. The controller can handle the callback.<br/>
You may need an object to own some other object that should have a long lifetime.<br/>
Controllers are instantiated automatically by ComponentKit. Don’t try to create them manually.<br/>
There is a only a one-way communication channel between the component and its component controller - you can only pass data off of a component to a component controller.<br/>
A component has no reference its corresponding component controller. This is by design.<br/>
To pass data from a component to its controller, expose a <code>@property</code> on the component in a class extension.<br/>
The controller can initialize itself with the properties in <code>initWithComponent:</code>.</p>

<h2>Lifecycle Methods</h2>

<p>Whenever possible, avoid using lifecycle methods. Think of them as an emergency escape hatch for integrating with stateful code.<br/>
Mounting -> Remounting -> Unmounting -> Updating</p>

<h2>Animation</h2>

<p>animationsOnInitialMount: Override this method to specify how to animate the initial appearance of a component.<br/>
animationsFromPreviousComponent: Override this method to specify how to animate between two versions of a component.<br/>
boundsAnimationFromPreviousComponent: Override this method to specify how the top-level bounds of a component should animate inside a <code>UICollectionView</code>.<br/>
If you implement either method, your component must have a <code>scope</code>.</p>
]]></content>
  </entry>
  
</feed>

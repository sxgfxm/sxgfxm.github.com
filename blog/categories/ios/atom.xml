<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Ios | Light's Blog]]></title>
  <link href="http://sxgfxm.github.io/blog/categories/ios/atom.xml" rel="self"/>
  <link href="http://sxgfxm.github.io/"/>
  <updated>2020-01-17T10:57:20+08:00</updated>
  <id>http://sxgfxm.github.io/</id>
  <author>
    <name><![CDATA[Light]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[iOS知识小集-201901]]></title>
    <link href="http://sxgfxm.github.io/blog/2020/01/17/ioszhi-shi-xiao-ji-201901/"/>
    <updated>2020-01-17T10:44:28+08:00</updated>
    <id>http://sxgfxm.github.io/blog/2020/01/17/ioszhi-shi-xiao-ji-201901</id>
    <content type="html"><![CDATA[<h2>2019.01.02</h2>

<h3>Swift 进阶</h3>

<p>Swift 语言特性<br/>
- Swift 既是高级语言，又是低级语言。既可以使用 <strong>map</strong> 、 <strong>reduce</strong> 这样的方法，编写 <strong>高阶函数</strong>，又可以直接编译出原生的二进制可执行文件，具有和 C语言 媲美的性能。  （如何理解第二点？）<br/>
- Swift 是多范式语言。既可以 <strong>面向对象编程</strong> ，又可以 <strong>函数式编程</strong> 。<br/>
- Swift 鼓励自下而上编程。可以自己构建组件。<br/>
- Swift 代码紧凑、精确，同时保持清晰。<br/>
- Swift 在实践中是相对安全的。（如何检查变量在被使用前是赋值的？）<br/>
- Swift 在不断的发展中。</p>

<p>专业术语<br/>
- 值语义：<br/>
- 值类型：具有值语义的类型为值类型，<strong>struct</strong>、 <strong>enum</strong> 都是值类型。<br/>
- 引用类型：<br/>
- 浅拷贝：<br/>
- 深拷贝：<br/>
- 闭包：持有外部变量的函数成为 <strong>闭包（closure）</strong> 。<br/>
- 高阶函数：<br/>
- 静态派发：<br/>
- 动态派发：</p>

<h3>Atom 快捷键</h3>

<p>打开快捷键列表：cmd + shift + P；<br/>
模糊搜索标题：cmd + P；</p>

<h3>adb 取 Android 系统日志</h3>

<ol>
<li><code>brew cask install android-platform-tools</code>；</li>
<li><code>adb bugreport</code>；</li>
</ol>


<h3>字节跳动组织核心</h3>

<p>技术、用户增长、商业化。<br/>
留存、拉新、变现。</p>

<h2>2019.01.03</h2>

<h3>Swift 进阶</h3>

<p>使用函数将行为参数化，复用模板代码，调用者提供变换函数。<br/>
将重复的代码抽象为函数，将函数行为抽象为模板，作为扩展重复使用。<br/>
<T>表示声明 T 为某种类型的占位符。</p>

<p>内建集合类型<br/>
- 标准库中的集合类型都具有值语义，且都是用了“写时复制”技术；</p>

<p>数组变形<br/>
- 尽量避免直接使用索引值访问数组元素；<br/>
- sort：<br/>
- map：对数组中每个元素进行变换，返回新数组；</p>

<pre><code class="swift">extension Array {
  func map&lt;T&gt;(_ transform: (Element) -&gt; T) -&gt; [T] {
    var result: [T] = []
    result.reserveCapacity(count)
    for x in self {
      result.append(transform(x))
    }
    return result
  }
}

[1, 2, 3].map{ x in
  return x + 1
}

[1, 2, 3].map{$0 + 1}
</code></pre>

<ul>
<li>filter：筛选出符合条件的元素，返回新数组；</li>
</ul>


<pre><code class="swift">extension Array {
  func filter(_ predicate:(Element) -&gt; Bool) -&gt; [Element] {
    var result: [Element] = []
    for x in self where predicate(x) {
      result.append(x)
    }
    return result
  }
}

[1, 2, 3].filter{ x in
  return x &gt; 0
}

[1, 2, 3].filter{$0 &gt; 1}
</code></pre>

<ul>
<li>reduce：合并数组元素，返回合并值；</li>
</ul>


<pre><code class="swift">extension Array {
  func reduce&lt;T&gt;(_ initialValue: T, _ transform: (T, Element)-&gt; T) - &gt; T {
    var value = initialValue
    for x in Self {
      value = transform(value, x)
    }
    return value
  }
}

[1, 2, 3].reduce(0){value, x in value + x}
[1, 2, 3].reduce(0, +)
</code></pre>

<ul>
<li>acummulate：迭代操作元素，返回新数组；</li>
</ul>


<pre><code class="swift">extension Array {
  func accumulate&lt;Result&gt;(_ initialResult: Result, _ nextParitialResult:(Result, Element) -&gt; Result) -&gt; [Result]{
    var running = initialResult
    return map{ next in
      running = nextParitialResult(running, next)
      return running
    }
  }
}

[1, 2, 3].accumulate(0, +)
</code></pre>

<ul>
<li>all：判断是否所有元素都符合条件；</li>
</ul>


<pre><code class="swift">extension Array {
  func all(_ predicate: (Element) -&gt; Bool) -&gt; Bool {
    return !contains{!predicate($0)}
  }
}

[1, 2, 3].all{$0 &gt; 0}
</code></pre>

<ul>
<li>map2：用reduce实现map；</li>
</ul>


<pre><code class="swift">extension Array {
  func map2&lt;T&gt;(_ transform:(Element) -&gt; T) -&gt; [T] {
    return reduce([]){
      $0 + [transform($1)]
    }
  }
}
</code></pre>

<ul>
<li>flatMap：先map再joined，当变换函数返回值为数组，且需要合并时使用；</li>
</ul>


<pre><code class="swift">extension Array {
  func flatMap&lt;T&gt;(_ transform:(Element) -&gt; [T]) -&gt; [T] {
    var result: [T] = []
    for x in self {
      result.append(contentsOf: transform(x))
    }
    return result
  }
}
</code></pre>

<ul>
<li>forEach：无返回值迭代数组元素；</li>
</ul>


<h2>2019.01.03</h2>

<h3>Swift 进阶</h3>

<p>数组类型<br/>
- 切片：切片只是数组的另一种表示方法，使用ptr、startIndex、endIndex表示，并不会创建新数组；
（如果改变切片中元素，原数组中元素会改变吗？）<br/>
- 桥接：Swift数组可以桥接到OC中，编译器会自动把不兼容的值用一个不透明的box包起来；</p>

<h3>Swfit 基础</h3>

<ul>
<li>Type Parameters</li>
<li>Type Parameters Constraints</li>
<li>Generic Type</li>
<li>Generic Founction</li>
<li>Associated Type</li>
<li>Associated Type Constraints</li>
<li>Generic where Clause</li>
</ul>


<h2>2019.01.07</h2>

<h3>Swift 进阶</h3>

<p>字典
- removeValue(forKey:)<br/>
- updateValue(_:forKey:)<br/>
- mapValue<br/>
- frequency<br/>
- merge(_:uniqueKeysWith:)</p>

<p>集合
- IndexSet：整数集合，支持范围操作；<br/>
- CharacterSet：Unicode字符集合；</p>

<h2>2019.01.08</h2>

<h3>Swift 进阶</h3>

<p>范围
- Range<br/>
- CloseRange<br/>
- Comparable 协议；<br/>
- Strideable 协议；</p>

<h2>2019.01.09</h2>

<h3>Swift 进阶</h3>

<ul>
<li><strong>Sequence</strong> 协议是集合类型结构的基础，一个序列代表一系列具有相同类型的值，你可以对这些值进行迭代；</li>
</ul>


<pre><code class="swift">protocol Sequence {
  associated Iterator : IteratorProtocol
  func makeIterator() -&gt; Iterator
}
</code></pre>

<ul>
<li><strong>IteratorProtocol</strong> 协议是对迭代器的描述，通过<code>next()</code>方法返回序列中下一个值；</li>
</ul>


<pre><code class="swift">protocol InteratorProtocol {
  associated Element
  mutating func next() -&gt; Element?
}
</code></pre>

<h2>2019.01.10</h2>

<h3>APP发布</h3>

<ul>
<li>封板之后不要再往发版分支合代码；</li>
<li>修改一定要验证，尤其是跨分支 <strong>cherry-pick</strong> 代码；</li>
<li>APP发布之前一定要看一下 <strong>TestFlight</strong> 版本是否正常；</li>
</ul>


<h3>Principles</h3>

<ul>
<li>What do you want ？</li>
<li>What is true?</li>
<li>What are you going to do about it ?</li>
</ul>


<h3>微信公开课</h3>

<ul>
<li>我们更多倡导的是利用微信做出好产品分享用户。</li>
<li>因为遵循原则，很多东西我们又必须坚持去改变。</li>
<li>第一我们没有批量导入某一批好友，而是通过用户手动一个一个挑选。第二，在一个产品还没有被验证只能够产生自然增长的时候，我们没有去推广它。</li>
<li>因为好的产品需要一定的独裁，否则它将包含很多不同意见以至于产品性格走向四分五裂。</li>
<li>第一，坚持做一个好的，与时俱进的工具。</li>
<li>微信是一个生活方式。</li>
<li>第二个原动力是，“让创造者体现价值”。</li>
<li>一个好的产品是有自己的使命的。</li>
<li>最主要的是，技术的使命应该是帮助人类提高效率。</li>
<li>一切盈利都是做好产品做好服务后的自然而来的副产品。</li>
<li>小游戏的原动力是，它应该是一个关于创意的平台。并且让产生创意的人体现价值。</li>
</ul>


<h3>Swift 开发</h3>

<ul>
<li>使用 <strong>Kingfiser</strong> 异步加载网络图片 <code>imageView.kf.setImage(with:URL(string:"http://xxx.png"))</code>；</li>
<li>使用 <strong>Material</strong> 自动布局 <code>view.layout().top().left().width().height()</code>；</li>
<li>使用 <strong>SnapKit</strong> 自动布局 <code>view.snp.makeConstrains{(make) in // layout}</code>；</li>
<li>使用 <strong>Extension</strong> 按功能模块分隔代码，相对清晰；</li>
<li>使用 <strong>Moya</strong> 封装网络模块请求；</li>
<li>使用 <strong>IGListKit</strong> 实现CollectionView，TableView；</li>
<li>使用 <strong>SwiftyUserDefaults</strong> 实现 UserDefault 存取；</li>
<li>使用 <strong>Realm</strong> 实现 数据库 存取；</li>
<li>使用 <strong>Codable</strong> 实现 JSON 解析；</li>
</ul>


<h2>2019.01.11</h2>

<h3>RxSwift</h3>

<ul>
<li>Every <strong>Observable</strong> sequence is just a sequence. The key advantage for an Observable vs Swift&rsquo;s Sequence is that it can also receive elements asynchronously.</li>
<li><strong>Observable</strong>(<strong>ObservableType</strong>) is equivalent to <strong>Sequence</strong>.</li>
<li><strong>ObservableType.subscribe</strong> method is equivalent to <strong>Sequence.makeIterator</strong> method.</li>
<li>Observer (callback) needs to be passed to <strong>ObservableType.subscribe</strong> method to receive sequence elements instead of calling <strong>next()</strong> on the returned iterator.</li>
<li>When an observable is created, it doesn&rsquo;t perform any work simply because it has been created.</li>
<li>However, if you just call a method that returns an <strong>Observable</strong>, no sequence generation is performed and there are no side effects. <strong>Observable</strong> just defines how the sequence is generated and what parameters are used for element generation. <strong>Sequence</strong> generation starts when <strong>subscribe</strong> method is called.</li>
</ul>


<h2>2019.01.16</h2>

<h3>RxSwift 使用场景</h3>

<ul>
<li>使用 <strong>RxSwift</strong> 实现 <strong>Target Action</strong>；</li>
<li>使用 <strong>RxSwift</strong> 实现 <strong>Delegate</strong>；</li>
<li>使用 <strong>RxSwift</strong> 实现 <strong>闭包回调</strong>；</li>
<li>使用 <strong>RxSwift</strong> 实现 <strong>Notification</strong>；</li>
<li>使用 <strong>RxSwift</strong> 实现 <strong>KVO</strong>；</li>
<li>使用 <strong>RxSwift</strong> 实现 <strong>依赖任务</strong>；</li>
<li>使用 <strong>RxSwift</strong> 实现 <strong>多异步任务同步</strong>；</li>
</ul>


<h3>RxSwift 核心概念</h3>

<ul>
<li><strong>Obervable</strong>：Single，Completable，Maybe，Driver，ControlEvent</li>
<li><strong>Observer</strong>：AnyObserver，Binder</li>
<li><strong>Obervable &amp; Observer</strong>：AsyncSubject、PublishSubject、ReplaySubject、BehaviorSubject、Variable、ControlProperty</li>
<li><strong>Operator</strong>：创建新序列 或 变换、组合原有序列</li>
<li><strong>Disposable</strong>：DisposeBag、takeUntil</li>
<li><strong>Schedulers</strong>：subscribeOn、observeOn、MainScheduler、SerialDispatchQueueScheduler、ConcurrentDispatchQueueScheduler、OperationQueueScheduler</li>
<li><strong>Error Handling</strong>：retry、retryWhen、catchError</li>
</ul>


<h2>2019.01.17</h2>

<h3>RxSwift 常用操作符</h3>

<p>Observable：描述可观察序列值是如何产生的，或者说观察者是如何接收该序列的，当subscribe时，真正触发序列产生。</p>

<p>创建 Observable<br/>
- <strong>create</strong>：通过构建函数，完整创建一个自定义的 Observable。各种操作符都是通过create实现的。<br/>
- <strong>just</strong>：创建只发出一个元素的 Observable。当只产生一个元素时，可以使用just快速创建，比如网络请求结果？<br/>
- <strong>timer</strong>：创建一定延时后，只发出一个元素的 Observable。类似于 dispatch_after ？<br/>
- <strong>from</strong>：将其他类型转换为 Observable。比如数组、可选值等。不必自己实现这个转化过程了。<br/>
- <strong>repeatElement</strong>：创建重复发出某个元素的 Observable。<br/>
- <strong>deferred</strong>：直到订阅发生，才创建 Observable，并且为每位订阅者创建全新的 Observable。订阅者获取独立序列。<br/>
- <strong>interval</strong>：创建每隔一段时间就发出一个索引数的 Observable。相当于一个repeated timer。<br/>
- <strong>empty</strong>：创建只发出一个完成事件的 Observable。什么时候使用呢？<br/>
- <strong>never</strong>：创建一个不会发出任何元素的 Observable。什么时候使用呢？<br/>
- <strong>startWith</strong>：创建一个在头部插入一些元素的 Observable。<br/>
- <strong>error</strong>：创建一个只有 error 的 Observable。</p>

<p>创建 可组合的Observable<br/>
- <strong>merger</strong>：创建一个合并多个 Observable 的 Observable，当某个 Observable 发出元素时，他就发出元素。类似多条生产线合并到一个出口。可交替发出元素。<br/>
- <strong>concat</strong>：创建一个合并多个 Observable 的 Observable，当前一个 Observable 发出完毕时，下一个 Observable 才开始发出元素。按顺序发出元素。<br/>
- <strong>zip</strong>：通过组合函数，创建一个将多个 Observable 的元素组合之后发出的 Observable。严格按照索引数组合发出。<br/>
- <strong>combineLatest</strong>：通过组合函数，创建一个将多个 Observable 的最新元素组合之后发出的 Observable。用最新值替换对应值后组合发出。</p>

<p>转换 Observable 元素<br/>
- <strong>map</strong>：通过转换函数，将 Observable 的每个元素转换后发出。<br/>
- <strong>scan/accumulator</strong>：通过转换函数，将 Observable 的每个元素累积之前的结果转换后发出。<br/>
- <strong>reduce</strong>：通过转换函数，将 Observable 的所有元素累积的结果发出。</p>

<p>转换 Observable 元素 为 Observable<br/>
- <strong>flatMap</strong>：通过转换函数，将 Observable 的每个元素转换成其他的 Observable ，然后将这些 Observables 合并发出；<br/>
- <strong>flatMapLatest</strong>：通过转换函数，将 Observable 的每个元素转换成其他的 Observable，然后取最新的发出；<br/>
- <strong>concatMap</strong>：通过转换函数，将 Observable 的每个元素转换成其他的 Observable 后，按顺序发出；<br/>
- <strong>publish</strong>：将 Observable 转换为可被连接的 Observable。直到 connect 才开始发出元素。<br/>
- <strong>replay</strong>：将 Observable 转换为可被连接的 Observable。直到 connect 时开始发出缓存的最新n个元素。<br/>
- <strong>refCount</strong>：将 Observable 转换为可自动连接和断开的的 Observable。<br/>
- <strong>connect</strong>：通知 ConnectableObservable 可以开始发出元素了。</p>

<p>如何发送 Observable 元素<br/>
- <strong>delay</strong>：将 Observable 的所有元素延迟一段设定好的时间发出；<br/>
- <strong>materialize</strong>：将 Observable 产生的时间全部转换成元素发出；<br/>
- <strong>dematerialize</strong>：将 materialize 转换后的元素还原；<br/>
- <strong>ignoreElements</strong>：将 Observable 产生的 next 事件忽略，只发出 completed 和 error 事件；只关心终止时使用<br/>
- <strong>buffer</strong>：将 Observable 元素周期性的以 元素集合 发出来。<br/>
- <strong>window</strong>：将 元素集合 周期性的以 Observable 形态发出来。<br/>
- <strong>groupBy</strong>：将 Observable 以键值分组为 子Observable 发出来。<br/>
- <strong>single</strong>：将 Observable 限制为只发出一个元素。</p>

<ul>
<li><strong>filter</strong>：只发出通过判定的元素。</li>
<li><strong>take</strong>：只发出头 n 个元素。</li>
<li><strong>takeWhile</strong>：从头发出通过判定的元素。</li>
<li><strong>takeUntil</strong>：从头发出直到另一个 Observable 发出元素。</li>
<li><strong>takeLast</strong>：只发出尾 n 个元素。</li>
<li><strong>elementAt</strong>：只发出第 n 个元素。</li>
<li><strong>skip</strong>：跳过头 n 个元素。</li>
<li><strong>skipWhile</strong>：从头跳过通过判定的元素。</li>
<li><strong>skipUntil</strong>：从头跳过直到另一个 Observable 发出元素。</li>
<li><strong>sample</strong>：按第二个 Observable 对 第一个 Observable 采样发出元素。</li>
<li><strong>debounce</strong>：过滤掉高频产生的元素。</li>
<li><strong>distinctUntilChanged</strong>：只发出与上个元素不同的元素。</li>
<li><p><strong>delaySubscription</strong>：将延迟一段时间后才订阅 Observable。</p></li>
<li><p><strong>amb</strong>：在多个源 Observable 中，取第一个发出元素的 Observable 只发出其元素。</p></li>
</ul>


<p>在哪个线程发出和接收元素<br/>
- <strong>subscribeOn</strong>：指定 Observable 在哪个 Scheduler 执行。<br/>
- <strong>observeOn</strong>：指定 Observable 在哪个 Scheduler 发出通知。</p>

<p>当发生某些事件时如何操作<br/>
- <strong>do</strong>：当 Observable 产生某些事件时，执行某个操作。可以来注册一些回调操作，单独回调。<br/>
- <strong>timeout</strong>：如果 Observable 在规定时间内么有产生任何元素，产生一个超时的 error 事件。</p>

<p>如何处理 Observable error 事件<br/>
- <strong>catchError</strong>：拦截一个 error 事件，将它替换成其他 Observable。<br/>
- <strong>catchErrorJustReturn</strong>：拦截一个 error 事件，将它替换成其他元素并结束。<br/>
- <strong>retry</strong>：拦截一个 error 事件，并重新订阅该 Observable。</p>

<ul>
<li><strong>using</strong>：创建一个可被清除的资源，它和 Observable 具有相同的生命周期。</li>
</ul>


<h3>RxSwift 常用架构</h3>

<ul>
<li><strong>MVVM</strong>：View &ndash;> Observable &ndash;> ViewModel &ndash;> Observable &ndash;> Controller</li>
<li><strong>RxFeedback</strong>：State &ndash;> Event &ndash;> StateChanged &ndash;> Event &ndash;> State</li>
<li><strong>ReactorKit</strong>：View &ndash;> Action &ndash;> Reactor &ndash;> State</li>
</ul>


<h2>2019.01.18</h2>

<h3>IGListKit</h3>

<ul>
<li>[ListDiffable] &ndash;> ListAdapter &ndash;> ListSectionController &ndash;> Cell</li>
<li>Data： needs conform ListDiffable</li>
<li>ListAdapter：init with UICollectionView and ListAdapterUpdater，set datasource delegate，use <code>performUpdates(animated:)</code> to tell data has changed</li>
<li>UIViewController：needs conform ListAdapterDataSource，implement <code>objects(for:)</code>，<code>listAdapter(_:sectionControllerFor:)</code>，<code>emptyView(for:)</code></li>
<li>ListSectionController：needs save data, state, and override <code>numberOfItems</code>，<code>cellForItem(at:)</code>，<code>sizeForItem(at:)</code>，<code>didUpdate(to:)</code>，<code>didSelectItem(at:)</code></li>
<li>UICollectionViewCell：needs implement <code>cellSize(for:)</code></li>
<li>布局的关键在于如何划分Cell，采用分层组合的方式，类似于 ComponentKit ，提高复用性</li>
<li><code>UUID().uuidString</code> 来生成 唯一标识</li>
<li>一种 model 类型 对应一种 sectionController，sectionController 负责如何展示 model，可以用一个cell展示，也可以分多个cell展示</li>
<li>避免数据与UI不一致导致的crash</li>
<li>分离dataSource；</li>
</ul>


<h2>2019.01.24</h2>

<h3>SwiftyUserDefaults</h3>

<ul>
<li>add keys</li>
</ul>


<pre><code>extension DefaultsKeys {
  static let firstInFlag = DefaultsKey&lt;Bool&gt;("firstInFlag")
  static let username = DefaultsKey&lt;String?&gt;("username")
  static let password = DefaultsKey&lt;String?&gt;("password")
}
</code></pre>

<ul>
<li>use keys</li>
</ul>


<pre><code>func storeDataWithUserDefault (){
    if !Defaults[.firstInFlag] {
      print("Is first in")
      Defaults[.firstInFlag] = true
      Defaults[.username] = "Light"
      Defaults[.password] = "123456"
    } else {
      print("Not first in")
      print("username \(Defaults[.username] ?? "not set")")
      print("password \(Defaults[.password] ?? "not set")")
    }
  }
</code></pre>

<h3>RealmSwift</h3>

<ul>
<li>Declare Model</li>
</ul>


<pre><code>class Person: Object {
  @objc dynamic var name = ""
  @objc dynamic var age = 0
}
</code></pre>

<ul>
<li>Get Realm <code>let realm = try! Realm()</code></li>
<li>Query <code>let studentOver20 = realm.objects(Person.self).filter("age &gt; 20").first</code></li>
<li>Update <code>try! realm.write { realm.add(mySelf) realm.add(other) }</code></li>
</ul>


<h2>2019.01.25</h2>

<h3>Swift 5.0 新特性</h3>

<ul>
<li>应用瘦身：Swfit 应用不再包含标准库的动态链接库；</li>
<li>Swift 语言

<ul>
<li><code>@dynamicCallable</code> 简化方法调用，增强与动态语言的协作性；</li>
<li>Key paths 现在支持指向自身的 key path <code>\.self</code>；</li>
<li>enum case 不定参数 需转换为 数组传入；</li>
<li><code>try?</code> 表达式不再返回嵌套的optional；</li>
<li>字面量初始化</li>
<li>String 插值更高效，<code>_ExpressibleByStringInterpolation</code>方法需要替换；</li>
</ul>
</li>
<li>Swfit 标准库

<ul>
<li><code>DictionaryLiteral</code> 重命名为 <code>KeyValuePairs</code>；</li>
<li><code>Sequence</code> 不再有关联类型 <code>SubSequence</code>；</li>
</ul>
</li>
<li>Swift Package Manager</li>
<li>Swift Compiler</li>
</ul>


<h2>2019.01.28</h2>

<h3>RxSwift 原理解析</h3>

<h2>2019.01.30</h2>

<h3>RTCRoom</h3>

<ul>
<li>Login

<ul>
<li>初始化 <code>RTCRoom</code>；</li>
<li>获取 <code>LoginInfo</code>；</li>
<li>登录 <code>-login:loginInfo:withCompletion:</code>；</li>
</ul>
</li>
<li>Get Room List

<ul>
<li>获取聊天室列表 <code>-getRoomList:cnt:withCompletion:</code>；</li>
</ul>
</li>
<li>Create Room

<ul>
<li>创建聊天室 <code>-creatRoom:roomInfo:withCompletion:</code>；</li>
</ul>
</li>
<li>Enter Room

<ul>
<li>进入聊天室 <code>-enterRoom:withCompletion:</code>；</li>
</ul>
</li>
<li>Show Local Video

<ul>
<li>展示本地视频 <code>-startLocalPreview:</code>；</li>
<li>停止本地视频 <code>-stopLocalPreview</code>；</li>
<li>设置音频清晰度 <code>-setHDAudio:</code>；</li>
<li>设置视频码率 <code>-setBitrateRange:max:</code>；</li>
<li>切换前后摄像头 <code>-switchCamera</code>；</li>
<li>静音推流 <code>-setMute:</code>；</li>
<li>设置美颜效果 <code>-setBeautyStyle:beaultyLevel:whitenessLevel:ruddinessLevel:</code>；</li>
<li>进入前台 <code>-switchToForeground</code>；</li>
<li>进入后台 <code>-switchToBackground:</code>；</li>
</ul>
</li>
<li>Show Remote Video

<ul>
<li>展示远程视频 <code>-addRemoteView:withUserID:playBegin:playError:</code>；</li>
</ul>
</li>
<li>On Get Pusher List

<ul>
<li>记录 <code>PusherInfo</code>；</li>
<li>记录 <code>playerView</code>；</li>
<li>展示远程视频，出错时 <code>-onPusherQuit:</code>；</li>
<li>重新布局；</li>
</ul>
</li>
<li>On Pusher Join

<ul>
<li>记录 <code>playerView</code>；</li>
<li>记录 <code>PusherInfo</code>；</li>
<li>展示远程视频，出错时 <code>-onPusherQuit:</code>；</li>
<li>重新布局；</li>
</ul>
</li>
<li>On Pusher Quit

<ul>
<li>删除 <code>playerView</code>；</li>
<li>删除 <code>PusherInfo</code>；</li>
<li>重新布局；</li>
</ul>
</li>
<li>On Room Close

<ul>
<li>提示聊天室关闭；</li>
</ul>
</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS知识小集-180924]]></title>
    <link href="http://sxgfxm.github.io/blog/2018/10/10/ioszhi-shi-xiao-ji-180924/"/>
    <updated>2018-10-10T21:44:06+08:00</updated>
    <id>http://sxgfxm.github.io/blog/2018/10/10/ioszhi-shi-xiao-ji-180924</id>
    <content type="html"><![CDATA[<h2>修改UISearchBar取消按钮颜色</h2>

<pre><code class="objective-c">- (void)willPresentSearchController:(UISearchController *)searchController{
  [[UIBarButtonItem appearanceWhenContainedInInstancesOfClasses:@[[UISearchBar class]]] setTitleTextAttributes:@{NSForegroundColorAttributeName:UIColorFromRGBA(0xff4a4a4a)} forState:UIControlStateNormal];
}
</code></pre>

<h2>解决XCode10 引入非同一目录下头文件没有自动提示的问题</h2>

<p>Xcode &ndash;> File &ndash;> Workspace Settings &ndash;> Build System &ndash;> Legacy Build System。<br/>
需重新编译后生效。</p>

<h2>非 Retina 显示器，升级到 Mojave 之后发现文字不清晰问题</h2>

<p>如果你在用 “非 Retina” 的显示器，升级到 Mojave 之后发现文字不清晰了，是因为 Mojave 默认关闭了文字的次像素渲染，如果需要可以通过终端里输入这个命令重新打开：<br/>
<code>sudo defaults write -g CGFontRenderingFontSmoothingDisabled -bool NO</code>。<br/>
重新打开对应软件后生效。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS知识小集-180917]]></title>
    <link href="http://sxgfxm.github.io/blog/2018/09/25/ioszhi-shi-xiao-ji-180917/"/>
    <updated>2018-09-25T13:05:35+08:00</updated>
    <id>http://sxgfxm.github.io/blog/2018/09/25/ioszhi-shi-xiao-ji-180917</id>
    <content type="html"><![CDATA[<h2>相机拍摄图片方向调整</h2>

<pre><code class="objective-c">  if (image.imageOrientation != UIImageOrientationUp) {
      UIGraphicsBeginImageContext(image.size);
      [image drawInRect:CGRectMake(0, 0, image.size.width, image.size.height)];
      image = UIGraphicsGetImageFromCurrentImageContext();
      UIGraphicsEndImageContext();
  }
</code></pre>

<h2>Playground running 卡死</h2>

<p>1、修改platform为Mac OS；<br/>
2、修改为手动执行；<br/>
3、为手动执行增加快捷键；</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS知识小集-180910]]></title>
    <link href="http://sxgfxm.github.io/blog/2018/09/17/ioszhi-shi-xiao-ji-180910/"/>
    <updated>2018-09-17T20:42:43+08:00</updated>
    <id>http://sxgfxm.github.io/blog/2018/09/17/ioszhi-shi-xiao-ji-180910</id>
    <content type="html"><![CDATA[<h2>Siri Kit</h2>

<h3>Siri Kit作用</h3>

<p>通过语音完成第三方应用功能，偏向于工具型操作。</p>

<h3>实现机制</h3>

<p><strong>Domain</strong>：业务领域；<br/>
<strong>Intent</strong>：领域中的任务或指令；<br/>
语音识别 &ndash;> Domain / Intent &ndash;> 下发到已注册的Extension进行处理。<br/>
接近固定形式的表述更容易被识别。</p>

<h3>集成</h3>

<p>需要注意develop target系统版本问题。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS知识小集-180903]]></title>
    <link href="http://sxgfxm.github.io/blog/2018/09/10/ioszhi-shi-xiao-ji-180903/"/>
    <updated>2018-09-10T14:34:51+08:00</updated>
    <id>http://sxgfxm.github.io/blog/2018/09/10/ioszhi-shi-xiao-ji-180903</id>
    <content type="html"><![CDATA[<h2>集成Apple Pay</h2>

<h3>权限配置</h3>

<p>按官方指导配置权限。</p>

<h3>调用过程</h3>

<p>引入<code>&lt;PassKit/PassKit.h&gt;</code>，权限判断，支付卡判断，设置商品参数，创建支付请求，显示支付界面，代理接收结果。</p>

<!-- more -->


<pre><code class="objective-c">- (void)useApplePay{
  //  权限判断
  if ([PKPaymentAuthorizationViewController canMakePayments]){
    //  支付卡判断
    if ([PKPaymentAuthorizationViewController canMakePaymentsUsingNetworks:@[PKPaymentNetworkVisa, PKPaymentNetworkChinaUnionPay, PKPaymentNetworkDiscover]]){
      //  设置商品参数
      NSDecimalNumber *amount = [NSDecimalNumber decimalNumberWithString:@"2.33"]
      PKPaymentSummaryItem *item = [PKPaymentSummaryItem summaryItemWithLabel:@"PJChao" amount:amount];
      //  支付请求
      PKPaymentRequest *request = [[PKPaymentRequest alloc] init];
      // 设置商户ID（merchant IDs）
      request.merchantIdentifier = @"com.mobvoi.ApplePayTest";
      // 设置国家代码(中国大陆)
      request.countryCode = @"CN";
      // 设置支付货币(人民币)
      request.currencyCode = @"CNY";
      // 设置商户的支付标准(3DS支付方式必须支持，其他方式可选)
      request.merchantCapabilities = PKMerchantCapability3DS;
      request.paymentSummaryItems = @[item];
      /**
       *  以上参数都是必须的
       *  以下参数不是必须的
       */
      // 设置收据内容
      request.requiredBillingAddressFields = PKAddressFieldAll;
      // 设置送货内容
      request.requiredShippingAddressFields = PKAddressFieldAll;
      // 设置送货方式
      PKShippingMethod *method = [PKShippingMethod summaryItemWithLabel:@"顺丰" amount:[NSDecimalNumber decimalNumberWithString:@"10.00"]];
      method.identifier = @"顺丰物流";
      method.detail = @"12小时到达";
      request.shippingMethods = @[method];
      //  显示支付页面
      PKPaymentAuthorizationViewController *paymentVC = [[PKPaymentAuthorizationViewController alloc] initWithPaymentRequest:request];
      paymentVC.delegate = self;
      if (paymentVC == nil) return;
      [self presentViewController:paymentVC animated:YES completion:nil];
    } else {
      //  跳转至银行卡设置界面
      [[[PKPassLibrary alloc] init] openPaymentSetup];
    }
  }
}

//  代理方法
#pragma mark - PKPaymentAuthorizationViewControllerDelegate
- (void)paymentAuthorizationViewController:(PKPaymentAuthorizationViewController *)controller
                       didAuthorizePayment:(PKPayment *)payment
                                completion:(void (^)(PKPaymentAuthorizationStatus status))completion
{
    /**
     *  在这里支付信息应发送给服务器/第三方的SDK（银联SDK/易宝支付SDK/易智付SDK等）
     *  再根据服务器返回的支付成功与否进行不同处理
     *  这里直接返回支付成功
     */
    completion(PKPaymentAuthorizationStatusSuccess);
}

- (void)paymentAuthorizationViewControllerDidFinish:(PKPaymentAuthorizationViewController *)controller
{
    // 点击支付/取消按钮隐藏界面
    [controller dismissViewControllerAnimated:YES completion:nil];
}
</code></pre>

<h2>集成Touch ID</h2>

<pre><code class="objective-c">- (void)startLocalAuthentication{
  if (NSFoundationVersionNumber &lt; NSFoundationVersionNumber_iOS_8_0) {
    NSLog(@"系统版本不支持TouchID");
  } else {
    LAContext *context = [[LAContext alloc] init];
    context.localizedFallbackTitle = @"请输入密码";
    NSError *error = nil;
    if ([context canEvaluatePolicy:LAPolicyDeviceOwnerAuthenticationWithBiometrics error:&amp;error]) {
      [context evaluatePolicy:LAPolicyDeviceOwnerAuthenticationWithBiometrics localizedReason:@"通过指纹登录" reply:^(BOOL success, NSError * _Nullable error) {
        if (success) {
          dispatch_async(dispatch_get_main_queue(), ^{
            NSLog(@"验证成功");
          });
        } else {
          NSLog(@"验证失败");
        }
      }];
    } else {
      NSLog(@"当前设备不支持TouchID");
    }
  }
}
</code></pre>
]]></content>
  </entry>
  
</feed>

<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Ios | Light's Blog]]></title>
  <link href="http://sxgfxm.github.io/blog/categories/ios/atom.xml" rel="self"/>
  <link href="http://sxgfxm.github.io/"/>
  <updated>2016-10-24T18:14:11+08:00</updated>
  <id>http://sxgfxm.github.io/</id>
  <author>
    <name><![CDATA[Light]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[ShareSDK接入]]></title>
    <link href="http://sxgfxm.github.io/blog/2016/10/21/sharesdkjie-ru/"/>
    <updated>2016-10-21T14:12:36+08:00</updated>
    <id>http://sxgfxm.github.io/blog/2016/10/21/sharesdkjie-ru</id>
    <content type="html"><![CDATA[<h2>iOS接入ShareSDK实现第三方分享</h2>

<p>因为<strong>友盟</strong>被阿里收购在Android平台的各种令人不悦的后台操作，改用<strong>ShareSDK</strong>实现第三方分享。以下为简单接入流程。详情可参考官方文档<a href="http://wiki.mob.com/ios%E7%AE%80%E6%B4%81%E7%89%88%E5%BF%AB%E9%80%9F%E9%9B%86%E6%88%90/">http://wiki.mob.com/ios%E7%AE%80%E6%B4%81%E7%89%88%E5%BF%AB%E9%80%9F%E9%9B%86%E6%88%90/</a></p>

<!--more-->


<h2>获取AppKey</h2>

<p>在官网注册，并按要求创建应用，获取AppKey，比如为<strong>182947e7afac0</strong>。</p>

<h2>下载所需版本的ShareSDK</h2>

<p>解压后，将<strong>ShareSDK</strong>导入工程中，记得勾选<strong>Copy items into destination group&rsquo;s folder(if needed)</strong>。</p>

<h2>添加依赖库</h2>

<pre><code>//  ShareSDK
libicucore.dylib
libz.dylib
libstdc++.dylib
JavaScriptCore.framework

//  新浪微博SDK
ImageIO.framework
libsqlite3.dylib

//  QQ空间SDK
libsqlite3.dylib

//  微信SDK
libsqlite3.dylib

//  根据需要添加
</code></pre>

<h2>初始化对应的第三方平台</h2>

<p>在<strong>AppDelegate.m</strong>中，导入所需头文件。</p>

<pre><code class="objective-c">#import &lt;ShareSDK/ShareSDK.h&gt;
#import &lt;ShareSDKConnector/ShareSDKConnector.h&gt;

//腾讯开放平台（对应QQ和QQ空间）SDK头文件
#import &lt;TencentOpenAPI/TencentOAuth.h&gt;
#import &lt;TencentOpenAPI/QQApiInterface.h&gt;

//微信SDK头文件
#import "WXApi.h"

//新浪微博SDK头文件
#import "WeiboSDK.h"
//新浪微博SDK需要在项目Build Settings中的Other Linker Flags添加"-ObjC"
</code></pre>

<p>在<code>application:didFinishLaunchingWithOptions:</code>方法中初始化。</p>

<pre><code class="objective-c">- (BOOL)application:(UIApplication *)application
    didFinishLaunchingWithOptions:(NSDictionary *)launchOptions {

  /**
   *  设置ShareSDK的appKey，如果尚未在ShareSDK官网注册过App，请移步到http://mob.com/login
   * 登录后台进行应用注册
   *  在将生成的AppKey传入到此方法中。
   *  方法中的第二个第三个参数为需要连接社交平台SDK时触发，
   *  在此事件中写入连接代码。第四个参数则为配置本地社交平台时触发，根据返回的平台类型来配置平台信息。
   *  如果您使用的时服务端托管平台信息时，第二、四项参数可以传入nil，第三项参数则根据服务端托管平台来决定要连接的社交SDK。
   */
  [ShareSDK registerApp:@"182947e7afac0"

      activePlatforms:@[
        @(SSDKPlatformTypeSinaWeibo),
        @(SSDKPlatformTypeWechat),
        @(SSDKPlatformTypeQQ),
      ]
      onImport:^(SSDKPlatformType platformType) {
        switch (platformType) {
        case SSDKPlatformTypeWechat:
          [ShareSDKConnector connectWeChat:[WXApi class]];
          break;
        case SSDKPlatformTypeQQ:
          [ShareSDKConnector connectQQ:[QQApiInterface class]
                     tencentOAuthClass:[TencentOAuth class]];
          break;
        case SSDKPlatformTypeSinaWeibo:
          [ShareSDKConnector connectWeibo:[WeiboSDK class]];
          break;
        default:
          break;
        }
      }
      onConfiguration:^(SSDKPlatformType platformType,
                        NSMutableDictionary *appInfo) {

        switch (platformType) {
        case SSDKPlatformTypeSinaWeibo:
          //设置新浪微博应用信息,其中authType设置为使用SSO＋Web形式授权
          [appInfo
              SSDKSetupSinaWeiboByAppKey:@"3144028685"
                               appSecret:@"11abfe456bc8eefbab49fe7bbcd90bf0"
                             redirectUri:@"http://www.sharesdk.cn"
                                authType:SSDKAuthTypeBoth];
          break;
        case SSDKPlatformTypeWechat:
          [appInfo SSDKSetupWeChatByAppId:@"wx4868b35061f87885"
                                appSecret:@"64020361b8ec4c99936c0e3999a9f249"];
          break;
        case SSDKPlatformTypeQQ:
          [appInfo SSDKSetupQQByAppId:@"100371282"
                               appKey:@"aed9b0303e3ed1e27bae87c33761161d"
                             authType:SSDKAuthTypeBoth];
          break;
        default:
          break;
        }
      }];
  return YES;
}
</code></pre>

<p>接入不同的平台均需要注册并获取<strong>AppKey</strong>和<strong>AppSecret</strong>值。</p>

<h2>添加分享实现代码</h2>

<p>在<strong>ViewController.m</strong>中触发分享的方法中，添加分享代码。</p>

<pre><code class="objective-c">- (void)shareAction {
  [self.tf endEditing:YES];
  // 1、创建分享参数
  NSArray *imageArray = @[ [UIImage imageNamed:@"junxi5.jpg"] ];
  if (imageArray) {

    NSMutableDictionary *shareParams = [NSMutableDictionary dictionary];
    [shareParams SSDKSetupShareParamsByText:self.tf.text
                                     images:imageArray
                                        url:nil
                                      title:@"Ticwatch Sport"
                                       type:SSDKContentTypeAuto];
    // 2、分享（可以弹出我们的分享菜单和编辑界面）
    [ShareSDK showShareActionSheet:nil
                             items:nil
                       shareParams:shareParams
               onShareStateChanged:^(
                   SSDKResponseState state, SSDKPlatformType platformType,
                   NSDictionary *userData, SSDKContentEntity *contentEntity,
                   NSError *error, BOOL end) {

                 switch (state) {
                 case SSDKResponseStateSuccess: {
                   NSLog(@"分享成功");
                   break;
                 }
                 case SSDKResponseStateFail: {
                   NSLog(@"分享失败");
                   NSLog(@"%@", error);
                   break;
                 }
                 default:
                   break;
                 }
               }];
  }
}
</code></pre>

<h2>添加URL Schemes</h2>

<p> <img src="http://ofj92itlz.bkt.clouddn.com/ShareSDK:WhiteList.jpeg" alt="urlscheme" /></p>

<h2>适配iOS 9问题</h2>

<h3>退回http协议，并设置域</h3>

<p><img src="http://ofj92itlz.bkt.clouddn.com/ShareSDK:Https.jpeg" alt="http" /></p>

<h3>添加scheme白名单</h3>

<p><img src="http://ofj92itlz.bkt.clouddn.com/ShareSDK:UrlScheme.jpeg" alt="白名单" /></p>

<h2>分享平台title为英文问题</h2>

<p>默认语言为英文，需要在项目中添加中文本地化。</p>

<p><img src="http://ofj92itlz.bkt.clouddn.com/ShareSDK:Localization.jpeg" alt="localization" /></p>

<p>如需修改标题可以修改对应的本地化文件。</p>

<p> <img src="http://ofj92itlz.bkt.clouddn.com/ShareSDK:CustomLocalization.jpeg" alt="customLocalization" /></p>

<h2>Github源码</h2>

<p><a href="https://github.com/sxgfxm/ShareSDKDemo">ShareSDKDemo</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[3D Touch]]></title>
    <link href="http://sxgfxm.github.io/blog/2016/10/20/3d-touch/"/>
    <updated>2016-10-20T15:51:27+08:00</updated>
    <id>http://sxgfxm.github.io/blog/2016/10/20/3d-touch</id>
    <content type="html"><![CDATA[<h2>3D Touch简介</h2>

<p>3D Touch是智能手机领域最先进技术之一，目前只有Apple在iPhone上构建了相对良好的生态，并在最新推出的iOS 10中进一步优化了用户体验，Android系统和手机厂商还未提供较为成熟的支持。 本文主要介绍3D Touch相关技术的基本实现方法，包括：</p>

<p>1、Home Screen Quick Actions，主屏幕快捷访问；</p>

<p>2、Peek and Pop，预览和进入；</p>

<p>3、3D Touch Force，3D touch压力值运用。</p>

<!--more-->


<h2>Home Screen Quick Action</h2>

<h3>显示效果</h3>

<p>在主屏幕按下应用图标，会弹出设定好的快捷访问入口。本文采用纯代码创建，也可以通过设置Info.plist实现。</p>

<h3>代码实现</h3>

<p>首先，在<strong>AppDelegate.m</strong>的<code>application:didFinishLaunchingWithOptions:</code>方法中添加<strong>UIApplicationShortcutItems</strong>。</p>

<pre><code class="objective-c">- (BOOL)application:(UIApplication *)application
    didFinishLaunchingWithOptions:(NSDictionary *)launchOptions {
  // Override point for customization after application launch.
  //  主界面入口
  ViewController *vc = [[ViewController alloc] init];
  self.mainNav = [[UINavigationController alloc] initWithRootViewController:vc];
  self.window.rootViewController = self.mainNav;

  //  创建快捷访问Items
  UIApplicationShortcutIcon *icon1 = [UIApplicationShortcutIcon
      iconWithType:UIApplicationShortcutIconTypeTask];
  UIApplicationShortcutItem *item1 =
      [[UIApplicationShortcutItem alloc] initWithType:@"item1"
                                       localizedTitle:@"item1"
                                    localizedSubtitle:@"1"
                                                 icon:icon1
                                             userInfo:nil];
  UIApplicationShortcutIcon *icon2 = [UIApplicationShortcutIcon
      iconWithType:UIApplicationShortcutIconTypeMail];
  UIApplicationShortcutItem *item2 =
      [[UIApplicationShortcutItem alloc] initWithType:@"item2"
                                       localizedTitle:@"item2"
                                    localizedSubtitle:@"2"
                                                 icon:icon2
                                             userInfo:nil];
  //  添加快捷访问Items
  application.shortcutItems = @[ item1, item2 ];
  return YES;
}
</code></pre>

<p>然后，在<strong>AppDelegate.m</strong>中添加如下方法，用于响应快捷访问事件。</p>

<pre><code class="objective-c">- (void)application:(UIApplication *)application
    performActionForShortcutItem:(UIApplicationShortcutItem *)shortcutItem
               completionHandler:(void (^)(BOOL))completionHandler {
  //  响应Item对应的操作，跳转至对应controller
  if ([shortcutItem.type isEqualToString:@"item1"]) {
    Item1ViewController *vc = [[Item1ViewController alloc] init];
    [self.mainNav pushViewController:vc animated:YES];
  }
  if ([shortcutItem.type isEqualToString:@"item2"]) {
    Item2ViewController *vc = [[Item2ViewController alloc] init];
    [self.mainNav pushViewController:vc animated:YES];
  }
}
</code></pre>

<p>运行效果：</p>

<p> <img src="http://ofj92itlz.bkt.clouddn.com/3DTouch:step1.jpeg" alt="step1" /></p>

<h2>Peek and Pop</h2>

<p>3D Touch按压力度可以分为两级，一级力度触发<strong>peek</strong>，二级力度触发<strong>pop</strong>。</p>

<p><strong>peek</strong>相当于<strong>预览</strong>与按压view相关的<strong>view controller</strong>。<strong>pop</strong>相当于<strong>跳转</strong>至对应的<strong>view controller</strong>。</p>

<h3>为view添加3D Touch响应</h3>

<p>本文以UIImageView为例，实现图片的预览效果。</p>

<pre><code class="objective-c">  //  创建ImageView
  self.imageView = [[UIImageView alloc]
      initWithFrame:CGRectMake(self.view.bounds.size.width / 2 - 50, 300, 100,
                               100)];
  self.imageView.image = [UIImage imageNamed:@"junxi3.jpeg"];
  //  非常重要
  self.imageView.userInteractionEnabled = YES;
  [self.view addSubview:self.imageView];
  //  添加3D Touch 响应
  if (self.traitCollection.forceTouchCapability ==
      UIForceTouchCapabilityAvailable) {
    [self registerForPreviewingWithDelegate:self sourceView:self.imageView];
  } else {
    NSLog(@"您的设备不支持3D Touch");
  }
</code></pre>

<p>通过<strong>UIViewController</strong>的 <code>registerForPreviewingWithDelegate:sourceView:</code>方法添加3D Touch响应。需要遵守<strong>UIViewControllerPreviewingDelegate</strong>协议，并实现分别对应<strong>peek</strong>和<strong>pop</strong>的代理方法。</p>

<p>注意，添加3D Touch响应的view，一定要使<strong>userInteractionEnabled = YES</strong>，否则无法响应。</p>

<h3>peek相关代理方法实现</h3>

<p>实现代理方法<code>previewingContext:viewControllerForLocation:</code>，在该代理方法中创建并返回待预览的<strong>view controller</strong>。</p>

<pre><code class="objective-c">//  peek
- (UIViewController *)previewingContext:
                          (id&lt;UIViewControllerPreviewing&gt;)previewingContext
              viewControllerForLocation:(CGPoint)location {
  //  log信息
  NSLog(@"peek");
  NSLog(@"point %@", NSStringFromCGPoint(location));
  NSLog(@"rect %@", NSStringFromCGRect(previewingContext.sourceRect));
  //  创建待预览view controller
  PreviewViewController *previewVC = [[PreviewViewController alloc] init];
  //  设置大小
  previewVC.preferredContentSize = CGSizeMake(0.0f, 0.0f);
  //  设置内容
  previewVC.image = self.imageView.image;
  //  设置高亮显示区域，其他区域会模糊显示
  previewingContext.sourceRect = self.imageView.frame;
  //  返回待预览view controller
  return previewVC;
}
</code></pre>

<p>其中，previewingContext.sourceRect用于设置高亮区域，location为点击手势在view中的位置，preferredContentSize用于设置预览区域大小，为0时系统会设为最佳显示大小。</p>

<p>运行效果：</p>

<p><img src="http://ofj92itlz.bkt.clouddn.com/3DTouch:step2.jpeg" alt="step2" />      <img src="http://ofj92itlz.bkt.clouddn.com/3DTouch:step3.jpeg" alt="step3" /></p>

<h3>在PreviewViewController中添加预览状态快捷选项</h3>

<p>在<strong>peek</strong>状态下，向上滑动，即可弹出快捷选项。</p>

<pre><code class="objective-c">- (NSArray&lt;id&lt;UIPreviewActionItem&gt;&gt; *)previewActionItems {
  // setup a list of preview actions
  UIPreviewAction *action1 = [UIPreviewAction
      actionWithTitle:@"Aciton1"
                style:UIPreviewActionStyleDefault
              handler:^(UIPreviewAction *_Nonnull action,
                        UIViewController *_Nonnull previewViewController) {
                NSLog(@"Aciton1");
              }];

  UIPreviewAction *action2 = [UIPreviewAction
      actionWithTitle:@"Aciton2"
                style:UIPreviewActionStyleDefault
              handler:^(UIPreviewAction *_Nonnull action,
                        UIViewController *_Nonnull previewViewController) {
                NSLog(@"Aciton2");
              }];

  UIPreviewAction *action3 = [UIPreviewAction
      actionWithTitle:@"Aciton3"
                style:UIPreviewActionStyleDefault
              handler:^(UIPreviewAction *_Nonnull action,
                        UIViewController *_Nonnull previewViewController) {
                NSLog(@"Aciton3");
              }];

  NSArray *actions = @[ action1, action2, action3 ];
  return actions;
}
</code></pre>

<p>运行效果：</p>

<p> <img src="http://ofj92itlz.bkt.clouddn.com/3DTouch:step5.jpeg" alt="step4" /></p>

<h3>pop相关代理方法</h3>

<p>实现代理方法<code>previewingContext:commitViewController:</code>，在该代理方法中跳转。</p>

<pre><code class="objective-c">//  pop
- (void)previewingContext:(id&lt;UIViewControllerPreviewing&gt;)previewingContext
     commitViewController:(UIViewController *)viewControllerToCommit {
  //  log信息
  NSLog(@"pop");
  //  跳转至对应view controller
  [self showViewController:viewControllerToCommit sender:self];
}
</code></pre>

<p>运行效果：</p>

<p> <img src="http://ofj92itlz.bkt.clouddn.com/3DTouch:step4.jpeg" alt="step5" /></p>

<h2>3D Touch Force简单运用</h2>

<p>在<code>touchesMoved:withEvent:</code>方法中，获取touch对象，可以根据force属性值做相应操作。</p>

<pre><code class="objective-c">- (void)touchesMoved:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event {
  NSArray *arrayTouch = [touches allObjects];
  UITouch *touch = (UITouch *)[arrayTouch lastObject];
  NSLog(@"force = %f", touch.force);
}
</code></pre>

<h2>参考资料</h2>

<p><a href="https://developer.apple.com/library/content/documentation/UserExperience/Conceptual/Adopting3DTouchOniPhone/#//apple_ref/doc/uid/TP40016543-CH1-SW1">Adopting 3D Touch on iPhone</a></p>

<p><a href="http://www.tuicool.com/articles/auIJbiN">iOS9新特性 3DTouch 开发教程全解</a></p>

<h3>Github源码</h3>

<p><a href="https://github.com/sxgfxm/3DTouchDemo">3DTouchDemo</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Today Extension - Widget]]></title>
    <link href="http://sxgfxm.github.io/blog/2016/10/19/today-extension-widget/"/>
    <updated>2016-10-19T21:05:18+08:00</updated>
    <id>http://sxgfxm.github.io/blog/2016/10/19/today-extension-widget</id>
    <content type="html"><![CDATA[<h2>Widget简介</h2>

<p>从iOS 8开始，引入<strong>widget</strong>特性。可以在通知中心的<strong>Today</strong>栏中添加widget。widget可以简单理解为一个小的扩展程序，可以展示相关应用的简略信息，提供快捷访问等功能。</p>

<p>widget的概念在Android中已经十分成熟，iOS widget与自由度相当高的Android widget有显著的区别。iOS widget的刷新时间为展示widget时，而不是像Android widget时刻保持在后台，消耗系统资源。iOS widget只是作为很小的配角存在，Apple的中心思想还是希望开发者关注App本身的设计和性能。</p>

<p>尽管iOS widget是一种约束状态下的自由，但已经逐渐改变用户的交互行为。</p>

<!--more-->


<h2>创建Widget</h2>

<p>1、创建工程；</p>

<p>2、为工程添加新<strong>Target</strong>，并选择<strong>Today Extension</strong>模板；</p>

<p><img src="http://ofj92itlz.bkt.clouddn.com/Widget:step1.jpeg" alt="step1" /> <img src="http://ofj92itlz.bkt.clouddn.com/Widget:step2.jpeg" alt="stept" /></p>

<p> <img src="http://ofj92itlz.bkt.clouddn.com/Widget:step3.jpeg" alt="step3" /></p>

<p>3、改为纯代码创建界面，默认会创建<strong>MainInterface.storyboard</strong>设计界面。删除Info.plist文件中的字段，并添加<strong>NSExtensionPrincipalClass</strong>字段，设为对应的<strong>TodayViewController</strong>； <img src="http://ofj92itlz.bkt.clouddn.com/Widget:step5.jpeg" alt="step4" /></p>

<p>4、在TodayViewController中创建界面。</p>

<h2>点击Widget跳转至主应用</h2>

<p>为widget添加跳转至主应用的快捷入口。</p>

<p>为widget添加一层透明UIView，并添加tap手势，当点击widget时，执行下面方法：</p>

<pre><code class="objective-c">- (void)tapAction {
  [self.extensionContext openURL:[NSURL URLWithString:@"customScheme://url"]
               completionHandler:nil];
}
</code></pre>

<p>其中<strong>customScheme</strong>可以自定义为需要的名字，字符串整体一定要符合<strong>URL</strong>格式，否则无法跳转。</p>

<h2>主应用响应跳转</h2>

<p>tapAction方法发出打开URL请，系统会查找注册过相同scheme的应用，并对其通知。所以主应用要注册相同的scheme，并且实现对通知的响应。</p>

<p>首先，在主应用的<strong>Info.plist</strong>文件中，添加<strong>URL types</strong>字段，并最终添加对应的scheme。</p>

<p><img src="http://ofj92itlz.bkt.clouddn.com/Widget:step4.jpeg" alt="step5" /></p>

<p>然后，在主应用<strong>AppDelegate.m</strong>中添加如下方法：</p>

<pre><code class="objective-c">- (BOOL)application:(UIApplication *)application
            openURL:(NSURL *)url
  sourceApplication:(NSString *)sourceApplication
         annotation:(id)annotation {
  if ([[url scheme] isEqualToString:@"customScheme"]) {
    //  scheme相同，打开应用
    return YES;
  }
  //    scheme不同，退出
  return NO;
}
</code></pre>

<h2>不同应用间跳转</h2>

<p>大致过程与widget跳转至主应用相同，差别在于发送跳转请求的方法不同，如下：</p>

<pre><code class="objective-c">- (void)jumpToApp2 {
  [[UIApplication sharedApplication]
      openURL:[NSURL URLWithString:[NSString stringWithFormat:@"customScheme://"
                                                              @"www.ticwath."
                                                              @"com?name=%@",
                                                              self.tf.text]]
      options:@{}
      completionHandler:^(BOOL success) {
        if (success) {
          NSLog(@"success");
        } else {
          NSLog(@"failed");
        }
      }];
}
</code></pre>

<p>一定要保持两者约定的scheme相同。跳转时传递的信息保存在<strong>URL</strong>中，按约定解析即可。</p>

<h2>Github源码</h2>

<p><a href="https://github.com/sxgfxm/WidgetDemo/tree/master">WidgetDemo</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS判断GPS坐标是否在中国]]></title>
    <link href="http://sxgfxm.github.io/blog/2016/10/19/iospan-duan-gpszuo-biao-shi-fou-zai-zhong-guo/"/>
    <updated>2016-10-19T10:29:23+08:00</updated>
    <id>http://sxgfxm.github.io/blog/2016/10/19/iospan-duan-gpszuo-biao-shi-fou-zai-zhong-guo</id>
    <content type="html"><![CDATA[<h2>Background</h2>

<p>GPS定位已经深入生活的方方面面。现实生活中存在着多种GPS坐标系：</p>

<ul>
<li><strong>WGS-84坐标系</strong>（World Geodetic System——1984 Coordinate System），国际通用GPS坐标系。</li>
<li><strong>GCJ-02坐标系</strong>（Guojia Cehui Ju Coordinate System），中国专用坐标系，加入随机偏差，俗称火星坐标。</li>
<li><strong>百度坐标系</strong>，百度自己定义的坐标系。</li>
</ul>


<p>在iOS应用开发中，<strong>CoreLocation</strong>返回<strong>WGS坐标</strong>，当定位在中国时，如果直接用<strong>MKMapView</strong>显示位置，由于中国地图使用<strong>GCJ坐标</strong>，会使定位出现偏差，达不到预期效果。为解决这一问题，在显示位置之前，需要判断<strong>WGS坐标</strong>是否在中国，并作出相应的坐标转换。</p>

<p>该问题抽象为<strong>判断点是否在多边形内部</strong>。</p>

<!--more-->


<h2>判断点是否在多边形内部算法</h2>

<ul>
<li>面积和判别法：判断目标点与多边形的每条边组成的三角形面积和是否等于该多边形，相等则在多边形内部。</li>
<li>夹角和判别法：判断目标点与所有边的夹角和是否为360度，为360度则在多边形内部。</li>
<li>引射线法：从目标点出发引一条射线，看这条射线和多边形所有边的交点数目。如果有奇数个交点，则说明在内部，如果有偶数个交点，则说明在外部。</li>
</ul>


<p>算法原理在此不再赘述，主要关注算法的实现问题。</p>

<h2>采用引射线法判断GPS坐标是否在中国</h2>

<h4>构造中国大陆轮廓</h4>

<p>因为<strong>GCJ坐标系</strong>不包含港澳台地区，所有选取中国大陆地区的采样点。</p>

<p>本文使用的采样点有限，某些边界可能存在偏差，仅供参考。</p>

<pre><code class="objective-c">//  中国大陆多边形，用于判断坐标是否在中国
//  因为港澳台地区使用WGS坐标，所以多边形不包含港澳台地区
+ (NSMutableArray *)polygonOfChina {
  static NSMutableArray *polygonOfChina = nil;
  static dispatch_once_t onceToken;
  dispatch_once(&amp;onceToken, ^{
    polygonOfChina = [[NSMutableArray alloc] init];
    [polygonOfChina
     addObject:[NSValue valueWithCGPoint:CGPointMake(49.1506690000,
                                                     87.4150810000)]];
    [polygonOfChina
     addObject:[NSValue valueWithCGPoint:CGPointMake(48.3664501790,
                                                     85.7527085300)]];
    [polygonOfChina
     addObject:[NSValue valueWithCGPoint:CGPointMake(47.0253058185,
                                                     85.3847443554)]];
    [polygonOfChina
     addObject:[NSValue valueWithCGPoint:CGPointMake(45.2406550000,
                                                     82.5214000000)]];
    [polygonOfChina
     addObject:[NSValue valueWithCGPoint:CGPointMake(44.8957121295,
                                                     79.9392351487)]];
    [polygonOfChina
     addObject:[NSValue valueWithCGPoint:CGPointMake(43.1166843846,
                                                     80.6751253982)]];
    [polygonOfChina
     addObject:[NSValue valueWithCGPoint:CGPointMake(41.8701690000,
                                                     79.6882160000)]];
    [polygonOfChina
     addObject:[NSValue valueWithCGPoint:CGPointMake(39.2896190000,
                                                     73.6171080000)]];
    [polygonOfChina
     addObject:[NSValue valueWithCGPoint:CGPointMake(34.2303430000,
                                                     78.9155300000)]];
    [polygonOfChina
     addObject:[NSValue valueWithCGPoint:CGPointMake(31.0238860000,
                                                     79.0627080000)]];
    [polygonOfChina
     addObject:[NSValue valueWithCGPoint:CGPointMake(27.9989800000,
                                                     88.7028920000)]];
    [polygonOfChina
     addObject:[NSValue valueWithCGPoint:CGPointMake(27.1793590000,
                                                     88.9972480000)]];
    [polygonOfChina
     addObject:[NSValue valueWithCGPoint:CGPointMake(28.0969170000,
                                                     89.7331400000)]];
    [polygonOfChina
     addObject:[NSValue valueWithCGPoint:CGPointMake(26.9157800000,
                                                     92.1615830000)]];
    [polygonOfChina
     addObject:[NSValue valueWithCGPoint:CGPointMake(28.1947640000,
                                                     96.0986050000)]];
    [polygonOfChina
     addObject:[NSValue valueWithCGPoint:CGPointMake(27.4094760000,
                                                     98.6742270000)]];
    [polygonOfChina
     addObject:[NSValue valueWithCGPoint:CGPointMake(23.9085500000,
                                                     97.5703890000)]];
    [polygonOfChina
     addObject:[NSValue valueWithCGPoint:CGPointMake(24.0775830000,
                                                     98.7846100000)]];
    [polygonOfChina
     addObject:[NSValue valueWithCGPoint:CGPointMake(22.1375640000,
                                                     99.1893510000)]];
    [polygonOfChina
     addObject:[NSValue valueWithCGPoint:CGPointMake(21.1398950000,
                                                     101.7649720000)]];
    [polygonOfChina
     addObject:[NSValue valueWithCGPoint:CGPointMake(22.2746220000,
                                                     101.7281780000)]];
    [polygonOfChina
     addObject:[NSValue valueWithCGPoint:CGPointMake(23.2641940000,
                                                     105.3708430000)]];
    [polygonOfChina
     addObject:[NSValue valueWithCGPoint:CGPointMake(22.7191200000,
                                                     106.6954480000)]];
    [polygonOfChina
     addObject:[NSValue valueWithCGPoint:CGPointMake(21.9945711661,
                                                     106.7256731791)]];
    [polygonOfChina
     addObject:[NSValue valueWithCGPoint:CGPointMake(21.4847050000,
                                                     108.0200530000)]];
    [polygonOfChina
     addObject:[NSValue valueWithCGPoint:CGPointMake(20.4478440000,
                                                     109.3814530000)]];
    [polygonOfChina
     addObject:[NSValue valueWithCGPoint:CGPointMake(18.6689850000,
                                                     108.2408210000)]];
    [polygonOfChina
     addObject:[NSValue valueWithCGPoint:CGPointMake(17.4017340000,
                                                     109.9333720000)]];
    [polygonOfChina
     addObject:[NSValue valueWithCGPoint:CGPointMake(19.5085670000,
                                                     111.4051560000)]];
    [polygonOfChina
     addObject:[NSValue valueWithCGPoint:CGPointMake(21.2716775175,
                                                     111.2514995205)]];
    [polygonOfChina
     addObject:[NSValue valueWithCGPoint:CGPointMake(21.9936323233,
                                                     113.4625292629)]];
    [polygonOfChina
     addObject:[NSValue valueWithCGPoint:CGPointMake(22.1818312942,
                                                     113.4258358111)]];
    [polygonOfChina
     addObject:[NSValue valueWithCGPoint:CGPointMake(22.2249729295,
                                                     113.5913115000)]];
    [polygonOfChina
     addObject:[NSValue valueWithCGPoint:CGPointMake(22.4501912753,
                                                     113.8946844490)]];
    [polygonOfChina
     addObject:[NSValue valueWithCGPoint:CGPointMake(22.5959159322,
                                                     114.3623797842)]];
    [polygonOfChina
     addObject:[NSValue valueWithCGPoint:CGPointMake(22.4334610000,
                                                     114.5194740000)]];
    [polygonOfChina
     addObject:[NSValue valueWithCGPoint:CGPointMake(22.9680954377,
                                                     116.8326939975)]];
    [polygonOfChina
     addObject:[NSValue valueWithCGPoint:CGPointMake(25.3788220000,
                                                     119.9667980000)]];
    [polygonOfChina
     addObject:[NSValue valueWithCGPoint:CGPointMake(28.3261276204,
                                                     121.7724402562)]];
    [polygonOfChina
     addObject:[NSValue valueWithCGPoint:CGPointMake(31.9883610000,
                                                     123.8808230000)]];
    [polygonOfChina
     addObject:[NSValue valueWithCGPoint:CGPointMake(39.8759700000,
                                                     124.4695370000)]];
    [polygonOfChina
     addObject:[NSValue valueWithCGPoint:CGPointMake(41.7350890000,
                                                     126.9531720000)]];
    [polygonOfChina
     addObject:[NSValue valueWithCGPoint:CGPointMake(41.5142160000,
                                                     128.3145720000)]];
    [polygonOfChina
     addObject:[NSValue valueWithCGPoint:CGPointMake(42.9842081790,
                                                     131.0676468344)]];
    [polygonOfChina
     addObject:[NSValue valueWithCGPoint:CGPointMake(45.2690810000,
                                                     131.8468530000)]];
    [polygonOfChina
     addObject:[NSValue valueWithCGPoint:CGPointMake(45.0608370000,
                                                     133.0610740000)]];
    [polygonOfChina
     addObject:[NSValue valueWithCGPoint:CGPointMake(48.4480260000,
                                                     135.0111880000)]];
    [polygonOfChina
     addObject:[NSValue valueWithCGPoint:CGPointMake(48.0054800000,
                                                     131.6628800000)]];
    [polygonOfChina
     addObject:[NSValue valueWithCGPoint:CGPointMake(50.2270740000,
                                                     127.6890640000)]];
    [polygonOfChina
     addObject:[NSValue valueWithCGPoint:CGPointMake(53.3516070000,
                                                     125.3710040000)]];
    [polygonOfChina
     addObject:[NSValue valueWithCGPoint:CGPointMake(53.4176040000,
                                                     119.9254040000)]];
    [polygonOfChina
     addObject:[NSValue valueWithCGPoint:CGPointMake(47.5590810000,
                                                     115.1421070000)]];
    [polygonOfChina
     addObject:[NSValue valueWithCGPoint:CGPointMake(47.1339370000,
                                                     119.1159230000)]];
    [polygonOfChina
     addObject:[NSValue valueWithCGPoint:CGPointMake(44.8256460000,
                                                     111.2786750000)]];
    [polygonOfChina
     addObject:[NSValue valueWithCGPoint:CGPointMake(42.5293560000,
                                                     109.2549720000)]];
    [polygonOfChina
     addObject:[NSValue valueWithCGPoint:CGPointMake(43.2598160000,
                                                     97.2967290000)]];
    [polygonOfChina
     addObject:[NSValue valueWithCGPoint:CGPointMake(45.4247620000,
                                                     90.9680590000)]];
    [polygonOfChina
     addObject:[NSValue valueWithCGPoint:CGPointMake(47.8075570000,
                                                     90.6737020000)]];
    [polygonOfChina
     addObject:[NSValue valueWithCGPoint:CGPointMake(49.1506690000,
                                                     87.4150810000)]];
  });
  return polygonOfChina;
}
</code></pre>

<h4>采用引射线法判断</h4>

<pre><code class="objective-c">/**
 *  判断是不是在中国
 *  用引射线法判断 点是否在多边形内部
 *  算法参考：http://www.cnblogs.com/luxiaoxun/p/3722358.html
 */
+ (BOOL)isLocationOutOfChina:(CLLocationCoordinate2D)location {
  CGPoint point = CGPointMake(location.latitude, location.longitude);
  BOOL oddFlag = NO;
  NSInteger j = [self polygonOfChina].count - 1;
  for (NSInteger i = 0; i &lt; [self polygonOfChina].count; i++) {
    CGPoint polygonPointi = [[self polygonOfChina][i] CGPointValue];
    CGPoint polygonPointj = [[self polygonOfChina][j] CGPointValue];
    if (((polygonPointi.y &lt; point.y &amp;&amp; polygonPointj.y &gt;= point.y) ||
         (polygonPointj.y &lt; point.y &amp;&amp; polygonPointi.y &gt;= point.y)) &amp;&amp;
        (polygonPointi.x &lt;= point.x || polygonPointj.x &lt;= point.x)) {
      oddFlag ^= (polygonPointi.x +
                  (point.y - polygonPointi.y) /
                  (polygonPointj.y - polygonPointi.y) *
                  (polygonPointj.x - polygonPointi.x) &lt;
                  point.x);
    }
    j = i;
  }
  return !oddFlag;
}
</code></pre>

<h4>测试结果</h4>

<p> <img src="http://ofj92itlz.bkt.clouddn.com/Map:Result.png" alt="result" /></p>

<p>如上图所示，红色多边形为所构造的中国大陆轮廓。随机生成经纬度坐标进行测试，如果在中国，标记为红色；如果不在中国，标记为蓝色。</p>

<h2>参考资料</h2>

<p><a href="http://www.cnblogs.com/luxiaoxun/p/3722358.html">阿凡卢博客</a></p>

<p><a href="https://github.com/TinyQ/TQLocationConverter">Github源码地址</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[UICollectionView iOS 10 New Features]]></title>
    <link href="http://sxgfxm.github.io/blog/2016/10/18/uicollectionview-ios10-new-features/"/>
    <updated>2016-10-18T20:01:45+08:00</updated>
    <id>http://sxgfxm.github.io/blog/2016/10/18/uicollectionview-ios10-new-features</id>
    <content type="html"><![CDATA[<h2>Background</h2>

<p>iPhone屏幕的刷新频率固定为60fps，为了达到流畅的滑动效果，iOS应用展示必须满足该条件。当帧率很低时，就会出现明显的卡顿现象。</p>

<p>60fps相当于每帧16.67毫秒，在这么短的时间内collection view可能并不能完成从相对较慢的数据源加载数据。为了提升collection view性能，一个常用的技巧是使<code>cellForItemAtIndexPath</code>尽可能快的返回cell，比如异步加载网络图片等。为了进一步提高collection view性能，并且尽量减少开发者的工作，在iOS 10中引入了新特性。</p>

<!--more-->


<h2>UICollectionView API变化</h2>

<h4>新增UICollectionViewDataSourcePrefetching协议</h4>

<pre><code class="objective-c">@protocol UICollectionViewDataSourcePrefetching &lt;NSObject&gt;

@required
// indexPaths are ordered ascending by geometric distance from the collection view
- (void)collectionView:(UICollectionView *)collectionView prefetchItemsAtIndexPaths:(NSArray&lt;NSIndexPath *&gt; *)indexPaths NS_AVAILABLE_IOS(10_0);

@optional
// indexPaths that previously were considered as candidates for pre-fetching, but were not actually used; may be a subset of the previous call to -collectionView:prefetchItemsAtIndexPaths:
- (void)collectionView:(UICollectionView *)collectionView cancelPrefetchingForItemsAtIndexPaths:(NSArray&lt;NSIndexPath *&gt; *)indexPaths  NS_AVAILABLE_IOS(10_0);

@end
</code></pre>

<p>这两个方法均异步执行，可用于异步加载图片等。</p>

<h4>新增prefetchDataSource代理</h4>

<pre><code class="objective-c">@property (nonatomic, weak, nullable) id&lt;UICollectionViewDataSourcePrefetching&gt; prefetchDataSource NS_AVAILABLE_IOS(10_0);
</code></pre>

<h4>新增prefetchingEnabled属性</h4>

<pre><code class="objective-c">@property (nonatomic, getter=isPrefetchingEnabled) BOOL prefetchingEnabled NS_AVAILABLE_IOS(10_0);
</code></pre>

<h2>Prefetching</h2>

<p>当collection view滑动速率将要超过<code>cellForItemAtIndexPath</code>返回cell的速率时，collection view会调用<code>prefetchItemAtIndexPaths:</code>方法。</p>

<p>collection view会把<strong>可能</strong>即将需要展示的cell的IndexPath放入数组中传递给prefetch方法。这为我们提供了预处理数据机会。比如，当我们需要加载网络图片时，可以在prefetch方法中请求网络数据，并把下载的数据插入到<strong>data source</strong>中，为<code>cellForItemAtIndexPath</code>的使用做准备。</p>

<p>当collection view滑动方向改变时，collection view会调用<code>cancelPrefetchingForItemsAtIndexPaths</code>方法。</p>

<p>该方法的目的是取消<strong>原本可能</strong>即将展示的cell的预加载数据工作。参数同样是IndexPath的数组。</p>

<h2>UICollectionView Cell生命周期变化</h2>

<h4>UICollectionViewCell Lifecycle: iOS &lt;= 9</h4>

<p> <img src="http://ofj92itlz.bkt.clouddn.com/UICollectionView:UICollectionViewLifecycle_iOS_9.jpeg" alt="UICollectionViewLifecycle_iOS_9" /></p>

<ol>
<li>首先，调用<code>cellForItemAtIndexPath:</code>，从复用队列中弹出一个<strong>cell</strong>，准备对其调用<code>prepareForReuse</code>。</li>
<li>然后，根据需求设置<strong>cell</strong>的内容，比如<strong>labels</strong>等。</li>
<li>当<strong>cell</strong>即将出现时，调用<code>collectionView:willDisplayCell:forItemAtindexPath:</code>。</li>
<li>当<strong>cell</strong>消失时，调用<code>collectionView:didEndDisplayingCell:forItemAtIndexPath:</code>。此时<strong>cell</strong>会重新进入复用队列，等待复用。</li>
<li>当用户向相反方向再次把<strong>cell</strong>滑回屏幕时，会重新从第一步开始执行。</li>
</ol>


<h4>UICollectionViewCell Lifecycle: iOS 10</h4>

<p> <img src="http://ofj92itlz.bkt.clouddn.com/UICollectionView:UICollectionViewLifecycle_iOS_10.jpeg" alt="UICollectionViewLifecycle_iOS_10" /></p>

<p>在iOS 10中，前3个步骤与iOS 9是相同的，新的变化发生在<strong>cell</strong>滑出屏幕的时候。</p>

<p>当调用<code>collectionView:didEndDisplayingCell:forItemAtIndexPath:</code>后，<strong>cell</strong>不会立刻进入复用队列，系统会<strong>keeps it around for a bit</strong>。相当于会缓存该<strong>cell</strong>一小段时间，在这段时间内如果该<strong>cell</strong>再次回到屏幕中，便不会重新调用<code>cellForItemAtIndexPath:</code>，而是直接显示。</p>

<p>至于系统会缓存多久，官方并没有给出明确的时间，感觉跟程序运行时开销有关。</p>

<p>如果想关闭该功能，需要设置<code>collectionView.prefetchingEnabled = NO;</code>。</p>

<p> <img src="http://ofj92itlz.bkt.clouddn.com/UICollectionView:multiple_cells.jpeg" alt="multiple_cells" /></p>

<p>collection view包含多列的情况，主要体现cell的<strong>独立性</strong>。</p>

<p>当某一行需要展示时，每个cell独立出队并调用<code>cellForItemAtIndexPath:</code>方法；</p>

<p>当该行即将展示时，每个cell调用<code>willDisplayCell:atIndexPath:</code>。</p>

<h2>总结</h2>

<ul>
<li>这些变化对开发者都是透明的，对开发者来说只需利用好prefetch特性。</li>
<li>prefetch进一步提升了collection view的性能，尤其是获取cell数据开销比较大或者比较慢时。</li>
<li>每个cell独立出队，单独设置，确保cell在展示之前总是ready。</li>
<li>UITableView拥有相同的新特性。</li>
</ul>


<h2>参考资料：</h2>

<p><a href="https://developer.apple.com/videos/play/wwdc2016/219/">WWDC2016 UICollectionView相关视频</a></p>

<p><a href="https://adoptioncurve.net/archives/2016/06/collection-view-updates-in-ios10/">Adoption Curve Dot Net</a></p>

<p><a href="https://littlebitesofcocoa.com/241-uicollectionview-cell-pre-fetching">little bites of cocoa</a></p>
]]></content>
  </entry>
  
</feed>

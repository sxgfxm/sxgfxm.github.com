<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Ios | Light's Blog]]></title>
  <link href="http://sxgfxm.github.io/blog/categories/ios/atom.xml" rel="self"/>
  <link href="http://sxgfxm.github.io/"/>
  <updated>2017-06-26T11:59:00+08:00</updated>
  <id>http://sxgfxm.github.io/</id>
  <author>
    <name><![CDATA[Light]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[iOS知识小集-170619]]></title>
    <link href="http://sxgfxm.github.io/blog/2017/06/26/ioszhi-shi-xiao-ji-170619/"/>
    <updated>2017-06-26T11:57:15+08:00</updated>
    <id>http://sxgfxm.github.io/blog/2017/06/26/ioszhi-shi-xiao-ji-170619</id>
    <content type="html"><![CDATA[<h2>Enable file sharing</h2>

<p>Application Supports iTunes file sharing = YES</p>

<h2>Image Slicing</h2>

<p>使用Xcode Image Slicing图片需为标准的PNG图片。</p>

<h2>TabBar</h2>

<p>高度49</p>

<!-- more -->


<h2>UIPageViewController</h2>

<p>子controller并不会被缩放，而是从上到下布局，可能被截断。</p>

<pre><code>-(void)setupPageController{
  self.pageController =
      [[UIPageViewController alloc] initWithTransitionStyle:UIPageViewControllerTransitionStyleScroll
                                      navigationOrientation:UIPageViewControllerNavigationOrientationVertical
                                                    options:options];
  self.pageController.view.frame = CGRectMake(0, 64, kScreen_Width, kScreen_Height - 64 - 49);
  self.pageController.dataSource = self;
  self.pages = @[ self.mainVC, self.bottomVC ];
  [self.pageController setViewControllers:@[ self.pages.firstObject ]
                                direction:UIPageViewControllerNavigationDirectionForward
                                 animated:YES
                               completion:nil];
  [self addChildViewController:self.pageController];
  [self.view addSubview:self.pageController.view];
}

#pragma mark - UIPageViewControllerDataSource
- (UIViewController *)pageViewController:(UIPageViewController *)pageViewController
      viewControllerBeforeViewController:(UIViewController *)viewController {
  if ([viewController isKindOfClass:[ViewController1 class]]) {
    return nil;
  }
  if ([viewController isKindOfClass:[ViewController2 class]]) {
    return self.pages[0];
  }
  return nil;
}

- (UIViewController *)pageViewController:(UIPageViewController *)pageViewController
       viewControllerAfterViewController:(UIViewController *)viewController {
  if ([viewController isKindOfClass:[ViewController1 class]]) {
    return self.pages[1];
  }
  if ([viewController isKindOfClass:[ViewController2 class]]) {
    return nil;
  }
  return nil;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS知识小集-170612]]></title>
    <link href="http://sxgfxm.github.io/blog/2017/06/16/ioszhi-shi-xiao-ji-170612/"/>
    <updated>2017-06-16T14:08:12+08:00</updated>
    <id>http://sxgfxm.github.io/blog/2017/06/16/ioszhi-shi-xiao-ji-170612</id>
    <content type="html"><![CDATA[<h2>MBProgressHUD需要在主线程调用</h2>

<p>UI在主线程操作。</p>

<!-- more -->


<h2>引入库</h2>

<p><code>#import &lt;&gt;</code>: global include<br/>
<code>#import ""</code>: local include<br/>
<code>#import</code>: only include once<br/>
<code>#include</code>: may recursive include<br/>
<code>@import</code>: done automatically</p>

<h2>Edit Scheme</h2>

<p>定义不同的宏</p>

<h2>NSAssert</h2>

<p>多用断言</p>

<h2>打包和解包</h2>

<p>打包：头 + 长度 + 内容。</p>

<pre><code>- (NSData *)packageData:(NSData *)data {
  NSAssert(data &amp;&amp; data.length &gt; 0, @"Data cannot be empty");

  NSMutableData *payload = [NSMutableData data];
  int length = (int)data.length;
  [payload appendBytes:kMagicHeader length:4];
  [payload appendBytes:&amp;length length:4];
  [payload appendData:data];

  return payload;
}
</code></pre>

<p>解包：取头 + 取长度 + 取内容。</p>

<pre><code>- (void)parseData:(NSData *)data {
  @synchronized(self) {
    [self.writeBuffer appendData:data];
    while (self.writeBuffer.length - self.writeBufferOffset &gt; 8) {
      // Parse header
      char header[4];
      [self.writeBuffer getBytes:header range:NSMakeRange(self.writeBufferOffset, 4)];
      if (header[0] != kMagicHeader[0] || header[1] != kMagicHeader[1] || header[2] != kMagicHeader[2] ||
          header[3] != kMagicHeader[3]) {
        NSLog(@"Invalid magic header");
        self.writeBufferOffset += 1;
        continue;
      }

      // Parse length
      int length;
      [self.writeBuffer getBytes:&amp;length range:NSMakeRange(self.writeBufferOffset + 4, 4)];

      // Parse payload
      if (self.writeBuffer.length - self.writeBufferOffset - 8 &lt; length) {
        break;
      }
      NSData *payload = [NSData dataWithBytes:[self.writeBuffer bytes] + self.writeBufferOffset + 8 length:length];
      if (self.delegate) {
        [self.delegate onIncomingData:payload];
      }
      self.writeBufferOffset = self.writeBufferOffset + 8 + length;
      if (self.writeBufferOffset &gt;= self.writeBuffer.length) {
        self.writeBuffer = [[NSMutableData alloc] init];
        self.writeBufferOffset = 0;
      }
    }
  }
}
</code></pre>

<h2>NSNetServiceBrowser</h2>

<p>扫描service。</p>

<pre><code>-(void)start{
  NSNetServiceBrowser *browser = [[NSNetServiceBrowser alloc] init];
  browser.delegate = self;
  [browser searchForServicesOfType:@"_http._tcp." inDomain:@""];
}

- (void)netServiceBrowser:(NSNetServiceBrowser *)aNetServiceBrowser
           didFindService:(NSNetService *)aNetService
               moreComing:(BOOL)moreComing {
  if ([self.serviceTypes containsObject:aNetService.name]) {
    NSLog(@"Found a service: %@", aNetService);
    aNetService.delegate = self;
    [aNetService resolveWithTimeout:5];
  }
}

- (void)netServiceBrowser:(NSNetServiceBrowser *)aNetServiceBrowser
         didRemoveService:(NSNetService *)aNetService
               moreComing:(BOOL)moreComing {
}

- (void)netServiceDidResolveAddress:(NSNetService *)netService {
  if ([self.serviceTypes containsObject:netService.name]) {
    [self.delegate serviceAdded:netService];
  }
  NSURL *serviceURL = [NSURL URLWithString:[NSString stringWithFormat:@"http://%@:%li", netService.hostName, (long)netService.port]];
  NSLog(@"Resolved address for service %@: %@", netService, serviceURL);
}

- (void)netService:(NSNetService *)sender didNotResolve:(NSDictionary *)errorDict {
  NSLog(@"Couldn't resolve address for service %@: %@", sender, errorDict);
}
</code></pre>

<h2>Compress files and folder</h2>

<p><strong>Zip</strong></p>

<pre><code>zip -r -X archive_name.zip folder_to_compress
unzip archive_name.zip
</code></pre>

<h2>Upload a file to Google Drive from the command line</h2>

<p>Install <a href="https://github.com/prasmussen/gdrive">gdrive</a>, a command line utility for interacting with Google Drive.</p>

<pre><code>brew install gdrive
</code></pre>

<pre><code>gdrive list
gdrive download file_name
gdrive upload file_name
</code></pre>

<h2>Open a certain folder in Atom</h2>

<pre><code>cd folder_path
atom .
</code></pre>

<h2>AFHTTPSessionManager</h2>

<pre><code>AFHTTPSessionManager *manager = [AFHTTPSessionManager manager];
  manager.responseSerializer = [AFHTTPResponseSerializer serializer];
  [manager GET:kXGFeedbackURL
      parameters:nil
      success:^(NSURLSessionDataTask *_Nonnull task, id _Nonnull responseObject) {
        NSError *error = nil;
        self.dataSource = [[XGFeedbackResponse alloc] initWithData:responseObject error:&amp;error];
        if (error) {
          DDLogDebug(@"XG - Feedback response error %@", error.localizedDescription);
        }
        DDLogDebug(@"XG - Feedback response %@", self.dataSource);
      }
      failure:^(NSURLSessionDataTask *_Nullable task, NSError *_Nonnull error) {
        DDLogDebug(@"XG - Feedback fail %@", error.localizedDescription);
      }];
</code></pre>

<h2>JSONModel</h2>

<pre><code>#import &lt;JSONModel/JSONModel.h&gt;

@protocol XGFeedbackItem;
@protocol XGFeedbackCategory;

@interface XGFeedbackItem : JSONModel

@property(nonatomic, strong) NSString *cn;
@property(nonatomic, strong) NSString *en;
@property(nonatomic, strong) NSString *tw;

@end

@interface XGFeedbackCategory : JSONModel

@property(nonatomic, strong) XGFeedbackItem *title;
@property(nonatomic, strong) NSArray&lt;XGFeedbackItem *&gt;&lt;XGFeedbackItem&gt; *detail;
@property(nonatomic, assign) BOOL multiple;

@end

@interface XGFeedbackResponse : JSONModel

@property(nonatomic, strong) NSString *product;
@property(nonatomic, strong) NSArray&lt;XGFeedbackCategory *&gt;&lt;XGFeedbackCategory&gt; *content;

@end
</code></pre>

<h2>获取系统语言</h2>

<pre><code>NSString *language = [[NSLocale preferredLanguages] firstObject];
  if ([language hasPrefix:@"zh-Hans"]) {
    return self.cn;
  } else if ([language hasPrefix:@"zh-Hant"]) {
    return self.tw;
  } else {
    return self.en;
  }
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS知识小集-170605]]></title>
    <link href="http://sxgfxm.github.io/blog/2017/06/12/ioszhi-shi-xiao-ji-170605/"/>
    <updated>2017-06-12T09:42:42+08:00</updated>
    <id>http://sxgfxm.github.io/blog/2017/06/12/ioszhi-shi-xiao-ji-170605</id>
    <content type="html"><![CDATA[<h2>fopen时路径名为日文时崩溃</h2>

<p>路径中尽量不要出现特殊字符。</p>

<!-- more -->


<h2>显示 &lt; 号</h2>

<p>居然因为是字体原因</p>

<pre><code>      CGFloat width = kScaleFrom_iPhone6_Desgin(5);
      CAShapeLayer *shapeLayer = [CAShapeLayer layer];
      shapeLayer.frame = CGRectMake(CGRectGetMinX(textLayer.frame) - kScaleFrom_iPhone6_Desgin(9), 0, width, width);
      shapeLayer.position = CGPointMake(shapeLayer.position.x, point.y);
      UIBezierPath *path = [UIBezierPath bezierPath];
      [path moveToPoint:CGPointMake(0, width / 2)];
      [path addLineToPoint:CGPointMake(width, 0)];
      [path moveToPoint:CGPointMake(0, width / 2)];
      [path addLineToPoint:CGPointMake(width, width)];
      shapeLayer.path = path.CGPath;
      shapeLayer.strokeColor = UIColorFromRGBA(0xff959595).CGColor;
      shapeLayer.fillColor = [UIColor clearColor].CGColor;
      shapeLayer.lineWidth = 1;
      shapeLayer.lineCap = kCALineCapButt;
      shapeLayer.lineJoin = kCALineJoinMiter;
      [self.yAxisLayer addSublayer:shapeLayer];
</code></pre>

<h2>Register DDLog</h2>

<pre><code>  // Register DDLog
  [DDLog addLogger:[DDTTYLogger sharedInstance]];  // TTY = Xcode console
  [DDLog addLogger:[DDASLLogger sharedInstance]];  // ASL = File log
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS知识小集-170529]]></title>
    <link href="http://sxgfxm.github.io/blog/2017/06/09/ioszhi-shi-xiao-ji-170529/"/>
    <updated>2017-06-09T10:08:09+08:00</updated>
    <id>http://sxgfxm.github.io/blog/2017/06/09/ioszhi-shi-xiao-ji-170529</id>
    <content type="html"><![CDATA[<h2>Open system wifi settings</h2>

<p><code>[[UIApplication sharedApplication] openURL:[NSURL URLWithString:@"App-Prefs:root=WIFI"]];</code></p>

<!-- more -->


<h2>UITextField</h2>

<pre><code>-(void)setupTextField{
  self.wifiNameTF =
      [[UITextField alloc] initWithFrame:CGRectMake(kScaleFrom_iPhone6_Desgin(16), 0,
                                                    self.view.bounds.size.width - kScaleFrom_iPhone6_Desgin(32),
                                                    kScaleFrom_iPhone6_Desgin(54))];
  self.wifiNameTF.placeholder = @"请输入Wi-Fi名称";
  self.wifiNameTF.font = [UIFont systemFontOfSize:kScaleFrom_iPhone6_Desgin(16)];
  self.wifiNameTF.textColor = UIColorFromRGBA(0xff16181d);
  self.wifiNameTF.clearButtonMode = UITextFieldViewModeWhileEditing;
  self.wifiNameTF.autocapitalizationType = UITextAutocapitalizationTypeNone;
  self.wifiNameTF.returnKeyType = UIReturnKeyDone;
  self.wifiNameTF.delegate = self;
  self.wifiNameTF.secureTextEntry = YES;
  self.wifiNameTF.rightView = secureBtn;
  self.wifiNameTF.rightViewMode = UITextFieldViewModeAlways;
  [self.view addSubview:self.wifiNameTF];
}
</code></pre>

<h2>Gradient flow animation</h2>

<p>两倍长度，添加左右移动动画，并添加左右两边覆盖层。</p>

<pre><code>  //  progress bar
  self.progressBar =
      [[UIView alloc] initWithFrame:CGRectMake((self.view.bounds.size.width - kScaleFrom_iPhone6_Desgin(120)) / 2,
                                               kScaleFrom_iPhone6_Desgin(360), kScaleFrom_iPhone6_Desgin(120),
                                               kScaleFrom_iPhone6_Desgin(4))];
  [self.view addSubview:self.progressBar];
  self.gradientLayer = [CAGradientLayer layer];
  self.gradientLayer.frame =
      CGRectMake(-kScaleFrom_iPhone6_Desgin(120), 0, kScaleFrom_iPhone6_Desgin(240), kScaleFrom_iPhone6_Desgin(4));
  self.gradientLayer.locations = @[ @0, @0.15, @0.3, @0.5, @0.65, @0.8, @1 ];
  self.gradientLayer.colors = @[
    (__bridge id)UIColorFromRGBA(0xff1af28f)
        .CGColor,
    (__bridge id)UIColorFromRGBA(0xff0de9c5).CGColor,
    (__bridge id)UIColorFromRGBA(0xff3293fe).CGColor,
    (__bridge id)UIColorFromRGBA(0xff1af28f).CGColor,
    (__bridge id)UIColorFromRGBA(0xff0de9c5).CGColor,
    (__bridge id)UIColorFromRGBA(0xff3293fe).CGColor,
    (__bridge id)UIColorFromRGBA(0xff1af28f).CGColor
  ];
  self.gradientLayer.startPoint = CGPointMake(0, 0);
  self.gradientLayer.endPoint = CGPointMake(1, 0);
  [self.progressBar.layer addSublayer:self.gradientLayer];
  CALayer *leftMask = [CALayer layer];
  leftMask.frame =
      CGRectMake(-kScaleFrom_iPhone6_Desgin(120), 0, kScaleFrom_iPhone6_Desgin(120), kScaleFrom_iPhone6_Desgin(4));
  leftMask.backgroundColor = [UIColor whiteColor].CGColor;
  [self.progressBar.layer addSublayer:leftMask];
  CALayer *rightMask = [CALayer layer];
  rightMask.frame =
      CGRectMake(kScaleFrom_iPhone6_Desgin(120), 0, kScaleFrom_iPhone6_Desgin(120), kScaleFrom_iPhone6_Desgin(4));
  rightMask.backgroundColor = [UIColor whiteColor].CGColor;
  [self.progressBar.layer addSublayer:rightMask];
  CABasicAnimation *moveAnimation = [CABasicAnimation animationWithKeyPath:@"position.x"];
  moveAnimation.fromValue = @(self.gradientLayer.position.x);
  moveAnimation.toValue = @(self.gradientLayer.position.x + kScaleFrom_iPhone6_Desgin(120));
  moveAnimation.repeatCount = 100;
  moveAnimation.duration = 2;
  moveAnimation.autoreverses = NO;
  [self.gradientLayer addAnimation:moveAnimation forKey:@"animation"];
</code></pre>

<h2>Alert with text field</h2>

<pre><code>- (void)changeName {
  // 修改昵称提示框
  UIAlertController *alertController =
      [UIAlertController alertControllerWithTitle:@"Title"
                                          message:nil
                                   preferredStyle:UIAlertControllerStyleAlert];
  // 添加输入框
  [alertController addTextFieldWithConfigurationHandler:^(UITextField *_Nonnull textField) {
    textField.placeholder = @"Please input";
  }];
  // 添加确定按钮
  [alertController addAction:[UIAlertAction actionWithTitle:@"Done"
                                                      style:UIAlertActionStyleDefault
                                                    handler:^(UIAlertAction *_Nonnull action) {
                                                      // 获得当前输入的字符串
                                                      NSString *name = alertController.textFields[0].text;
                                                      self.tichomeNameLbl.text = name;
                                                    }]];
  // 添加取消按钮
  [alertController addAction:[UIAlertAction actionWithTitle:@"Cancel"
                                                      style:UIAlertActionStyleCancel
                                                    handler:^(UIAlertAction *_Nonnull action){
                                                    }]];
  [self presentViewController:alertController animated:YES completion:nil];
}
</code></pre>

<h2>UISlider</h2>

<pre><code>-(void)setupSlider{
  self.volumeSlider = [UISlider new];
  [self.volumeSlider addTarget:self action:@selector(changeVolumeAction) forControlEvents:UIControlEventTouchUpInside];
  self.volumeSlider.minimumValueImage = [UIImage imageNamed:@"icVolumeDown"];
  self.volumeSlider.maximumValueImage = [UIImage imageNamed:@"icVolumeUp"];
  [self.volumeSlider setThumbImage:[UIImage imageNamed:@"icVolumeBtn"] forState:UIControlStateNormal];
  [self.volumeSlider setMinimumTrackImage:[UIImage imageNamed:@"minTrackBg"] forState:UIControlStateNormal];
  [self.volumeSlider setMaximumTrackImage:[UIImage imageNamed:@"maxTrackBg"] forState:UIControlStateNormal];
  [self.contentView addSubview:self.volumeSlider];
  [self.volumeSlider mas_makeConstraints:^(MASConstraintMaker *make) {
    make.centerX.equalTo(self.contentView.mas_centerX);
    make.bottom.equalTo(self.contentView.mas_bottom).offset(-kScaleFrom_iPhone6_Desgin(15));
    make.width.equalTo(@(kScaleFrom_iPhone6_Desgin(270)));
  }];
}
</code></pre>

<h2>UITextView</h2>

<pre><code>-(void)setupTextView{
  self.textView = [UITextView new];
  self.textView.backgroundColor = [UIColor clearColor];
  self.textView.text = @"placeholder";
  self.textView.textColor = [[UIColor whiteColor] colorWithAlphaComponent:0.2];
  self.textView.font = [UIFont systemFontOfSize:14];
  self.textView.delegate = self;
  self.textView.autocapitalizationType = UITextAutocapitalizationTypeNone;
  self.textView.returnKeyType = UIReturnKeyDone;
  [self.contentView addSubview:self.textView];
}

//  实现placeholder功能
- (BOOL)textViewShouldBeginEditing:(UITextView *)textView {
  if (self.isEmpty) {
    textView.textColor = [UIColor whiteColor];
    textView.text = @"";
    self.isEmpty = NO;
  }
  return YES;
}

- (void)textViewDidEndEditing:(UITextView *)textView {
  if (textView.text.length == 0) {
    self.isEmpty = YES;
    textView.text = @"placeholder";
    textView.textColor = [[UIColor whiteColor] colorWithAlphaComponent:0.2];
  }
  [textView resignFirstResponder];
}

//  实现换行替换为结束编辑
- (BOOL)textView:(UITextView *)textView shouldChangeTextInRange:(NSRange)range replacementText:(NSString *)text {
  if ([text isEqualToString:@"\n"]) {
    [textView resignFirstResponder];
    return NO;
  }
  return YES;
}
</code></pre>

<h2>IQActionSheetPickerView</h2>

<pre><code>-(void)setupPickerView{
  NSArray *dataSource = @[@"item1",@"item2",@"item3"];
  IQActionSheetPickerView *categoryPicker = [[IQActionSheetPickerView alloc] initWithTitle:@"选择" delegate:self];
  //  tool bar
  [categoryPicker setTitleFont:[UIFont systemFontOfSize:17]];
  [categoryPicker setTitleColor:[UIColor whiteColor]];
  [categoryPicker setToolbarTintColor:[UIColorFromRGBA(0xff26272e) colorWithAlphaComponent:0.6]];
  [categoryPicker setDoneButtonAttributes:@{
    kIQActionSheetAttributesForNormalStateKey : @{
      NSForegroundColorAttributeName : [[UIColor whiteColor] colorWithAlphaComponent:0.5],
      NSFontAttributeName : [UIFont systemFontOfSize:15]
    }
  }];
  [categoryPicker setCancelButtonAttributes:@{
    kIQActionSheetAttributesForNormalStateKey : @{
      NSForegroundColorAttributeName : [[UIColor grayColor] colorWithAlphaComponent:0.5],
      NSFontAttributeName : [UIFont systemFontOfSize:15]
    }
  }];
  //  component
  [categoryPicker setPickerViewBackgroundColor:UIColorFromRGBA(0xff1c1d24)];
  [categoryPicker setPickerComponentsFont:[UIFont systemFontOfSize:16]];
  [categoryPicker setPickerComponentsColor:[UIColor whiteColor]];
  //  data source
  [categoryPicker setTitlesForComponents:@[ dataSource ]];
  if (self.category) {
    [categoryPicker setSelectedTitles:@[ @"item2" ]];
  }
  //  show
  [categoryPicker show];
}

- (void)actionSheetPickerView:(IQActionSheetPickerView *)pickerView didSelectTitles:(NSArray *)titles {
  //  do something with selected item
}
</code></pre>

<h2>NSURLSession</h2>

<p>completion handler 并非在主线程回调。<br/>
UI相关操作必须在主线程执行。</p>

<h2>Protocol Buffers</h2>

<p>Protocol buffers – a language-neutral, platform-neutral, extensible way of serializing structured data for use in communications protocols, data storage, and more.<br/>
Protocol buffers have many advantages over XML for serializing structured data. Protocol buffers:<br/>
  are simpler<br/>
  are 3 to 10 times smaller<br/>
  are 20 to 100 times faster<br/>
  are less ambiguous<br/>
  generate data access classes that are easier to use programmatically</p>

<ol>
<li>protoc</li>
<li>build rules</li>
<li>build phases</li>
</ol>


<h2>Undefined symbols for architecture arm64</h2>

<p>build phases -> compile source</p>

<h2>NSError</h2>

<p>error.localizedDescription</p>

<h2>block</h2>

<p>循环引用。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS知识小集-170522]]></title>
    <link href="http://sxgfxm.github.io/blog/2017/06/09/ioszhi-shi-xiao-ji-170522/"/>
    <updated>2017-06-09T09:57:35+08:00</updated>
    <id>http://sxgfxm.github.io/blog/2017/06/09/ioszhi-shi-xiao-ji-170522</id>
    <content type="html"><![CDATA[<h2>Networking Concepts</h2>

<p><a href="https://developer.apple.com/library/content/documentation/NetworkingInternet/Conceptual/NetworkingConcepts/Introduction/Introduction.html#//apple_ref/doc/uid/TP40012487">Networking Concepts</a></p>

<!-- more -->


<h3>Networking Terminology</h3>

<p><strong>host</strong>: a host is any device that is connected to a network and provides an endpoint for networked communication.It is called a host because it hosts the applications and daemons that run on it.<br/>
<strong>nfrastructure device</strong>: an infrastructure device is any piece of equipment that is responsible for making the network function.
When one host sends data across a network, it divides the data into small pieces called packets.
A packet generally contains three basic parts: a <strong>header</strong> that tells where the packet should be sent, a <strong>payload</strong> that contains the actual data, and a <strong>trailer</strong> that contains checksum information to ensure that the packet was received correctly.<br/>
<strong>encapsulation</strong>: When one packet contains another packet (generally of a different type), this is called encapsulation.</p>

<h3>Networking Layers</h3>

<p><strong>Link Layer</strong>: The bottommost layer is the link layer, or <strong>physical layer</strong>.This layer of the networking stack involves the actual hardware used to communicate with nearby physically connected hosts.A network interface is a piece of hardware that provides a link-layer interconnect.<br/>
<strong>IP Layer</strong>: Sitting on top of the link layer is the IP layer. The IP layer provides packet transport from one host to another in such a way that the packets can pass across multiple physical networks. The path your packets take is called a route, and each link that the packets follow from one router to another along the route is called a hop.To hide this difference, the IP layer splits packets into multiple pieces—a process known as fragmentation—and reassembles them at the other end.<br/>
<strong>Transport Layer</strong>: On top of the IP layer, you’ll find several transport layers. The two most common protocols at this layer are the transmission control protocol (TCP) and the user datagram protocol (UDP). Both TCP and UDP provide basic data transport from one host to another, much like IP, but add the notion of port numbers.<br/>
<strong>UDP</strong><br/>
  No guarantee &mdash;- Like the layers below it, UDP provides no guarantee that the data will ever reach its destination.<br/>
  Low latency &mdash;- UDP may be a good choice for situations where low latency is required.<br/>
  Broadcast messages in IPv4 &mdash;- packets sent to a broadcast address are received by every host within its broadcast domain.<br/>
  Multicast messages &mdash;- UDP packets sent to a multicast address are sent out to any host that subscribes to them.<br/>
  Preservation of record (packet) boundaries &mdash;- With UDP, the receiver sees each message individually instead of as a continuous stream of bytes.<br/>
<strong>TCP </strong> <br/>
  Delivery guarantees &mdash;- Data transmitted using TCP is guaranteed to be received in the order in which it was sent and (connection failures notwithstanding) in its entirety.<br/>
  Congestion control &mdash;- Sending hosts back off the speed of transmission (and retransmission) if data is getting dropped along the way due to an over-utilized link.<br/>
  Flow control &mdash;- When busy, receiving hosts tell sending hosts to wait until they are ready to handle more data.<br/>
  Stream-based data flow &mdash;- Your software sees the data as a series of bytes instead of as a series of discrete records (messages, in UDP parlance)<br/>
  Path MTU discovery &mdash;- TCP chooses the largest packet size that avoids fragmentation en route.<br/>
<strong>Application Layer</strong>: The application layer sits at the top of the protocol stack. This layer includes such protocols as hypertext transfer protocol (HTTP) and file transfer protocol (FTP).</p>

<h3>Understanding Latency</h3>

<p>Latency refers to the round-trip time for a request. Every network has latency.<br/>
The minimum latency between two points on the earth can be calculated by dividing the distance by the speed at which light or electricity moves in a particular medium.<br/>
Routing delays.<br/>
Retransmission and exponential backoff.<br/>
Signal propagation delays within hardware that receives, transmits, forwards, or repeats packets.</p>

<h3>Addressing Schemes and Domain Names</h3>

<p>At every level of networking, each host is assigned one or more numeric identifiers that uniquely represent it within a particular network.<br/>
<strong>Link-Layer Addressing</strong>: At the link layer (physical layer), each network interface is usually identified by a globally unique hardware ID: Ethernet—MAC address etc.The hardware ID is used to determine whether a particular device should listen to a packet or ignore it.<br/>
<strong>IP-Layer Addressing</strong>: At the IP layer and above, hosts are identified by an IP address. An IP address can be in one of two forms: IPv4 or IPv6.<br/>
  <strong>IPv4</strong>: An IPv4 address consists of four bytes, and is usually represented to the user as a series of four numbers separated by decimal points.<br/>
  <strong>IPv6</strong>: An IPv6 address is a 128-bit value, and is usually written as eight groups of 16-bit hexadecimal numbers separated by colons. Leading zeros in each group can be omitted as long as there is at least one digit in each group.<br/>
<strong>Domain Name System (DNS)</strong>:
A domain name is a human-readable name that describes a particular host. Each domain name is made up of a series of parts separated by periods.<br/>
Features:<br/>
  Minimize service disruption when an IP address changes.<br/>
  Allow a host to be accessed by more than one address.<br/>
  Allow multiple physical hosts to pretend to be a single host.<br/>
  Can adapt to changes in the underlying technology.<br/>
  Being easier to remember.</p>

<h3>Packet Routing and Delivery</h3>

<p>Each packet contains a the link-layer address of its intended recipient.</p>

<h2>Networking Overview</h2>

<p><a href="https://developer.apple.com/library/content/documentation/NetworkingInternetWeb/Conceptual/NetworkingOverview/Introduction/Introduction.html#//apple_ref/doc/uid/TP40010220">Networking Overview</a></p>

<h2>Bonjour Overview</h2>

<p><a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/NetServices/Introduction.html#//apple_ref/doc/uid/10000119i">Bonjour Overview</a></p>

<p>The Bonjour zero-configuration networking architecture provides support for publishing and discovering TCP/IP-based services on a local area or wide area network.<br/>
Bonjour is Apple’s implementation of a suite of zero-configuration networking protocols. Bonjour is designed to make network configuration easier for users.</p>

<h2>NSNetServices and CFNetworkServices Programming Guide</h2>

<p><a href="https://developer.apple.com/library/content/documentation/Networking/Conceptual/NSNetServiceProgGuide/Introduction.html#//apple_ref/doc/uid/TP40002736">NSNetServices and CFNetworkServices Programming Guide</a></p>

<h2>DNS Service Discovery Programming Guide</h2>

<p><a href="https://developer.apple.com/library/content/documentation/Networking/Conceptual/dns_discovery_api/Introduction.html#//apple_ref/doc/uid/TP30000964">DNS Service Discovery Programming Guide</a></p>
]]></content>
  </entry>
  
</feed>

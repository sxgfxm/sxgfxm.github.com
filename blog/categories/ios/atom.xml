<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Ios | Light's Blog]]></title>
  <link href="http://sxgfxm.github.io/blog/categories/ios/atom.xml" rel="self"/>
  <link href="http://sxgfxm.github.io/"/>
  <updated>2017-06-09T10:03:37+08:00</updated>
  <id>http://sxgfxm.github.io/</id>
  <author>
    <name><![CDATA[Light]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[iOS知识小集-170522]]></title>
    <link href="http://sxgfxm.github.io/blog/2017/06/09/ioszhi-shi-xiao-ji-170522/"/>
    <updated>2017-06-09T09:57:35+08:00</updated>
    <id>http://sxgfxm.github.io/blog/2017/06/09/ioszhi-shi-xiao-ji-170522</id>
    <content type="html"><![CDATA[<h2>Networking Concepts</h2>

<p><a href="https://developer.apple.com/library/content/documentation/NetworkingInternet/Conceptual/NetworkingConcepts/Introduction/Introduction.html#//apple_ref/doc/uid/TP40012487">Networking Concepts</a></p>

<!-- more -->


<h3>Networking Terminology</h3>

<p><strong>host</strong>: a host is any device that is connected to a network and provides an endpoint for networked communication.It is called a host because it hosts the applications and daemons that run on it.<br/>
<strong>nfrastructure device</strong>: an infrastructure device is any piece of equipment that is responsible for making the network function.
When one host sends data across a network, it divides the data into small pieces called packets.
A packet generally contains three basic parts: a <strong>header</strong> that tells where the packet should be sent, a <strong>payload</strong> that contains the actual data, and a <strong>trailer</strong> that contains checksum information to ensure that the packet was received correctly.<br/>
<strong>encapsulation</strong>: When one packet contains another packet (generally of a different type), this is called encapsulation.</p>

<h3>Networking Layers</h3>

<p><strong>Link Layer</strong>: The bottommost layer is the link layer, or <strong>physical layer</strong>.This layer of the networking stack involves the actual hardware used to communicate with nearby physically connected hosts.A network interface is a piece of hardware that provides a link-layer interconnect.<br/>
<strong>IP Layer</strong>: Sitting on top of the link layer is the IP layer. The IP layer provides packet transport from one host to another in such a way that the packets can pass across multiple physical networks. The path your packets take is called a route, and each link that the packets follow from one router to another along the route is called a hop.To hide this difference, the IP layer splits packets into multiple pieces—a process known as fragmentation—and reassembles them at the other end.<br/>
<strong>Transport Layer</strong>: On top of the IP layer, you’ll find several transport layers. The two most common protocols at this layer are the transmission control protocol (TCP) and the user datagram protocol (UDP). Both TCP and UDP provide basic data transport from one host to another, much like IP, but add the notion of port numbers.<br/>
<strong>UDP</strong><br/>
  No guarantee &mdash;- Like the layers below it, UDP provides no guarantee that the data will ever reach its destination.<br/>
  Low latency &mdash;- UDP may be a good choice for situations where low latency is required.<br/>
  Broadcast messages in IPv4 &mdash;- packets sent to a broadcast address are received by every host within its broadcast domain.<br/>
  Multicast messages &mdash;- UDP packets sent to a multicast address are sent out to any host that subscribes to them.<br/>
  Preservation of record (packet) boundaries &mdash;- With UDP, the receiver sees each message individually instead of as a continuous stream of bytes.<br/>
<strong>TCP </strong> <br/>
  Delivery guarantees &mdash;- Data transmitted using TCP is guaranteed to be received in the order in which it was sent and (connection failures notwithstanding) in its entirety.<br/>
  Congestion control &mdash;- Sending hosts back off the speed of transmission (and retransmission) if data is getting dropped along the way due to an over-utilized link.<br/>
  Flow control &mdash;- When busy, receiving hosts tell sending hosts to wait until they are ready to handle more data.<br/>
  Stream-based data flow &mdash;- Your software sees the data as a series of bytes instead of as a series of discrete records (messages, in UDP parlance)<br/>
  Path MTU discovery &mdash;- TCP chooses the largest packet size that avoids fragmentation en route.<br/>
<strong>Application Layer</strong>: The application layer sits at the top of the protocol stack. This layer includes such protocols as hypertext transfer protocol (HTTP) and file transfer protocol (FTP).</p>

<h3>Understanding Latency</h3>

<p>Latency refers to the round-trip time for a request. Every network has latency.<br/>
The minimum latency between two points on the earth can be calculated by dividing the distance by the speed at which light or electricity moves in a particular medium.<br/>
Routing delays.<br/>
Retransmission and exponential backoff.<br/>
Signal propagation delays within hardware that receives, transmits, forwards, or repeats packets.</p>

<h3>Addressing Schemes and Domain Names</h3>

<p>At every level of networking, each host is assigned one or more numeric identifiers that uniquely represent it within a particular network.<br/>
<strong>Link-Layer Addressing</strong>: At the link layer (physical layer), each network interface is usually identified by a globally unique hardware ID: Ethernet—MAC address etc.The hardware ID is used to determine whether a particular device should listen to a packet or ignore it.<br/>
<strong>IP-Layer Addressing</strong>: At the IP layer and above, hosts are identified by an IP address. An IP address can be in one of two forms: IPv4 or IPv6.<br/>
  <strong>IPv4</strong>: An IPv4 address consists of four bytes, and is usually represented to the user as a series of four numbers separated by decimal points.<br/>
  <strong>IPv6</strong>: An IPv6 address is a 128-bit value, and is usually written as eight groups of 16-bit hexadecimal numbers separated by colons. Leading zeros in each group can be omitted as long as there is at least one digit in each group.<br/>
<strong>Domain Name System (DNS)</strong>:
A domain name is a human-readable name that describes a particular host. Each domain name is made up of a series of parts separated by periods.<br/>
Features:<br/>
  Minimize service disruption when an IP address changes.<br/>
  Allow a host to be accessed by more than one address.<br/>
  Allow multiple physical hosts to pretend to be a single host.<br/>
  Can adapt to changes in the underlying technology.<br/>
  Being easier to remember.</p>

<h3>Packet Routing and Delivery</h3>

<p>Each packet contains a the link-layer address of its intended recipient.</p>

<h2>Networking Overview</h2>

<p><a href="https://developer.apple.com/library/content/documentation/NetworkingInternetWeb/Conceptual/NetworkingOverview/Introduction/Introduction.html#//apple_ref/doc/uid/TP40010220">Networking Overview</a></p>

<h2>Bonjour Overview</h2>

<p><a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/NetServices/Introduction.html#//apple_ref/doc/uid/10000119i">Bonjour Overview</a></p>

<p>The Bonjour zero-configuration networking architecture provides support for publishing and discovering TCP/IP-based services on a local area or wide area network.<br/>
Bonjour is Apple’s implementation of a suite of zero-configuration networking protocols. Bonjour is designed to make network configuration easier for users.</p>

<h2>NSNetServices and CFNetworkServices Programming Guide</h2>

<p><a href="https://developer.apple.com/library/content/documentation/Networking/Conceptual/NSNetServiceProgGuide/Introduction.html#//apple_ref/doc/uid/TP40002736">NSNetServices and CFNetworkServices Programming Guide</a></p>

<h2>DNS Service Discovery Programming Guide</h2>

<p><a href="https://developer.apple.com/library/content/documentation/Networking/Conceptual/dns_discovery_api/Introduction.html#//apple_ref/doc/uid/TP30000964">DNS Service Discovery Programming Guide</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS知识小集-170515]]></title>
    <link href="http://sxgfxm.github.io/blog/2017/05/17/ioszhi-shi-xiao-ji-170515/"/>
    <updated>2017-05-17T16:57:00+08:00</updated>
    <id>http://sxgfxm.github.io/blog/2017/05/17/ioszhi-shi-xiao-ji-170515</id>
    <content type="html"><![CDATA[<h2>更新cocoapods版本</h2>

<p>正式版：<code>sudo gem install cocoapods</code><br/>
开发版：<code>sudo gem install cocoapods --pre </code></p>

<!-- more -->


<h2>Get local bundle</h2>

<p>通过<code>frameworkName</code>和<code>bundleName</code>获取对应bundle。</p>

<pre><code class="c">+ (NSBundle *)getBundleWithFrameworkName:(NSString *)frameworkName bundleName:(NSString *)bundleName {
  NSString *tmpBundleName = [bundleName copy];
  if (![bundleName hasSuffix:@".bundle"]) {
    tmpBundleName = [NSString stringWithFormat:@"%@.bundle", tmpBundleName];
  }

  NSString *mainBundlePath = [[NSBundle mainBundle] resourcePath];
  NSString *bundlePath = [mainBundlePath stringByAppendingPathComponent:tmpBundleName];
  NSBundle *bundle = [NSBundle bundleWithPath:bundlePath];
  if (bundle) {
    return bundle;
  }

  NSString *tempFramework = [frameworkName copy];
  NSString *frameExtension = @".framework";
  if (![tempFramework hasSuffix:frameExtension]) {
    tempFramework = [tempFramework stringByAppendingString:frameExtension];
  }

  NSString *path = [[[NSBundle mainBundle] privateFrameworksPath] stringByAppendingPathComponent:tempFramework];
  return [NSBundle bundleWithPath:[path stringByAppendingPathComponent:tmpBundleName]];
}
</code></pre>

<h2>Localized string in cocoapods</h2>

<p>在自定义pod中添加语言本地化：<br/>
1. 为<code>MyPod</code>添加语言路径<code>MyPod/Languages/**/*</code>,pod中使用的不同语言的<code>.strings</code>存放在该目录下；<br/>
2. 在<code>MyPod.podspec</code>文件中添加语言bundle：<code>s.resource_bundles = {'LanguageBundle' =&gt; ['MyPod/Languages/**/*']}</code>；<br/>
3. 添加简便调用方法：</p>

<pre><code class="c">NSString *XGLocalizedString(NSString *key, NSString *comment) {
  return [XGFitnessLocalize localizedString:key];
}

+ (NSString *)localizedString:(NSString *)key {
  //  key == nil, return nil;
  if (!key) {
    return key;
  }
  //  system language
  NSUserDefaults *defaults = [NSUserDefaults standardUserDefaults];
  NSArray *languages = [defaults objectForKey:kAppleLanguageKey];
  NSString *language = [languages firstObject];
  //  set default language
  NSString *fileNamePrefix = language;
  if (!([fileNamePrefix isEqualToString:kLanguageEnglish] ||
        [fileNamePrefix isEqualToString:kLanguageSimplifiedChinese] ||
        [fileNamePrefix isEqualToString:kLanguageTraditionalChinese])) {
    fileNamePrefix = kDefaultLanguage;
  }
  //  language bundle
  NSBundle *languageBundle =
      [WWFitnessBundleUtil getBundleWithFrameworkName:kFrameworkName bundleName:kLanguageBundleName];
  //  lproj bundle
  NSString *path = [languageBundle pathForResource:fileNamePrefix ofType:@"lproj"];
  NSBundle *lprojBundle = [NSBundle bundleWithPath:path];
  //  localized string
  NSString *localizedString = [lprojBundle localizedStringForKey:key value:@"" table:@"Localizable"];
  if (!localizedString) {
    localizedString = key;
  }
  return localizedString;
}
</code></pre>

<h2>Image in cocoapods</h2>

<p>在自定义pod中添加图片步骤：<br/>
1. 为<code>MyPod</code>添加图片路径<code>MyPod/Assets/Images</code>,pod中使用的图片存放在该目录下；<br/>
2. 在<code>MyPod.podspec</code>文件中添加图片bundle：<code>s.resource_bundles = {'ImageBundle' =&gt; ['MyPod/Assets/Images/**/*']}</code>；<br/>
3. 为<code>UIImage</code>添加类别方法<code>bundleImageNamed:</code></p>

<pre><code class="objective-c">@implementation UIImage (BundleImage)

+ (UIImage *)bundleImageNamed:(NSString *)name {
  NSBundle *imageBundle = [WWFitnessBundleUtil getBundleWithFrameworkName:@"MyPod" bundleName:@"ImageBundle"];
  return [UIImage imageNamed:name inBundle:imageBundle compatibleWithTraitCollection:nil];
}

@end
</code></pre>

<h2>Font in cocoapods</h2>

<p>自定义字体无法静态添加到自定义pod中，需要动态注册字体才能使用。<br/>
1. 为<code>MyPod</code>添加字体路径<code>MyPod/Fonts</code>,pod中使用的字体存放在该目录下；<br/>
2. 在<code>MyPod.podspec</code>文件中添加字体bundle：<code>s.resource_bundles = {'FontBundle' =&gt; ['MyPod/Fonts/*']}</code>；<br/>
3. 创建注册字体方法，并在使用前仅调用一次。</p>

<pre><code class="objective-c">#import &lt;CoreText/CTFontManager.h&gt;

+ (void)registerFitnessFont {
  [self registerFitnessFont:@"DIN-Regular"];
  [self registerFitnessFont:@"DIN-Medium"];
  [self registerFitnessFont:@"DIN-Bold"];
}

+ (void)registerFitnessFont:(NSString *)fontName {
  NSBundle *fontBundle = [WWFitnessBundleUtil getBundleWithFrameworkName:@"MyPod" bundleName:@"FontBundle"];
  NSURL *fontURL = [fontBundle URLForResource:fontName withExtension:@"otf" /*or TTF*/];
  NSData *inData = [NSData dataWithContentsOfURL:fontURL];
  CFErrorRef error;
  CGDataProviderRef provider = CGDataProviderCreateWithCFData((CFDataRef)inData);
  CGFontRef font = CGFontCreateWithDataProvider(provider);
  if (!CTFontManagerRegisterGraphicsFont(font, &amp;error)) {
    CFStringRef errorDescription = CFErrorCopyDescription(error);
    NSLog(@"Failed to load font: %@", errorDescription);
    CFRelease(errorDescription);
  }
  CFSafeRelease(font);
  CFSafeRelease(provider);
}

void CFSafeRelease(CFTypeRef cf) {
  if (cf != NULL) {
    CFRelease(cf);
  }
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS知识小集-170508]]></title>
    <link href="http://sxgfxm.github.io/blog/2017/05/17/ioszhi-shi-xiao-ji-170508/"/>
    <updated>2017-05-17T16:52:43+08:00</updated>
    <id>http://sxgfxm.github.io/blog/2017/05/17/ioszhi-shi-xiao-ji-170508</id>
    <content type="html"><![CDATA[<h2>Carthage</h2>

<p>安装：<code>brew install carthage</code><br/>
添加：<code>Cartfile</code><br/>
运行：<code>carthage update</code><br/>
添加：<code>Carthage/Build/.framework</code></p>

<!-- more -->


<h2>防止重复push/present类型相同的controller</h2>

<ol>
<li>找到最上层view controller；</li>
<li>判断最上层view controller与待展示view controller是否类型相同；</li>
<li>如果类型不同，才进行操作。
获取最底层view controller：<code>[UIApplication sharedApplication].delegate.window.rootViewController</code>。<br/>
获取最上层view controller：</li>
</ol>


<pre><code>+ (UIViewController *)topViewController {
  return [self
      topViewControllerWithRootViewController:[UIApplication sharedApplication].delegate.window.rootViewController];
}

+ (UIViewController *)topViewControllerWithRootViewController:(UIViewController *)rootViewController {
  NSLog(@"root to top vc:%@", NSStringFromClass([rootViewController class]));
  if ([rootViewController isKindOfClass:[MMDrawerController class]]) {
    MMDrawerController *mmdVc = (MMDrawerController *)rootViewController;
    return [self topViewControllerWithRootViewController:mmdVc.centerViewController];
  } else if ([rootViewController isKindOfClass:[UITabBarController class]]) {
    UITabBarController *tabBarController = (UITabBarController *)rootViewController;
    return [self topViewControllerWithRootViewController:tabBarController.selectedViewController];
  } else if ([rootViewController isKindOfClass:[UINavigationController class]]) {
    UINavigationController *navigationController = (UINavigationController *)rootViewController;
    return [self topViewControllerWithRootViewController:navigationController.visibleViewController];
  } else if (rootViewController.presentedViewController) {
    UIViewController *presentedViewController = rootViewController.presentedViewController;
    return [self topViewControllerWithRootViewController:presentedViewController];
  } else {
    return rootViewController;
  }
}
</code></pre>

<h2>Create Groups vs Create Folder References</h2>

<p>Group：不创建文件夹，不能同名； <br/>
Folder：创建文件夹，可以重名；</p>

<h2>拉伸Image</h2>

<p>代码：<code>- (UIImage *)resizableImageWithCapInsets:(UIEdgeInsets)capInsets resizingMode:(UIImageResizingMode)resizingMode NS_AVAILABLE_IOS(6_0);</code><br/>
设置：Assets -> Attributes Inspector -> Slicing</p>

<h2>隐藏文件</h2>

<p>显示隐藏文件：<code>defaults write com.apple.finder AppleShowAllFiles -bool true</code><br/>
隐藏隐藏文件：<code>defaults write com.apple.finder AppleShowAllFiles -bool false</code>
重启finder：<code>killall Finder</code></p>

<h2>NavigationBar &amp; ScrollView</h2>

<p>自动：<code>contentOffset.y == -64</code><br/>
手动：<code>self.edgesForExtendedLayout = UIRectEdgeNone;</code>，y轴0点下移64。</p>

<h2>Objective-C static vs external</h2>

<p>static: In C and Objective-C, a static variable or function at global scope means that that symbol has internal linkage.<br/>
external: If you want to have a single global variable, you can&rsquo;t have it in class scope like in C++. One option is to create a global variable with external linkage: declare the variable with the extern keyword in a header file, and then in one source file, define it at global scope without the extern keyword.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS知识小集-170501]]></title>
    <link href="http://sxgfxm.github.io/blog/2017/05/17/ioszhi-shi-xiao-ji-170501/"/>
    <updated>2017-05-17T16:42:40+08:00</updated>
    <id>http://sxgfxm.github.io/blog/2017/05/17/ioszhi-shi-xiao-ji-170501</id>
    <content type="html"><![CDATA[<h1>ComponentKit Tutorial - CollectionView</h1>

<h2>Install</h2>

<p>通过 <strong>Carthage</strong> 安装，在 <strong>Cartfile</strong> 中添加<code>github "facebook/ComponentKit" ~&gt; 0.20</code>，然后运行<code>carthage update</code>，编译完成后，在 <strong>Embedded Binaries</strong> 添加<code>Carthage/Build/iOS/ComponentKit.framework</code>。所有需要使用ComponentKit的源文件需要修改后缀为 <strong>.mm</strong>。</p>

<h2>Philosophy</h2>

<p>Doing so this reverses the traditional approach for a <code>UICollectionViewDataSource</code>. Usually the controller layer will <strong>tell</strong> the <code>UICollectionView</code> to update and then the <code>UICollectionView</code> <strong>ask</strong> the datasource for the data. Here the model is  more Reactive, from an external prospective, the datasource is <strong>told</strong> what changes to apply and then <strong>tell</strong> the collection view to apply the corresponding changes.</p>

<!-- more -->


<h2>步骤</h2>

<h3>CKComponentProvider Protocol</h3>

<p>ViewController需要遵守<code>CKComponentProvider</code>协议，实现<code>+componentForModel: context:</code>方法，将model转换为component。<br/>
在该方法中，通过不同类型的model返回不同类型的component。</p>

<pre><code>+ (CKComponent *)componentForModel:(id&lt;NSObject&gt;)model
                           context:(id&lt;NSObject&gt;)context {
  if ([model isKindOfClass:[NewsModel class]]) {
    return [NewsComponent newWithNewsModel:model context:context];
  }
  return nil;
}
</code></pre>

<h3>FlowLayout</h3>

<pre><code>UICollectionViewFlowLayout *flowLayout = [[UICollectionViewFlowLayout alloc] init];
[flowLayout setScrollDirection:UICollectionViewScrollDirectionVertical];
[flowLayout setMinimumInteritemSpacing:0];
[flowLayout setMinimumLineSpacing:0];
</code></pre>

<h3>CollectionView</h3>

<pre><code>self.collectionView = [[UICollectionView alloc] initWithFrame:self.view.bounds collectionViewLayout:flowLayout];
self.collectionView.delegate = self;
self.collectionView.backgroundColor = [UIColor blackColor];
[self.view addSubview:self.collectionView];
</code></pre>

<h3>Item size range</h3>

<p>Item size range。通过设置<code>CKComponentSizeRangeFlexibleHeight</code>使item的高度自适应。</p>

<pre><code>const CKSizeRange sizeRange = [[CKComponentFlexibleSizeRangeProvider
      providerWithFlexibility:CKComponentSizeRangeFlexibleHeight]
     sizeRangeForBoundingSize:self.collectionView.bounds.size];
</code></pre>

<h3>Context</h3>

<p>Context可以是任何不可变对象，创建component时的不可变上下文信息，比如设备类型，图片下载器。<br/>
<code>MyContext *context = [MyContext new];</code><br/>
预先在主线程加载图片。</p>

<h3>Configuration</h3>

<p>DataSource的configuration，需要 <strong>ComponentProvider</strong>，<strong>sizeRange</strong>，<strong>context</strong> 三个参数。</p>

<pre><code>CKTransactionalComponentDataSourceConfiguration *configuration =
      [[CKTransactionalComponentDataSourceConfiguration alloc]
          initWithComponentProvider:[self class]
                            context:context
                          sizeRange:sizeRange];
</code></pre>

<h3>DataSource</h3>

<p>需要 <strong>collectionView</strong>，<strong>supplementaryViewDataSource</strong>，<strong>configuration</strong> 三个参数。</p>

<pre><code>self.dataSource = [[CKCollectionViewTransactionalDataSource alloc]
           initWithCollectionView:self.collectionView
      supplementaryViewDataSource:nil
                    configuration:configuration];
</code></pre>

<h3>Initial Changeset</h3>

<p>需要初始化DataSource，即向DataSource中添加Section。</p>

<pre><code>CKTransactionalComponentDataSourceChangeset *initialChangeset =
  [[[CKTransactionalComponentDataSourceChangesetBuilder
      transactionalComponentDataSourceChangeset]
      withInsertedSections:[NSIndexSet indexSetWithIndex:0]] build];
[self.dataSource applyChangeset:initialChangeset
                           mode:CKUpdateModeAsynchronous
                       userInfo:nil];
</code></pre>

<h3>insert/update items</h3>

<p>向DataSource中插入Items才能显示。</p>

<pre><code>NSMutableDictionary&lt;NSIndexPath *, NewsModel *&gt; *items = [NSMutableDictionary new];
for (NSInteger i = 0; i &lt; 50; i++) {
  NewsModel *newsModel = [[NewsModel alloc] init];
  newsModel.title = [NSString stringWithFormat:@"News Title: Title %ld", i];
  newsModel.category = @"科技";
  newsModel.updateTime = [NSDate date];
  newsModel.source = @"网易新闻";
  [items setObject:newsModel
            forKey:[NSIndexPath indexPathForRow:i inSection:0]];
}
CKTransactionalComponentDataSourceChangeset *changeset =
  [[[CKTransactionalComponentDataSourceChangesetBuilder
      transactionalComponentDataSourceChangeset]
      withInsertedItems:items] build];
[self.dataSource applyChangeset:changeset
                           mode:CKUpdateModeAsynchronous
                       userInfo:nil];
</code></pre>

<h3>UICollectionView delegate</h3>

<pre><code>- (CGSize)collectionView:(UICollectionView *)collectionView
                  layout:(UICollectionViewLayout *)collectionViewLayout
  sizeForItemAtIndexPath:(NSIndexPath *)indexPath {
  return [self.dataSource sizeForItemAtIndexPath:indexPath];
}

- (void)collectionView:(UICollectionView *)collectionView
       willDisplayCell:(UICollectionViewCell *)cell
    forItemAtIndexPath:(NSIndexPath *)indexPath {
  [self.dataSource announceWillDisplayCell:cell];
}

- (void)collectionView:(UICollectionView *)collectionView
  didEndDisplayingCell:(UICollectionViewCell *)cell
    forItemAtIndexPath:(NSIndexPath *)indexPath {
  [self.dataSource announceDidEndDisplayingCell:cell];
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS知识小集-170424]]></title>
    <link href="http://sxgfxm.github.io/blog/2017/05/17/ioszhi-shi-xiao-ji-170424/"/>
    <updated>2017-05-17T16:38:39+08:00</updated>
    <id>http://sxgfxm.github.io/blog/2017/05/17/ioszhi-shi-xiao-ji-170424</id>
    <content type="html"><![CDATA[<h1>ComponentKit Tutorial - Layout</h1>

<h2>Flexbox Layout</h2>

<p><strong>flex container</strong>：容器。<br/>
main axis：main start， main end。<br/>
cross axis：cross start， cross end。<br/>
<strong>flex item</strong>：成员。<br/>
main size。<br/>
cross size。</p>

<!-- more -->


<h2>Container Properties</h2>

<p>flex-direction：决定主轴方向。</p>

<pre><code>typedef NS_ENUM(NSUInteger, CKStackLayoutDirection) {
  //  垂直方向
  CKStackLayoutDirectionVertical,
  //  水平方向
  CKStackLayoutDirectionHorizontal,
};
</code></pre>

<p>flex-wrap：决定如何换行。<br/>
flex-flow：flex-direction和flex-wrap的简写形式。<br/>
<strong>justify-content</strong>：决定items在主轴上的对齐方式。</p>

<pre><code>/** If no children are flexible, how should this component justify its children in the available space? */
typedef NS_ENUM(NSUInteger, CKStackLayoutJustifyContent) {
  /**
   On overflow, children overflow out of this component's bounds on the right/bottom side.
   On underflow, children are left/top-aligned within this component's bounds.
   */
  //  左对齐
  CKStackLayoutJustifyContentStart,
  /**
   On overflow, children are centered and overflow on both sides.
   On underflow, children are centered within this component's bounds in the stacking direction.
   */
  //  居中
  CKStackLayoutJustifyContentCenter,
  /**
   On overflow, children overflow out of this component's bounds on the left/top side.
   On underflow, children are right/bottom-aligned within this component's bounds.
   */
  //  右对齐
  CKStackLayoutJustifyContentEnd,
};
</code></pre>

<p><strong>align-items</strong>：决定items在交叉轴上的对齐方式。</p>

<pre><code>typedef NS_ENUM(NSUInteger, CKStackLayoutAlignItems) {
  /** Align children to start of cross axis */
  //  交叉轴起点对齐
  CKStackLayoutAlignItemsStart,
  /** Align children with end of cross axis */
  CKStackLayoutAlignItemsEnd,
  //  交叉轴终点对齐
  /** Center children on cross axis */
  //  交叉轴居中对齐
  CKStackLayoutAlignItemsCenter,
  /** Expand children to fill cross axis */
  //  交叉轴方向拉伸
  CKStackLayoutAlignItemsStretch,
};
</code></pre>

<h2>Item Properties</h2>

<p>order：决定item排列顺序，数值越小，排位越靠前。<br/>
<strong>flex-grow</strong>：决定item主轴方向的放大比例，默认为0，即如果存在剩余空间，也不放大。<br/>
如果所有项目的flex-grow属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的flex-grow属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。<br/>
<strong>flex-shrink</strong>：决定item主轴方向的缩小比例，默认为1，即如果空间不足，该item将缩小。<br/>
如果所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小。如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小。<br/>
<strong>flex-basis</strong>：决定了在分配多余空间之前，item的main size大小，根据该值计算主轴是否有多余空间。<br/>
flex：flex-grow, flex-shrink 和 flex-basis的简写。<br/>
<strong>align-self</strong>：决定item单独的对齐方式，可以覆盖 <strong>align-items</strong> 属性。<br/>
默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。</p>

<pre><code>/**
 Each child may override their parent stack's cross axis alignment.
 @see CKStackLayoutAlignItems
 */
typedef NS_ENUM(NSUInteger, CKStackLayoutAlignSelf) {
  /** Inherit alignment value from containing stack. */
  CKStackLayoutAlignSelfAuto,
  CKStackLayoutAlignSelfStart,
  CKStackLayoutAlignSelfEnd,
  CKStackLayoutAlignSelfCenter,
  CKStackLayoutAlignSelfStretch,
};
</code></pre>

<h2>CKStackLayoutComponent</h2>

<p>A simple layout component that stacks a list of children vertically or horizontally.<br/>
动态创建children：</p>

<pre><code>static std::vector&lt;CKStackLayoutComponentChild&gt; createChildren(NSArray* list){
  std::vector&lt;CKStackLayoutComponentChild&gt; children;
  for (VPANewsModel*newsModel in list) {
    children.push_back({[VPANewsComponent newWithNewsModel:newsModel]});
  }
  return children;
}
</code></pre>

<h2>CKBackgroundLayoutComponent</h2>

<p>Lays out a single child component, then lays out a background component behind it stretched to its size.</p>

<pre><code>+ (instancetype)newWithComponent:(CKComponent *)component
                      background:(CKComponent *)background;
</code></pre>

<h2>CKStaticLayoutComponent</h2>

<p>A component that positions children at fixed positions.<br/>
Computes a size that is the union of all childrens' frames.</p>

<h2>CKCenterLayoutComponent</h2>

<p>Lays out a single child component and position it so that it is centered into the layout bounds.</p>

<pre><code>+ (instancetype)newWithCenteringOptions:(CKCenterLayoutComponentCenteringOptions)centeringOptions
                          sizingOptions:(CKCenterLayoutComponentSizingOptions)sizingOptions
                                  child:(CKComponent *)child
                                   size:(const CKComponentSize &amp;)size;
</code></pre>

<h2>CKRatioLayoutComponent</h2>

<p>For when the content should respect a certain inherent ratio but can be scaled (think photos or videos).
The ratio passed is the ratio of height / width you expect.</p>
]]></content>
  </entry>
  
</feed>

<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Ios | Light's Blog]]></title>
  <link href="http://sxgfxm.github.io/blog/categories/ios/atom.xml" rel="self"/>
  <link href="http://sxgfxm.github.io/"/>
  <updated>2017-05-17T16:24:11+08:00</updated>
  <id>http://sxgfxm.github.io/</id>
  <author>
    <name><![CDATA[Light]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[iOS知识小集-170403]]></title>
    <link href="http://sxgfxm.github.io/blog/2017/05/17/ioszhi-shi-xiao-ji-170403/"/>
    <updated>2017-05-17T16:16:33+08:00</updated>
    <id>http://sxgfxm.github.io/blog/2017/05/17/ioszhi-shi-xiao-ji-170403</id>
    <content type="html"><![CDATA[<h2>Heap and Stack</h2>

<p>Value types are created on the stack, Reference types are created on the heap.<br/>
Stack is attached to a thread, and Heap is attached to the application.<br/>
Stack is faster than Heap.</p>

<!-- more -->


<h2>dealloc 是否需要调用[super dealloc]</h2>

<p>ARC中不能调用<code>[super dealloc]</code>。</p>

<p>MRC中，必须最后调用<code>[super dealloc]</code>。</p>

<h2>set a breakpoint in malloc_error_break to debug</h2>

<p>The error message indicates a pointer to a block of freed memory doesn&rsquo;t actually point to free memory.
The most likely cause is that the memory is a freed object instance, but your code as an unretained reference to it and has tried to use it like a &ldquo;live&rdquo; instance.<br/>
Click on the breakpoints navigator (looks like a sign post) on the top of the left bar on XCode.<br/>
On the bottom left hand corner there is a plus sign. Click on it.<br/>
Add Symbolic Breakpoint and set malloc_error_break as the symbol.<br/>
Click the next breakpoint button.</p>

<h2>EXC_BAD_ACCESS</h2>

<p>Whenever you encounter EXC_BAD_ACCESS, it means that you are sending a message to an object that has already been released.<br/>
In summary, when you run into EXC_BAD_ACCESS, it means that you try to send a message to a block of memory that can&rsquo;t execute that message.<br/>
Put differently, deallocated objects are kept alive for debugging purposes. If you send a message to a zombie object, your application will still crash as a result of EXC_BAD_ACCESS.<br/>
Click the active scheme in the top left and choose Edit Scheme.<br/>
Select Run on the left and open the Diagnostics tab at the top. To enable zombie objects, tick the checkbox labeled Enable Zombie Objects.</p>

<h2>dyld: Library not loaded</h2>

<p>In the target&rsquo;s General tab, there is an Embedded Binaries field. When you add the framework there the crash is resolved.</p>

<p>Reference is here on Apple Developer Forums.</p>

<h2>PlantUML</h2>

<p><a href="http://plantuml.com/">PlantUML</a>是一个开源项目，支持快速绘制时序图、用例图、类图等常用软件开发示意图。<br/>
优点：通过代码实现图形绘制，逻辑清晰，扩展维护，效率高。<br/>
集成方法：<br/>
1. 下载安装<a href="https://atom.io/">Atom</a>。
2. Atom -> Preferences -> Packages -> plantuml-viewer。
3. 学习语法，编写代码，自动生成对应图形。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS知识小集-170327]]></title>
    <link href="http://sxgfxm.github.io/blog/2017/04/05/ioszhi-shi-xiao-ji-170403/"/>
    <updated>2017-04-05T09:07:16+08:00</updated>
    <id>http://sxgfxm.github.io/blog/2017/04/05/ioszhi-shi-xiao-ji-170403</id>
    <content type="html"><![CDATA[<h2>转换</h2>

<p>NSURL -> NSString：<code>NSString *path = [url path];</code><br/>
NSString -> NSURL：<code>NSURL *url = [NSURL fileURLWithPath:path];</code> <br/>
UIImage -> NSData：<code>NSData *data = UIImagePNGRepresentation(image);</code><br/>
NSData -> UIImage：<code>UIImage *image = [UIImage imageWithData:data];</code></p>

<!-- more -->


<h2>向歌曲中写入metadata信息</h2>

<p>导入第三方库<a href="https://github.com/larsbs/id3v2lib">id3v2lib</a>。</p>

<pre><code>  //  文件路径
  const char *cPath = [[url path] cStringUsingEncoding:NSUTF8StringEncoding];
  //  创建tag
  ID3v2_tag *tag = load_tag(cPath);
  if (tag == NULL) {
    tag = new_tag();
  }
  //  设置tag
  char *title = (char *)[item.title cStringUsingEncoding:NSUTF8StringEncoding];
  tag_set_title(title, 0, tag);
  char *artist = (char *)[item.artist cStringUsingEncoding:NSUTF8StringEncoding];
  tag_set_artist(artist, 0, tag);
  UIImage *image = [item.artwork imageWithSize:CGSizeMake(400, 400)];
  NSData *data = UIImagePNGRepresentation(image);
  NSString *coverPath = [[NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES) firstObject]
      stringByAppendingPathComponent:[NSString stringWithFormat:@"%@.png", item.title]];
  [[NSFileManager defaultManager] removeItemAtPath:coverPath error:nil];
  [[NSFileManager defaultManager] createFileAtPath:coverPath contents:data attributes:nil];
  tag_set_album_cover([coverPath cStringUsingEncoding:NSUTF8StringEncoding], tag);
  [[NSFileManager defaultManager] removeItemAtPath:coverPath error:nil];
  //  写入tag
  set_tag(cPath, tag);
</code></pre>

<h2>MPMediaItem</h2>

<p>isCloudItem：是否为云端文件；<br/>
hasProtectedAsset：是否含有被保护文件；<br/>
以上两个原因可能导致assertURL为nil。</p>

<h2>NSOperation内存泄露</h2>

<p>operation.completionBlock会引起循环引用。<br/>
在block中创建对象注意生命周期。</p>

<h2>GCDWebServer监听传输状态</h2>

<p>继承<code>GCDWebServerConnection</code>，重写<code>- (void)didWriteBytes:(const void *)bytes length:(NSUInteger)length</code>方法，以通知的形式传递值。</p>

<h2>c string in OC</h2>

<p><code>char *cString = (char *)[string cStringUsingEncoding:NSUTF8StringEncoding]</code>，
无需手动释放，当receiver被释放或者内存不足时，会自动释放cString。</p>

<h2>WiFi ap隔离</h2>

<h2>观察者模式</h2>

<h2>工厂模式</h2>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS知识小集-170320]]></title>
    <link href="http://sxgfxm.github.io/blog/2017/03/27/ioszhi-shi-xiao-ji-170320/"/>
    <updated>2017-03-27T09:58:51+08:00</updated>
    <id>http://sxgfxm.github.io/blog/2017/03/27/ioszhi-shi-xiao-ji-170320</id>
    <content type="html"><![CDATA[<h2>iOS系统分享</h2>

<p>需增加版本判断：<code>UIActivityTypeOpenInIBooks</code>iOS 9.0之后才有。</p>

<h2>iOS导出音乐</h2>

<p>如何导出mp3：先按mov格式导出，再转为mp3。<br/>
如何包含metadata信息：m4a格式自动包含metadata信息，mp3无。<br/>
路径去除特殊字符。</p>

<!-- more -->


<h2>GCDWebserver后台运行</h2>

<p>设置option</p>

<pre><code>- (BOOL)startServer {
  for (int i = 0; i &lt; 10; i++) {
    //  随机端口号
    NSInteger port = arc4random_uniform(64510) + 1025;
    NSDictionary *options = @{
      GCDWebServerOption_ConnectedStateCoalescingInterval : @(20),
      GCDWebServerOption_Port : @(port)
    };
    NSError *error = nil;
    if ([self.webServer startWithOptions:options error:&amp;error]) {
      DDLogDebug(@"Start local server: %@", self.webServer.serverURL);
      return YES;
    }
  }
  return NO;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS知识小集-170313]]></title>
    <link href="http://sxgfxm.github.io/blog/2017/03/20/ioszhi-shi-xiao-ji-170313/"/>
    <updated>2017-03-20T16:50:46+08:00</updated>
    <id>http://sxgfxm.github.io/blog/2017/03/20/ioszhi-shi-xiao-ji-170313</id>
    <content type="html"><![CDATA[<h2>Masonry</h2>

<p>需要先添加到父视图，再设置约束。<br/>
block中无需使用weakself。<br/>
添加约束：makeConstrains。<br/>
更新约束：updateConstrains，与之相关的布局自动调整。<br/>
重设约束：remakeConstrains，删除之前的约束重新添加。</p>

<pre><code>[self.view updateConstraints:^(MASConstraintMaker *make){
  //  updateConstraints
}];
[self.view updateConstraints];
[self.view setNeedsLayout];
[UIView animateWithDuration:3 animations:^{
  [self.view layoutIfNeeded];
}];
</code></pre>

<!-- more -->


<h2>Autolayout</h2>

<p><code>setNeedsLayout</code>：使当前布局失效，并在下一个更新循环中触发布局更新，遍历view的结构。<br/>
<code>layoutIfNeeded</code>：强制立即更新布局，可以实现动画效果。<br/>
scrollview自动布局：添加tmpview，在tmpview上添加view，最后约束tmpview和contentsize。</p>

<h2>退出viewcontroller事件监听</h2>

<h2>IQActionSheetPickerView</h2>

<pre><code>IQActionSheetPickerView *picker = [IQActionSheetPickerView actionSheetWithTitle:@"Age" delegate:self];
NSArray *dataSource = @[@"10",@"20",@"30",@"40",@"50",@"60"];
[picker setTitlesForComponents:@[dataSource]];
[picker setSelectedTitles:@[@"20"]];
[picker show];
</code></pre>

<p>代理回调</p>

<pre><code>- (void)actionSheetPickerView:(IQActionSheetPickerView *)pickerView didSelectTitles:(NSArray *)titles {
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS知识小集-170306]]></title>
    <link href="http://sxgfxm.github.io/blog/2017/03/10/ioszhi-shi-xiao-ji-170306/"/>
    <updated>2017-03-10T17:00:41+08:00</updated>
    <id>http://sxgfxm.github.io/blog/2017/03/10/ioszhi-shi-xiao-ji-170306</id>
    <content type="html"><![CDATA[<h2>异步回调</h2>

<ol>
<li>明确知道操作执行完成；</li>
<li>操作时间未知；</li>
</ol>


<!-- more -->


<h2>Block</h2>

<ol>
<li>对block中的内容强引用；</li>
<li>循环引用，类A的强property类B的强property block强引用self；</li>
<li>单例不用管循环引用；</li>
</ol>


<h2>内存划分</h2>

<ol>
<li>全局区；</li>
<li>静态区；</li>
<li>堆区；</li>
<li>栈区；</li>
</ol>


<h2>单例</h2>

<ol>
<li>如何创建单例？</li>
<li>何时创建单例？</li>
<li>单例的特性？</li>
</ol>


<h2>NSOperation</h2>

<pre><code>-(void)start;
-(void)main;
-(void)cancel;
-(void)addDependency:(NSOperation*)op;
-(void)removeDependency:(NSOperation*)op;
@property BOOL executing;
@property BOOL cancelled;
@property BOOL finished;
@property copy void (^completionBlock)(void);
</code></pre>

<p>使用方法：<br/>
1、继承NSOperation，通过init方法初始化，重写main方法执行任务；<br/>
2、可以通过completionBlock设置执行完成回调；<br/>
3、可以方便的判断任务执行状态，取消任务等；<br/>
4、可以添加和删除依赖关系，依赖其他operation的执行；<br/>
5、可以通过NSCondition阻塞，加锁，生产者-消费者；</p>

<h2>NSOperationQueue</h2>

<pre><code>@property NSInteger maxCoucurrentOperationCount;
@property NSInteger operationCount;
-(void)addOperation:(NSOperation*)op;
-(void)cancelAllOperations;
-(void)waitUntilAllOperationsAreFinished;
</code></pre>

<p>使用方法：<br/>
1、初始化NSOperationQueue，设置同时可并行任务数量；<br/>
2、创建任务，并将其加入队列中，任务自动开始执行；<br/>
3、可以通过operationCount判断还有多少任务未执行；</p>

<h2>HealthKit</h2>

<p>功能：存放健康数据，自动合并；<br/>
读：读某一类别健康数据；<br/>
写：写某一类别健康数据；<br/>
改：改自己写的健康数据。<br/>
锁屏时无法读数据，保护用户数据安全。</p>

<h2>UIPasteboard</h2>

<p>将信息写到剪切板中。</p>

<pre><code>UIPasteboard *pasteboard = [UIPasteboard generalPasteboard];
[pasteboard setString:string];
</code></pre>

<h2>发送本地通知</h2>

<pre><code>// 创建一个本地推送
UILocalNotification *notification = [UILocalNotification new];
if (notification != nil) {
  // 推送声音
  notification.soundName = UILocalNotificationDefaultSoundName;
  // 推送内容
  notification.alertBody = NSLocalizedString(@"stopWatch.timing", @"已将打点计时信息复制到剪切板");
  // 显示在icon上的红色圈中的数子
  notification.applicationIconBadgeNumber++;
  // 设置userinfo 方便在之后需要撤销的时候使用
  NSDictionary *info = [NSDictionary dictionaryWithObject:kStopWatchKey forKey:kNotificationKey];
  notification.userInfo = info;
  // 添加推送到UIApplication
  UIApplication *app = [UIApplication sharedApplication];
  [app scheduleLocalNotification:notification];
}
</code></pre>

<h2>string label</h2>

<pre><code>NSStringDrawingUsesLineFragmentOrigin | NSStringDrawingUsesFontLeading
ceil()
</code></pre>

<h2>相册和相机</h2>

<p>取消选择照片和选择没有照片是不同的回调。<br/>
相片可以编辑，相机不可以编辑。</p>

<h2>类方法、类变量、单例</h2>

<h2>埋点</h2>

<p>点击量；<br/>
人次；<br/>
存留；<br/>
停留时间；</p>
]]></content>
  </entry>
  
</feed>

<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Ios | Light's Blog]]></title>
  <link href="http://sxgfxm.github.io/blog/categories/ios/atom.xml" rel="self"/>
  <link href="http://sxgfxm.github.io/"/>
  <updated>2017-05-17T16:41:01+08:00</updated>
  <id>http://sxgfxm.github.io/</id>
  <author>
    <name><![CDATA[Light]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[iOS知识小集-170424]]></title>
    <link href="http://sxgfxm.github.io/blog/2017/05/17/ioszhi-shi-xiao-ji-170424/"/>
    <updated>2017-05-17T16:38:39+08:00</updated>
    <id>http://sxgfxm.github.io/blog/2017/05/17/ioszhi-shi-xiao-ji-170424</id>
    <content type="html"><![CDATA[<h1>ComponentKit Tutorial - Layout</h1>

<h2>Flexbox Layout</h2>

<p><strong>flex container</strong>：容器。<br/>
main axis：main start， main end。<br/>
cross axis：cross start， cross end。<br/>
<strong>flex item</strong>：成员。<br/>
main size。<br/>
cross size。</p>

<!-- more -->


<h2>Container Properties</h2>

<p>flex-direction：决定主轴方向。</p>

<pre><code>typedef NS_ENUM(NSUInteger, CKStackLayoutDirection) {
  //  垂直方向
  CKStackLayoutDirectionVertical,
  //  水平方向
  CKStackLayoutDirectionHorizontal,
};
</code></pre>

<p>flex-wrap：决定如何换行。<br/>
flex-flow：flex-direction和flex-wrap的简写形式。<br/>
<strong>justify-content</strong>：决定items在主轴上的对齐方式。</p>

<pre><code>/** If no children are flexible, how should this component justify its children in the available space? */
typedef NS_ENUM(NSUInteger, CKStackLayoutJustifyContent) {
  /**
   On overflow, children overflow out of this component's bounds on the right/bottom side.
   On underflow, children are left/top-aligned within this component's bounds.
   */
  //  左对齐
  CKStackLayoutJustifyContentStart,
  /**
   On overflow, children are centered and overflow on both sides.
   On underflow, children are centered within this component's bounds in the stacking direction.
   */
  //  居中
  CKStackLayoutJustifyContentCenter,
  /**
   On overflow, children overflow out of this component's bounds on the left/top side.
   On underflow, children are right/bottom-aligned within this component's bounds.
   */
  //  右对齐
  CKStackLayoutJustifyContentEnd,
};
</code></pre>

<p><strong>align-items</strong>：决定items在交叉轴上的对齐方式。</p>

<pre><code>typedef NS_ENUM(NSUInteger, CKStackLayoutAlignItems) {
  /** Align children to start of cross axis */
  //  交叉轴起点对齐
  CKStackLayoutAlignItemsStart,
  /** Align children with end of cross axis */
  CKStackLayoutAlignItemsEnd,
  //  交叉轴终点对齐
  /** Center children on cross axis */
  //  交叉轴居中对齐
  CKStackLayoutAlignItemsCenter,
  /** Expand children to fill cross axis */
  //  交叉轴方向拉伸
  CKStackLayoutAlignItemsStretch,
};
</code></pre>

<h2>Item Properties</h2>

<p>order：决定item排列顺序，数值越小，排位越靠前。<br/>
<strong>flex-grow</strong>：决定item主轴方向的放大比例，默认为0，即如果存在剩余空间，也不放大。<br/>
如果所有项目的flex-grow属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的flex-grow属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。<br/>
<strong>flex-shrink</strong>：决定item主轴方向的缩小比例，默认为1，即如果空间不足，该item将缩小。<br/>
如果所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小。如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小。<br/>
<strong>flex-basis</strong>：决定了在分配多余空间之前，item的main size大小，根据该值计算主轴是否有多余空间。<br/>
flex：flex-grow, flex-shrink 和 flex-basis的简写。<br/>
<strong>align-self</strong>：决定item单独的对齐方式，可以覆盖 <strong>align-items</strong> 属性。<br/>
默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。</p>

<pre><code>/**
 Each child may override their parent stack's cross axis alignment.
 @see CKStackLayoutAlignItems
 */
typedef NS_ENUM(NSUInteger, CKStackLayoutAlignSelf) {
  /** Inherit alignment value from containing stack. */
  CKStackLayoutAlignSelfAuto,
  CKStackLayoutAlignSelfStart,
  CKStackLayoutAlignSelfEnd,
  CKStackLayoutAlignSelfCenter,
  CKStackLayoutAlignSelfStretch,
};
</code></pre>

<h2>CKStackLayoutComponent</h2>

<p>A simple layout component that stacks a list of children vertically or horizontally.<br/>
动态创建children：</p>

<pre><code>static std::vector&lt;CKStackLayoutComponentChild&gt; createChildren(NSArray* list){
  std::vector&lt;CKStackLayoutComponentChild&gt; children;
  for (VPANewsModel*newsModel in list) {
    children.push_back({[VPANewsComponent newWithNewsModel:newsModel]});
  }
  return children;
}
</code></pre>

<h2>CKBackgroundLayoutComponent</h2>

<p>Lays out a single child component, then lays out a background component behind it stretched to its size.</p>

<pre><code>+ (instancetype)newWithComponent:(CKComponent *)component
                      background:(CKComponent *)background;
</code></pre>

<h2>CKStaticLayoutComponent</h2>

<p>A component that positions children at fixed positions.<br/>
Computes a size that is the union of all childrens' frames.</p>

<h2>CKCenterLayoutComponent</h2>

<p>Lays out a single child component and position it so that it is centered into the layout bounds.</p>

<pre><code>+ (instancetype)newWithCenteringOptions:(CKCenterLayoutComponentCenteringOptions)centeringOptions
                          sizingOptions:(CKCenterLayoutComponentSizingOptions)sizingOptions
                                  child:(CKComponent *)child
                                   size:(const CKComponentSize &amp;)size;
</code></pre>

<h2>CKRatioLayoutComponent</h2>

<p>For when the content should respect a certain inherent ratio but can be scaled (think photos or videos).
The ratio passed is the ratio of height / width you expect.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS知识小集-170417]]></title>
    <link href="http://sxgfxm.github.io/blog/2017/05/17/ioszhi-shi-xiao-ji-170417/"/>
    <updated>2017-05-17T16:33:08+08:00</updated>
    <id>http://sxgfxm.github.io/blog/2017/05/17/ioszhi-shi-xiao-ji-170417</id>
    <content type="html"><![CDATA[<h1>ComponentKit Tutorial - Component</h1>

<h2>CKComponent</h2>

<p>A component is an immutable object that specifies how to configure a view, loosely inspired by React.</p>

<pre><code>+ (instancetype)newWithView:(const CKComponentViewConfiguration &amp;)view
                       size:(const CKComponentSize &amp;)size;
</code></pre>

<p>Example:</p>

<pre><code>CKComponent *component = [CKComponent
    newWithView:{
        [UIView class],
        {
            {@selector(setBackgroundColor:),[UIColor redColor]},
            {@selector(setUserInteractionEnabled:), @YES},
            {CKComponentTapGestureAttribute(@selector(didTap))},
            {CKComponentViewAttribute::LayerAttribute(@selector(setCornerRadius:)), @10.0}
        }
    }
    size:{50,50}];

- (void)didTap{
  [self updateState:^(NSNumber *oldState){
    return [oldState boolValue] ? @NO : @YES;
  } mode:CKUpdateModeSynchronous];
}
</code></pre>

<!-- more -->


<h2>CKLabelComponent</h2>

<p>多行文字通过size.width控制。</p>

<pre><code>CKLabelComponent *titleComponent = [CKLabelComponent newWithLabelAttributes:{
    .string = newsModel.title,
    .color = [UIColor whiteColor],
    .alignment = NSTextAlignmentLeft,
    .font = [UIFont systemFontOfSize:20]
  }
  viewAttributes:{
    { @selector(setBackgroundColor:), [UIColor clearColor] }
  }
  size:{}];
</code></pre>

<h2>CKButtonComponent</h2>

<pre><code> CKButtonComponent *buttonComponent = [CKButtonComponent
    newWithTitles:{
      {UIControlStateNormal,@"button"}
    }
    titleColors:{
      {UIControlStateNormal,[UIColor whiteColor]}
    }
    images:{}
    backgroundImages:{}
    titleFont:[UIFont systemFontOfSize:17]
    selected:NO
    enabled:YES
    action:{@selector(tapAction)}
    size:{}
    attributes:{}
    accessibilityConfiguration:{}];
</code></pre>

<h2>CKImageComponent</h2>

<pre><code>CKImageComponent *image = [CKImageComponent newWithImage:
    [UIImage imageNamed:newsModel.imageURL]
    attributes:{
        { @selector(setBackgroundColor:), [UIColor whiteColor] },
        {CKComponentViewAttribute::LayerAttribute(@selector(setCornerRadius:)), @10.0}
    }
    size:{60, 60}];
</code></pre>

<h2>CKInsetComponent</h2>

<p>A component that wraps another component, applying insets around it.</p>

<pre><code>+ (instancetype)newWithView:(const CKComponentViewConfiguration &amp;)view
                     insets:(UIEdgeInsets)insets
                  component:(CKComponent *)component;

+ (instancetype)newWithInsets:(UIEdgeInsets)insets component:(CKComponent *)child;
</code></pre>

<p>Example:</p>

<pre><code>CKInsetComponent *insetComponent = [CKInsetComponent
    newWithInsets:{.top = 10,.left = 20,.right = 10,.bottom = 20}
    component:[CKComponent
        newWithView:{}
        size:{}]
    ];
</code></pre>

<h2>CKOverlayLayoutComponent</h2>

<p>This component lays out a single component and then overlays a component on top of it streched to its size.</p>

<pre><code>+ (instancetype)newWithComponent:(CKComponent *)component
                         overlay:(CKComponent *)overlay;
</code></pre>

<h2>State</h2>

<p>Simply ask three questions about each piece of data:<br/>
1. Is it passed in from a parent via props? If so, it probably isn&rsquo;t state.<br/>
2. Does it remain unchanged over time? If so, it probably isn&rsquo;t state.<br/>
3. Can you compute it based on any other state or props in your component? If so, it isn&rsquo;t state.</p>

<p>For each piece of state in your application:<br/>
1. Identify every component that renders something based on that state.<br/>
2. Find a common owner component (a single component above all the components that need the state in the hierarchy).<br/>
3. Either the common owner or another component higher up in the hierarchy should own the state.<br/>
4. If you can&rsquo;t find a component where it makes sense to own the state, create a new component simply for holding the state and add it somewhere in the hierarchy above the common owner component.</p>

<h2>Scope</h2>

<ol>
<li>Components that have state must have a scope.</li>
<li>Components that have a controller must have a scope.</li>
<li>Components that have child components with state or controllers may need a scope, even if they don’t have state or controllers.</li>
</ol>


<h2>ComponentController</h2>

<p>与component写在同一个文件里，系统自动创建。<br/>
用来处理代理、事件响应等，有持续的生命周期。<br/>
scope必须唯一，与controller一一对应。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS知识小集-170410]]></title>
    <link href="http://sxgfxm.github.io/blog/2017/05/17/ioszhi-shi-xiao-ji-170410/"/>
    <updated>2017-05-17T16:25:45+08:00</updated>
    <id>http://sxgfxm.github.io/blog/2017/05/17/ioszhi-shi-xiao-ji-170410</id>
    <content type="html"><![CDATA[<h1>ComponentKit Tutorial - Introduction</h1>

<h2>Philosophy</h2>

<p>Components are immutable objects that specify how to configure views.<br/>
<strong>Declarative</strong> : You declare the subcomponents of your component.<br/>
<strong>Functional</strong> : Data flows in one direction.<br/>
<strong>Composable</strong> : Reusing it is a one-liner.</p>

<!-- more -->


<h2>Flex box</h2>

<p><strong>main axis</strong>: The main axis of a flex container is the primary axis along which flex items are laid out. It extends in the main dimension.<br/>
<strong>main-start,main-end</strong>: The flex items are placed within the container starting on the main-start side and going toward the main-end side.<br/>
<strong>main size</strong>: The flex item’s main size property is either the width or height property, whichever is in the main dimension.<br/>
<strong>cross axis</strong>: The axis perpendicular to the main axis is called the cross axis. It extends in the cross dimension.<br/>
<strong>cross-start,cross-end</strong>: Flex lines are filled with items and placed into the container starting on the cross-start side of the flex container and going toward the cross-end side.<br/>
<strong>cross size</strong>: The cross size property is whichever of width or height that is in the cross dimension.</p>

<h2>Uses</h2>

<p><strong>Strengths</strong>:<br/>
Simple and Declarative: Just like React itself. Why React? sums up these benefits.<br/>
Scroll Performance: All layout is performed on a background thread, ensuring the main thread isn’t tied up measuring text.<br/>
View Recycling: By requiring all view configurations to be expressed declaratively, ComponentKit makes error-free view recycling automatic.<br/>
Composability: By encouraging heavy use of composition, it’s possible to build UIs as complex as News Feed without any single component exceeding 300 lines of code.<br/>
<strong>Considerations</strong>:<br/>
Interfaces that aren’t lists or tables aren’t ideally suited to ComponentKit since it is optimized to work well with a UICollectionView.<br/>
ComponentKit is fully native and compiled. React Native offers an alternative based on JavaScriptCore and React, including features like instant reload with no recompilation.<br/>
Dynamic gesture-driven UIs are currently hard to implement in ComponentKit; consider using AsyncDisplayKit.<br/>
ComponentKit is built on Objective-C++. There is no easy way to interoperate with Swift since Swift cannot bridge to C++.</p>

<h2>Component API</h2>

<pre><code>@interface CKComponent : NSObject

/** Returns a new component. */
+ (instancetype)newWithView:(const CKComponentViewConfiguration &amp;)view
                       size:(const CKComponentSize &amp;)size;

@end
</code></pre>

<p>Notes:<br/>
A component is totally immutable. For example, there is no <code>addSubcomponent:</code> method.<br/>
A component can be created on any thread. This helps keep all sizing and construction operations off the main thread.<br/>
The Objective-C idiom <code>+newWith...</code> is used for instantiation instead of the more typical <code>+alloc/-initWith...</code> This is mainly for brevity. Getting rid of noise is important to keep components code readable.</p>

<h2>Composite Components</h2>

<p>Avoid subclassing <code>CKComponent directly</code>. Instead, subclass <code>CKCompositeComponent</code>.<br/>
A “composite component” simply wraps another component, hiding its implementation details from the outside world.</p>

<pre><code>@implementation ShareButtonComponent

+ (instancetype)newWithArticle:(ArticleModel *)article
{
  return [super newWithComponent:
          [CKButtonComponent
           newWithTitles:...
           titleColors:...]];
}

- (void)shareTapped
{
  // Share the article
}

@end
</code></pre>

<h2>Views</h2>

<pre><code>struct CKComponentViewConfiguration {
  CKComponentViewClass viewClass;
  std::unordered_map&lt;CKComponentViewAttribute, id&gt; attributes;
};
</code></pre>

<p>The first field is a view class. Ignore <code>CKComponentViewClass</code> for now — in most cases you just pass a class like <code>[UIImageView class]</code> or <code>[UIButton class]</code>.<br/>
The second field holds a map of attributes to values: font, color, background image, and so forth. Again, ignore <code>CKComponentViewAttribute</code> for now; you can usually use a <code>SEL</code> as the attribute.</p>

<pre><code>[CKComponent
 newWithView:{
   [UIImageView class],
   {
     {@selector(setImage:), image},
     {@selector(setContentMode:), @(UIViewContentModeCenter)} // Wrapping into an NSNumber
   }
 }
 size:{image.size.width, image.size.height}];
</code></pre>

<p>In such situations, just pass {} for the view configuration and no view is created.</p>

<h2>Layout</h2>

<p><code>CKComponent</code> instances do not have any size or position information. Instead, ComponentKit calls the <code>layoutThatFits:</code> method with a given size constraint and the component must return a structure describing both its size, and the position and sizes of its children.</p>

<pre><code>struct CKComponentLayout {
  CKComponent *component;
  CGSize size;
  std::vector&lt;CKComponentLayoutChild&gt; children;
};

struct CKComponentLayoutChild {
  CGPoint position;
  CKComponentLayout layout;
};
</code></pre>

<p><strong>Layout Components</strong>:<br/>
<code>CKStackLayoutComponent</code>: It allows you to stack components vertically or horizontally and specify how they should be flexed and aligned to fit in the available space.<br/>
<code>CKInsetComponent</code>: Applies an inset margin around a component.<br/>
<code>CKBackgroundLayoutComponent</code>: Lays out a component, stretching another component behind it as a backdrop.<br/>
<code>CKOverlayLayoutComponent</code>: Lays out a component, stretching another component on top of it as an overlay.<br/>
<code>CKCenterLayoutComponent</code>: Centers a component in the available space.<br/>
<code>CKRatioLayoutComponent</code>: Lays out a component at a fixed aspect ratio.<br/>
<code>CKStaticLayoutComponent</code>: Allows positioning children at fixed offsets.<br/>
If the components above aren’t powerful enough, you can implement <code>computeLayoutThatFits:</code> manually.</p>

<h2>Responder Chain</h2>

<p>The ComponentKit responder chain is separate from UIView’s responder chain, so you must manually bridge over to the component responder chain if desired.<br/>
The easiest way to handle taps on UIControl views is to use <code>CKComponentActionAttribute</code>.</p>

<pre><code>@implementation SomeComponent

+ (instancetype)new
{
  return [self newWithView:{
    [UIButton class],
    {CKComponentActionAttribute(@selector(didTapButton))}
  }];
}

- (void)didTapButton
{
  // Aha! The button has been tapped.
}

@end
</code></pre>

<h2>Component Actions</h2>

<h2>State</h2>

<p><code>State</code>: Internal to the component, this holds implementation details that the parent should not have to know about.</p>

<pre><code>#import "CKComponentSubclass.h" // import to expose updateState:
@implementation MessageComponent

+ (id)initialState
{
  return @NO;
}

+ (instancetype)newWithMessage:(NSAttributedString *)message
{
  CKComponentScope scope(self);
  NSNumber *state = scope.state();
  return [super newWithComponent:
          [CKTextComponent
           newWithAttributes:{
             .attributedString = message,
             .maximumNumberOfLines = [state boolValue] ? 0 : 5,
           }
           viewAttributes:{}
           accessibilityContext:{}]];
}

- (void)didTapContinueReading
{
  [self updateState:^(id oldState){ return @YES; } mode:CKUpdateModeAsynchronous];
}

@end
</code></pre>

<h2>Scopes</h2>

<p><code>Scopes</code> give components a persistent, unique identity. They’re needed in three cases:<br/>
Components that have <code>state</code> must have a scope.<br/>
Components that have a <code>controller</code> must have a scope.<br/>
Components that have child components with state or controllers may need a scope, even if they don’t have state or controllers.<br/>
Use the <code>CKComponentScope</code> type to define a component scope at the top of a component’s <code>+new</code> method.</p>

<pre><code>+ (instancetype)newWithModel:(Model *)model
{
  CKComponentScope scope(self, model.uniqueID);
  ...
  return [super newWithComponent:...];
}
</code></pre>

<p>If your component doesn’t have a model object with a unique identifier, you can omit that parameter as long as there won’t be multiple siblings of the same type.</p>

<pre><code>CKComponentScope scope(self);
</code></pre>

<h2>Component Controllers</h2>

<p>Every time something changes, an entirely new component is created and the old one is thrown away.<br/>
This means components are short-lived, and their lifecycle is not under your control.<br/>
But sometimes, you do need <strong>an object with a longer lifecycle</strong>. Component controllers fill that role:<br/>
Components can’t be delegates because they are short-lived, but component controllers can be delegates.<br/>
Network downloads take time to complete; the component may have been recreated by the time the download completes. The controller can handle the callback.<br/>
You may need an object to own some other object that should have a long lifetime.<br/>
Controllers are instantiated automatically by ComponentKit. Don’t try to create them manually.<br/>
There is a only a one-way communication channel between the component and its component controller - you can only pass data off of a component to a component controller.<br/>
A component has no reference its corresponding component controller. This is by design.<br/>
To pass data from a component to its controller, expose a <code>@property</code> on the component in a class extension.<br/>
The controller can initialize itself with the properties in <code>initWithComponent:</code>.</p>

<h2>Lifecycle Methods</h2>

<p>Whenever possible, avoid using lifecycle methods. Think of them as an emergency escape hatch for integrating with stateful code.<br/>
Mounting -> Remounting -> Unmounting -> Updating</p>

<h2>Animation</h2>

<p>animationsOnInitialMount: Override this method to specify how to animate the initial appearance of a component.<br/>
animationsFromPreviousComponent: Override this method to specify how to animate between two versions of a component.<br/>
boundsAnimationFromPreviousComponent: Override this method to specify how the top-level bounds of a component should animate inside a <code>UICollectionView</code>.<br/>
If you implement either method, your component must have a <code>scope</code>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS知识小集-170403]]></title>
    <link href="http://sxgfxm.github.io/blog/2017/05/17/ioszhi-shi-xiao-ji-170403/"/>
    <updated>2017-05-17T16:16:33+08:00</updated>
    <id>http://sxgfxm.github.io/blog/2017/05/17/ioszhi-shi-xiao-ji-170403</id>
    <content type="html"><![CDATA[<h2>Heap and Stack</h2>

<p>Value types are created on the stack, Reference types are created on the heap.<br/>
Stack is attached to a thread, and Heap is attached to the application.<br/>
Stack is faster than Heap.</p>

<!-- more -->


<h2>dealloc 是否需要调用[super dealloc]</h2>

<p>ARC中不能调用<code>[super dealloc]</code>。</p>

<p>MRC中，必须最后调用<code>[super dealloc]</code>。</p>

<h2>set a breakpoint in malloc_error_break to debug</h2>

<p>The error message indicates a pointer to a block of freed memory doesn&rsquo;t actually point to free memory.
The most likely cause is that the memory is a freed object instance, but your code as an unretained reference to it and has tried to use it like a &ldquo;live&rdquo; instance.<br/>
Click on the breakpoints navigator (looks like a sign post) on the top of the left bar on XCode.<br/>
On the bottom left hand corner there is a plus sign. Click on it.<br/>
Add Symbolic Breakpoint and set malloc_error_break as the symbol.<br/>
Click the next breakpoint button.</p>

<h2>EXC_BAD_ACCESS</h2>

<p>Whenever you encounter EXC_BAD_ACCESS, it means that you are sending a message to an object that has already been released.<br/>
In summary, when you run into EXC_BAD_ACCESS, it means that you try to send a message to a block of memory that can&rsquo;t execute that message.<br/>
Put differently, deallocated objects are kept alive for debugging purposes. If you send a message to a zombie object, your application will still crash as a result of EXC_BAD_ACCESS.<br/>
Click the active scheme in the top left and choose Edit Scheme.<br/>
Select Run on the left and open the Diagnostics tab at the top. To enable zombie objects, tick the checkbox labeled Enable Zombie Objects.</p>

<h2>dyld: Library not loaded</h2>

<p>In the target&rsquo;s General tab, there is an Embedded Binaries field. When you add the framework there the crash is resolved.</p>

<p>Reference is here on Apple Developer Forums.</p>

<h2>PlantUML</h2>

<p><a href="http://plantuml.com/">PlantUML</a>是一个开源项目，支持快速绘制时序图、用例图、类图等常用软件开发示意图。<br/>
优点：通过代码实现图形绘制，逻辑清晰，扩展维护，效率高。<br/>
集成方法：<br/>
1. 下载安装<a href="https://atom.io/">Atom</a>。
2. Atom -> Preferences -> Packages -> plantuml-viewer。
3. 学习语法，编写代码，自动生成对应图形。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS知识小集-170327]]></title>
    <link href="http://sxgfxm.github.io/blog/2017/04/05/ioszhi-shi-xiao-ji-170403/"/>
    <updated>2017-04-05T09:07:16+08:00</updated>
    <id>http://sxgfxm.github.io/blog/2017/04/05/ioszhi-shi-xiao-ji-170403</id>
    <content type="html"><![CDATA[<h2>转换</h2>

<p>NSURL -> NSString：<code>NSString *path = [url path];</code><br/>
NSString -> NSURL：<code>NSURL *url = [NSURL fileURLWithPath:path];</code> <br/>
UIImage -> NSData：<code>NSData *data = UIImagePNGRepresentation(image);</code><br/>
NSData -> UIImage：<code>UIImage *image = [UIImage imageWithData:data];</code></p>

<!-- more -->


<h2>向歌曲中写入metadata信息</h2>

<p>导入第三方库<a href="https://github.com/larsbs/id3v2lib">id3v2lib</a>。</p>

<pre><code>  //  文件路径
  const char *cPath = [[url path] cStringUsingEncoding:NSUTF8StringEncoding];
  //  创建tag
  ID3v2_tag *tag = load_tag(cPath);
  if (tag == NULL) {
    tag = new_tag();
  }
  //  设置tag
  char *title = (char *)[item.title cStringUsingEncoding:NSUTF8StringEncoding];
  tag_set_title(title, 0, tag);
  char *artist = (char *)[item.artist cStringUsingEncoding:NSUTF8StringEncoding];
  tag_set_artist(artist, 0, tag);
  UIImage *image = [item.artwork imageWithSize:CGSizeMake(400, 400)];
  NSData *data = UIImagePNGRepresentation(image);
  NSString *coverPath = [[NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES) firstObject]
      stringByAppendingPathComponent:[NSString stringWithFormat:@"%@.png", item.title]];
  [[NSFileManager defaultManager] removeItemAtPath:coverPath error:nil];
  [[NSFileManager defaultManager] createFileAtPath:coverPath contents:data attributes:nil];
  tag_set_album_cover([coverPath cStringUsingEncoding:NSUTF8StringEncoding], tag);
  [[NSFileManager defaultManager] removeItemAtPath:coverPath error:nil];
  //  写入tag
  set_tag(cPath, tag);
</code></pre>

<h2>MPMediaItem</h2>

<p>isCloudItem：是否为云端文件；<br/>
hasProtectedAsset：是否含有被保护文件；<br/>
以上两个原因可能导致assertURL为nil。</p>

<h2>NSOperation内存泄露</h2>

<p>operation.completionBlock会引起循环引用。<br/>
在block中创建对象注意生命周期。</p>

<h2>GCDWebServer监听传输状态</h2>

<p>继承<code>GCDWebServerConnection</code>，重写<code>- (void)didWriteBytes:(const void *)bytes length:(NSUInteger)length</code>方法，以通知的形式传递值。</p>

<h2>c string in OC</h2>

<p><code>char *cString = (char *)[string cStringUsingEncoding:NSUTF8StringEncoding]</code>，
无需手动释放，当receiver被释放或者内存不足时，会自动释放cString。</p>

<h2>WiFi ap隔离</h2>

<h2>观察者模式</h2>

<h2>工厂模式</h2>
]]></content>
  </entry>
  
</feed>

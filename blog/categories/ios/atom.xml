<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Ios | Light's Blog]]></title>
  <link href="http://sxgfxm.github.io/blog/categories/ios/atom.xml" rel="self"/>
  <link href="http://sxgfxm.github.io/"/>
  <updated>2016-10-18T21:16:58+08:00</updated>
  <id>http://sxgfxm.github.io/</id>
  <author>
    <name><![CDATA[Light]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[UICollectionView iOS 10 New Features]]></title>
    <link href="http://sxgfxm.github.io/blog/2016/10/18/uicollectionview-ios10-new-features/"/>
    <updated>2016-10-18T20:01:45+08:00</updated>
    <id>http://sxgfxm.github.io/blog/2016/10/18/uicollectionview-ios10-new-features</id>
    <content type="html"><![CDATA[<h2>UICollectionView API变化</h2>

<h4>新增UICollectionViewDataSourcePrefetching协议</h4>

<pre><code class="objective-c">@protocol UICollectionViewDataSourcePrefetching &lt;NSObject&gt;

@required
// indexPaths are ordered ascending by geometric distance from the collection view
- (void)collectionView:(UICollectionView *)collectionView prefetchItemsAtIndexPaths:(NSArray&lt;NSIndexPath *&gt; *)indexPaths NS_AVAILABLE_IOS(10_0);

@optional
// indexPaths that previously were considered as candidates for pre-fetching, but were not actually used; may be a subset of the previous call to -collectionView:prefetchItemsAtIndexPaths:
- (void)collectionView:(UICollectionView *)collectionView cancelPrefetchingForItemsAtIndexPaths:(NSArray&lt;NSIndexPath *&gt; *)indexPaths  NS_AVAILABLE_IOS(10_0);

@end
</code></pre>

<p>这两个方法均异步执行，可用于异步加载图片等。</p>

<h4>新增prefetchDataSource代理</h4>

<pre><code class="objective-c">@property (nonatomic, weak, nullable) id&lt;UICollectionViewDataSourcePrefetching&gt; prefetchDataSource NS_AVAILABLE_IOS(10_0);
</code></pre>

<h4>新增prefetchingEnabled属性</h4>

<pre><code class="objective-c">@property (nonatomic, getter=isPrefetchingEnabled) BOOL prefetchingEnabled NS_AVAILABLE_IOS(10_0);
</code></pre>

<h2>UICollectionView Cell生命周期变化</h2>

<h4>UICollectionViewCell Lifecycle: iOS &lt;= 9</h4>

<p> <img src="../images/UICollectionViewCell/UICollectionViewLifecycle_iOS_9.jpeg" alt="UICollectionViewLifecycle_iOS_9" /></p>

<ol>
<li>首先，调用<code>cellForItemAtIndexPath:</code>，从复用队列中弹出一个<strong>cell</strong>，准备对其调用<code>prepareForReuse</code>。</li>
<li>然后，根据需求设置<strong>cell</strong>的内容，比如<strong>labels</strong>等。</li>
<li>当<strong>cell</strong>即将出现时，调用<code>collectionView:willDisplayCell:forItemAtindexPath:</code>。</li>
<li>当<strong>cell</strong>消失时，调用<code>collectionView:didEndDisplayingCell:forItemAtIndexPath:</code>。此时<strong>cell</strong>会重新进入复用队列，等待复用。</li>
<li>当用户向相反方向再次把<strong>cell</strong>滑回屏幕时，会重新从第一步开始执行。</li>
</ol>


<h4>UICollectionViewCell Lifecycle: iOS 10</h4>

<p> <img src="../images/UICollectionViewCell/UICollectionViewLifecycle_iOS_10.jpeg" alt="UICollectionViewLifecycle_iOS_10" /></p>

<p>在iOS 10中，前3个步骤与iOS 9是相同的，新的变化发生在<strong>cell</strong>滑出屏幕的时候。</p>

<p>当调用<code>collectionView:didEndDisplayingCell:forItemAtIndexPath:</code>后，<strong>cell</strong>不会立刻进入复用队列，系统会<strong>keeps it around for a bit</strong>。相当于会缓存该<strong>cell</strong>一小段时间，在这段时间内如果该<strong>cell</strong>再次回到屏幕中，便不会重新调用<code>cellForItemAtIndexPath:</code>，而是直接显示。</p>

<p>至于系统会缓存多久，官方并没有给出明确的时间，感觉跟程序运行时开销有关。</p>

<p>如果想关闭该功能，需要设置<code>collectionView.prefetchingEnabled = NO;</code>。</p>

<h2>总结</h2>

<ul>
<li>在<code>cellForItemAtIndexPath:</code>中设置cell，尽量保持<code>willDisplay/didEndDisplay</code>轻量级。</li>
<li>cell被创建，但不一定会显示。</li>
<li>UITableView拥有相同的新特性。</li>
</ul>

]]></content>
  </entry>
  
</feed>

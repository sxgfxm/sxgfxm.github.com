<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Ios | Light's Blog]]></title>
  <link href="http://sxgfxm.github.io/blog/categories/ios/atom.xml" rel="self"/>
  <link href="http://sxgfxm.github.io/"/>
  <updated>2017-05-17T17:00:41+08:00</updated>
  <id>http://sxgfxm.github.io/</id>
  <author>
    <name><![CDATA[Light]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[iOS知识小集-170515]]></title>
    <link href="http://sxgfxm.github.io/blog/2017/05/17/ioszhi-shi-xiao-ji-170515/"/>
    <updated>2017-05-17T16:57:00+08:00</updated>
    <id>http://sxgfxm.github.io/blog/2017/05/17/ioszhi-shi-xiao-ji-170515</id>
    <content type="html"><![CDATA[<h2>更新cocoapods版本</h2>

<p>正式版：<code>sudo gem install cocoapods</code><br/>
开发版：<code>sudo gem install cocoapods --pre </code></p>

<!-- more -->


<h2>Get local bundle</h2>

<p>通过<code>frameworkName</code>和<code>bundleName</code>获取对应bundle。</p>

<pre><code class="c">+ (NSBundle *)getBundleWithFrameworkName:(NSString *)frameworkName bundleName:(NSString *)bundleName {
  NSString *tmpBundleName = [bundleName copy];
  if (![bundleName hasSuffix:@".bundle"]) {
    tmpBundleName = [NSString stringWithFormat:@"%@.bundle", tmpBundleName];
  }

  NSString *mainBundlePath = [[NSBundle mainBundle] resourcePath];
  NSString *bundlePath = [mainBundlePath stringByAppendingPathComponent:tmpBundleName];
  NSBundle *bundle = [NSBundle bundleWithPath:bundlePath];
  if (bundle) {
    return bundle;
  }

  NSString *tempFramework = [frameworkName copy];
  NSString *frameExtension = @".framework";
  if (![tempFramework hasSuffix:frameExtension]) {
    tempFramework = [tempFramework stringByAppendingString:frameExtension];
  }

  NSString *path = [[[NSBundle mainBundle] privateFrameworksPath] stringByAppendingPathComponent:tempFramework];
  return [NSBundle bundleWithPath:[path stringByAppendingPathComponent:tmpBundleName]];
}
</code></pre>

<h2>Localized string in cocoapods</h2>

<p>在自定义pod中添加语言本地化：<br/>
1. 为<code>MyPod</code>添加语言路径<code>MyPod/Languages/**/*</code>,pod中使用的不同语言的<code>.strings</code>存放在该目录下；<br/>
2. 在<code>MyPod.podspec</code>文件中添加语言bundle：<code>s.resource_bundles = {'LanguageBundle' =&gt; ['MyPod/Languages/**/*']}</code>；<br/>
3. 添加简便调用方法：</p>

<pre><code class="c">NSString *XGLocalizedString(NSString *key, NSString *comment) {
  return [XGFitnessLocalize localizedString:key];
}

+ (NSString *)localizedString:(NSString *)key {
  //  key == nil, return nil;
  if (!key) {
    return key;
  }
  //  system language
  NSUserDefaults *defaults = [NSUserDefaults standardUserDefaults];
  NSArray *languages = [defaults objectForKey:kAppleLanguageKey];
  NSString *language = [languages firstObject];
  //  set default language
  NSString *fileNamePrefix = language;
  if (!([fileNamePrefix isEqualToString:kLanguageEnglish] ||
        [fileNamePrefix isEqualToString:kLanguageSimplifiedChinese] ||
        [fileNamePrefix isEqualToString:kLanguageTraditionalChinese])) {
    fileNamePrefix = kDefaultLanguage;
  }
  //  language bundle
  NSBundle *languageBundle =
      [WWFitnessBundleUtil getBundleWithFrameworkName:kFrameworkName bundleName:kLanguageBundleName];
  //  lproj bundle
  NSString *path = [languageBundle pathForResource:fileNamePrefix ofType:@"lproj"];
  NSBundle *lprojBundle = [NSBundle bundleWithPath:path];
  //  localized string
  NSString *localizedString = [lprojBundle localizedStringForKey:key value:@"" table:@"Localizable"];
  if (!localizedString) {
    localizedString = key;
  }
  return localizedString;
}
</code></pre>

<h2>Image in cocoapods</h2>

<p>在自定义pod中添加图片步骤：<br/>
1. 为<code>MyPod</code>添加图片路径<code>MyPod/Assets/Images</code>,pod中使用的图片存放在该目录下；<br/>
2. 在<code>MyPod.podspec</code>文件中添加图片bundle：<code>s.resource_bundles = {'ImageBundle' =&gt; ['MyPod/Assets/Images/**/*']}</code>；<br/>
3. 为<code>UIImage</code>添加类别方法<code>bundleImageNamed:</code></p>

<pre><code class="objective-c">@implementation UIImage (BundleImage)

+ (UIImage *)bundleImageNamed:(NSString *)name {
  NSBundle *imageBundle = [WWFitnessBundleUtil getBundleWithFrameworkName:@"MyPod" bundleName:@"ImageBundle"];
  return [UIImage imageNamed:name inBundle:imageBundle compatibleWithTraitCollection:nil];
}

@end
</code></pre>

<h2>Font in cocoapods</h2>

<p>自定义字体无法静态添加到自定义pod中，需要动态注册字体才能使用。<br/>
1. 为<code>MyPod</code>添加字体路径<code>MyPod/Fonts</code>,pod中使用的字体存放在该目录下；<br/>
2. 在<code>MyPod.podspec</code>文件中添加字体bundle：<code>s.resource_bundles = {'FontBundle' =&gt; ['MyPod/Fonts/*']}</code>；<br/>
3. 创建注册字体方法，并在使用前仅调用一次。</p>

<pre><code class="objective-c">#import &lt;CoreText/CTFontManager.h&gt;

+ (void)registerFitnessFont {
  [self registerFitnessFont:@"DIN-Regular"];
  [self registerFitnessFont:@"DIN-Medium"];
  [self registerFitnessFont:@"DIN-Bold"];
}

+ (void)registerFitnessFont:(NSString *)fontName {
  NSBundle *fontBundle = [WWFitnessBundleUtil getBundleWithFrameworkName:@"MyPod" bundleName:@"FontBundle"];
  NSURL *fontURL = [fontBundle URLForResource:fontName withExtension:@"otf" /*or TTF*/];
  NSData *inData = [NSData dataWithContentsOfURL:fontURL];
  CFErrorRef error;
  CGDataProviderRef provider = CGDataProviderCreateWithCFData((CFDataRef)inData);
  CGFontRef font = CGFontCreateWithDataProvider(provider);
  if (!CTFontManagerRegisterGraphicsFont(font, &amp;error)) {
    CFStringRef errorDescription = CFErrorCopyDescription(error);
    NSLog(@"Failed to load font: %@", errorDescription);
    CFRelease(errorDescription);
  }
  CFSafeRelease(font);
  CFSafeRelease(provider);
}

void CFSafeRelease(CFTypeRef cf) {
  if (cf != NULL) {
    CFRelease(cf);
  }
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS知识小集-170508]]></title>
    <link href="http://sxgfxm.github.io/blog/2017/05/17/ioszhi-shi-xiao-ji-170508/"/>
    <updated>2017-05-17T16:52:43+08:00</updated>
    <id>http://sxgfxm.github.io/blog/2017/05/17/ioszhi-shi-xiao-ji-170508</id>
    <content type="html"><![CDATA[<h2>Carthage</h2>

<p>安装：<code>brew install carthage</code><br/>
添加：<code>Cartfile</code><br/>
运行：<code>carthage update</code><br/>
添加：<code>Carthage/Build/.framework</code></p>

<!-- more -->


<h2>防止重复push/present类型相同的controller</h2>

<ol>
<li>找到最上层view controller；</li>
<li>判断最上层view controller与待展示view controller是否类型相同；</li>
<li>如果类型不同，才进行操作。
获取最底层view controller：<code>[UIApplication sharedApplication].delegate.window.rootViewController</code>。<br/>
获取最上层view controller：</li>
</ol>


<pre><code>+ (UIViewController *)topViewController {
  return [self
      topViewControllerWithRootViewController:[UIApplication sharedApplication].delegate.window.rootViewController];
}

+ (UIViewController *)topViewControllerWithRootViewController:(UIViewController *)rootViewController {
  NSLog(@"root to top vc:%@", NSStringFromClass([rootViewController class]));
  if ([rootViewController isKindOfClass:[MMDrawerController class]]) {
    MMDrawerController *mmdVc = (MMDrawerController *)rootViewController;
    return [self topViewControllerWithRootViewController:mmdVc.centerViewController];
  } else if ([rootViewController isKindOfClass:[UITabBarController class]]) {
    UITabBarController *tabBarController = (UITabBarController *)rootViewController;
    return [self topViewControllerWithRootViewController:tabBarController.selectedViewController];
  } else if ([rootViewController isKindOfClass:[UINavigationController class]]) {
    UINavigationController *navigationController = (UINavigationController *)rootViewController;
    return [self topViewControllerWithRootViewController:navigationController.visibleViewController];
  } else if (rootViewController.presentedViewController) {
    UIViewController *presentedViewController = rootViewController.presentedViewController;
    return [self topViewControllerWithRootViewController:presentedViewController];
  } else {
    return rootViewController;
  }
}
</code></pre>

<h2>Create Groups vs Create Folder References</h2>

<p>Group：不创建文件夹，不能同名； <br/>
Folder：创建文件夹，可以重名；</p>

<h2>拉伸Image</h2>

<p>代码：<code>- (UIImage *)resizableImageWithCapInsets:(UIEdgeInsets)capInsets resizingMode:(UIImageResizingMode)resizingMode NS_AVAILABLE_IOS(6_0);</code><br/>
设置：Assets -> Attributes Inspector -> Slicing</p>

<h2>隐藏文件</h2>

<p>显示隐藏文件：<code>defaults write com.apple.finder AppleShowAllFiles -bool true</code><br/>
隐藏隐藏文件：<code>defaults write com.apple.finder AppleShowAllFiles -bool false</code>
重启finder：<code>killall Finder</code></p>

<h2>NavigationBar &amp; ScrollView</h2>

<p>自动：<code>contentOffset.y == -64</code><br/>
手动：<code>self.edgesForExtendedLayout = UIRectEdgeNone;</code>，y轴0点下移64。</p>

<h2>Objective-C static vs external</h2>

<p>static: In C and Objective-C, a static variable or function at global scope means that that symbol has internal linkage.<br/>
external: If you want to have a single global variable, you can&rsquo;t have it in class scope like in C++. One option is to create a global variable with external linkage: declare the variable with the extern keyword in a header file, and then in one source file, define it at global scope without the extern keyword.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS知识小集-170501]]></title>
    <link href="http://sxgfxm.github.io/blog/2017/05/17/ioszhi-shi-xiao-ji-170501/"/>
    <updated>2017-05-17T16:42:40+08:00</updated>
    <id>http://sxgfxm.github.io/blog/2017/05/17/ioszhi-shi-xiao-ji-170501</id>
    <content type="html"><![CDATA[<h1>ComponentKit Tutorial - CollectionView</h1>

<h2>Install</h2>

<p>通过 <strong>Carthage</strong> 安装，在 <strong>Cartfile</strong> 中添加<code>github "facebook/ComponentKit" ~&gt; 0.20</code>，然后运行<code>carthage update</code>，编译完成后，在 <strong>Embedded Binaries</strong> 添加<code>Carthage/Build/iOS/ComponentKit.framework</code>。所有需要使用ComponentKit的源文件需要修改后缀为 <strong>.mm</strong>。</p>

<h2>Philosophy</h2>

<p>Doing so this reverses the traditional approach for a <code>UICollectionViewDataSource</code>. Usually the controller layer will <strong>tell</strong> the <code>UICollectionView</code> to update and then the <code>UICollectionView</code> <strong>ask</strong> the datasource for the data. Here the model is  more Reactive, from an external prospective, the datasource is <strong>told</strong> what changes to apply and then <strong>tell</strong> the collection view to apply the corresponding changes.</p>

<!-- more -->


<h2>步骤</h2>

<h3>CKComponentProvider Protocol</h3>

<p>ViewController需要遵守<code>CKComponentProvider</code>协议，实现<code>+componentForModel: context:</code>方法，将model转换为component。<br/>
在该方法中，通过不同类型的model返回不同类型的component。</p>

<pre><code>+ (CKComponent *)componentForModel:(id&lt;NSObject&gt;)model
                           context:(id&lt;NSObject&gt;)context {
  if ([model isKindOfClass:[NewsModel class]]) {
    return [NewsComponent newWithNewsModel:model context:context];
  }
  return nil;
}
</code></pre>

<h3>FlowLayout</h3>

<pre><code>UICollectionViewFlowLayout *flowLayout = [[UICollectionViewFlowLayout alloc] init];
[flowLayout setScrollDirection:UICollectionViewScrollDirectionVertical];
[flowLayout setMinimumInteritemSpacing:0];
[flowLayout setMinimumLineSpacing:0];
</code></pre>

<h3>CollectionView</h3>

<pre><code>self.collectionView = [[UICollectionView alloc] initWithFrame:self.view.bounds collectionViewLayout:flowLayout];
self.collectionView.delegate = self;
self.collectionView.backgroundColor = [UIColor blackColor];
[self.view addSubview:self.collectionView];
</code></pre>

<h3>Item size range</h3>

<p>Item size range。通过设置<code>CKComponentSizeRangeFlexibleHeight</code>使item的高度自适应。</p>

<pre><code>const CKSizeRange sizeRange = [[CKComponentFlexibleSizeRangeProvider
      providerWithFlexibility:CKComponentSizeRangeFlexibleHeight]
     sizeRangeForBoundingSize:self.collectionView.bounds.size];
</code></pre>

<h3>Context</h3>

<p>Context可以是任何不可变对象，创建component时的不可变上下文信息，比如设备类型，图片下载器。<br/>
<code>MyContext *context = [MyContext new];</code><br/>
预先在主线程加载图片。</p>

<h3>Configuration</h3>

<p>DataSource的configuration，需要 <strong>ComponentProvider</strong>，<strong>sizeRange</strong>，<strong>context</strong> 三个参数。</p>

<pre><code>CKTransactionalComponentDataSourceConfiguration *configuration =
      [[CKTransactionalComponentDataSourceConfiguration alloc]
          initWithComponentProvider:[self class]
                            context:context
                          sizeRange:sizeRange];
</code></pre>

<h3>DataSource</h3>

<p>需要 <strong>collectionView</strong>，<strong>supplementaryViewDataSource</strong>，<strong>configuration</strong> 三个参数。</p>

<pre><code>self.dataSource = [[CKCollectionViewTransactionalDataSource alloc]
           initWithCollectionView:self.collectionView
      supplementaryViewDataSource:nil
                    configuration:configuration];
</code></pre>

<h3>Initial Changeset</h3>

<p>需要初始化DataSource，即向DataSource中添加Section。</p>

<pre><code>CKTransactionalComponentDataSourceChangeset *initialChangeset =
  [[[CKTransactionalComponentDataSourceChangesetBuilder
      transactionalComponentDataSourceChangeset]
      withInsertedSections:[NSIndexSet indexSetWithIndex:0]] build];
[self.dataSource applyChangeset:initialChangeset
                           mode:CKUpdateModeAsynchronous
                       userInfo:nil];
</code></pre>

<h3>insert/update items</h3>

<p>向DataSource中插入Items才能显示。</p>

<pre><code>NSMutableDictionary&lt;NSIndexPath *, NewsModel *&gt; *items = [NSMutableDictionary new];
for (NSInteger i = 0; i &lt; 50; i++) {
  NewsModel *newsModel = [[NewsModel alloc] init];
  newsModel.title = [NSString stringWithFormat:@"News Title: Title %ld", i];
  newsModel.category = @"科技";
  newsModel.updateTime = [NSDate date];
  newsModel.source = @"网易新闻";
  [items setObject:newsModel
            forKey:[NSIndexPath indexPathForRow:i inSection:0]];
}
CKTransactionalComponentDataSourceChangeset *changeset =
  [[[CKTransactionalComponentDataSourceChangesetBuilder
      transactionalComponentDataSourceChangeset]
      withInsertedItems:items] build];
[self.dataSource applyChangeset:changeset
                           mode:CKUpdateModeAsynchronous
                       userInfo:nil];
</code></pre>

<h3>UICollectionView delegate</h3>

<pre><code>- (CGSize)collectionView:(UICollectionView *)collectionView
                  layout:(UICollectionViewLayout *)collectionViewLayout
  sizeForItemAtIndexPath:(NSIndexPath *)indexPath {
  return [self.dataSource sizeForItemAtIndexPath:indexPath];
}

- (void)collectionView:(UICollectionView *)collectionView
       willDisplayCell:(UICollectionViewCell *)cell
    forItemAtIndexPath:(NSIndexPath *)indexPath {
  [self.dataSource announceWillDisplayCell:cell];
}

- (void)collectionView:(UICollectionView *)collectionView
  didEndDisplayingCell:(UICollectionViewCell *)cell
    forItemAtIndexPath:(NSIndexPath *)indexPath {
  [self.dataSource announceDidEndDisplayingCell:cell];
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS知识小集-170424]]></title>
    <link href="http://sxgfxm.github.io/blog/2017/05/17/ioszhi-shi-xiao-ji-170424/"/>
    <updated>2017-05-17T16:38:39+08:00</updated>
    <id>http://sxgfxm.github.io/blog/2017/05/17/ioszhi-shi-xiao-ji-170424</id>
    <content type="html"><![CDATA[<h1>ComponentKit Tutorial - Layout</h1>

<h2>Flexbox Layout</h2>

<p><strong>flex container</strong>：容器。<br/>
main axis：main start， main end。<br/>
cross axis：cross start， cross end。<br/>
<strong>flex item</strong>：成员。<br/>
main size。<br/>
cross size。</p>

<!-- more -->


<h2>Container Properties</h2>

<p>flex-direction：决定主轴方向。</p>

<pre><code>typedef NS_ENUM(NSUInteger, CKStackLayoutDirection) {
  //  垂直方向
  CKStackLayoutDirectionVertical,
  //  水平方向
  CKStackLayoutDirectionHorizontal,
};
</code></pre>

<p>flex-wrap：决定如何换行。<br/>
flex-flow：flex-direction和flex-wrap的简写形式。<br/>
<strong>justify-content</strong>：决定items在主轴上的对齐方式。</p>

<pre><code>/** If no children are flexible, how should this component justify its children in the available space? */
typedef NS_ENUM(NSUInteger, CKStackLayoutJustifyContent) {
  /**
   On overflow, children overflow out of this component's bounds on the right/bottom side.
   On underflow, children are left/top-aligned within this component's bounds.
   */
  //  左对齐
  CKStackLayoutJustifyContentStart,
  /**
   On overflow, children are centered and overflow on both sides.
   On underflow, children are centered within this component's bounds in the stacking direction.
   */
  //  居中
  CKStackLayoutJustifyContentCenter,
  /**
   On overflow, children overflow out of this component's bounds on the left/top side.
   On underflow, children are right/bottom-aligned within this component's bounds.
   */
  //  右对齐
  CKStackLayoutJustifyContentEnd,
};
</code></pre>

<p><strong>align-items</strong>：决定items在交叉轴上的对齐方式。</p>

<pre><code>typedef NS_ENUM(NSUInteger, CKStackLayoutAlignItems) {
  /** Align children to start of cross axis */
  //  交叉轴起点对齐
  CKStackLayoutAlignItemsStart,
  /** Align children with end of cross axis */
  CKStackLayoutAlignItemsEnd,
  //  交叉轴终点对齐
  /** Center children on cross axis */
  //  交叉轴居中对齐
  CKStackLayoutAlignItemsCenter,
  /** Expand children to fill cross axis */
  //  交叉轴方向拉伸
  CKStackLayoutAlignItemsStretch,
};
</code></pre>

<h2>Item Properties</h2>

<p>order：决定item排列顺序，数值越小，排位越靠前。<br/>
<strong>flex-grow</strong>：决定item主轴方向的放大比例，默认为0，即如果存在剩余空间，也不放大。<br/>
如果所有项目的flex-grow属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的flex-grow属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。<br/>
<strong>flex-shrink</strong>：决定item主轴方向的缩小比例，默认为1，即如果空间不足，该item将缩小。<br/>
如果所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小。如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小。<br/>
<strong>flex-basis</strong>：决定了在分配多余空间之前，item的main size大小，根据该值计算主轴是否有多余空间。<br/>
flex：flex-grow, flex-shrink 和 flex-basis的简写。<br/>
<strong>align-self</strong>：决定item单独的对齐方式，可以覆盖 <strong>align-items</strong> 属性。<br/>
默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。</p>

<pre><code>/**
 Each child may override their parent stack's cross axis alignment.
 @see CKStackLayoutAlignItems
 */
typedef NS_ENUM(NSUInteger, CKStackLayoutAlignSelf) {
  /** Inherit alignment value from containing stack. */
  CKStackLayoutAlignSelfAuto,
  CKStackLayoutAlignSelfStart,
  CKStackLayoutAlignSelfEnd,
  CKStackLayoutAlignSelfCenter,
  CKStackLayoutAlignSelfStretch,
};
</code></pre>

<h2>CKStackLayoutComponent</h2>

<p>A simple layout component that stacks a list of children vertically or horizontally.<br/>
动态创建children：</p>

<pre><code>static std::vector&lt;CKStackLayoutComponentChild&gt; createChildren(NSArray* list){
  std::vector&lt;CKStackLayoutComponentChild&gt; children;
  for (VPANewsModel*newsModel in list) {
    children.push_back({[VPANewsComponent newWithNewsModel:newsModel]});
  }
  return children;
}
</code></pre>

<h2>CKBackgroundLayoutComponent</h2>

<p>Lays out a single child component, then lays out a background component behind it stretched to its size.</p>

<pre><code>+ (instancetype)newWithComponent:(CKComponent *)component
                      background:(CKComponent *)background;
</code></pre>

<h2>CKStaticLayoutComponent</h2>

<p>A component that positions children at fixed positions.<br/>
Computes a size that is the union of all childrens' frames.</p>

<h2>CKCenterLayoutComponent</h2>

<p>Lays out a single child component and position it so that it is centered into the layout bounds.</p>

<pre><code>+ (instancetype)newWithCenteringOptions:(CKCenterLayoutComponentCenteringOptions)centeringOptions
                          sizingOptions:(CKCenterLayoutComponentSizingOptions)sizingOptions
                                  child:(CKComponent *)child
                                   size:(const CKComponentSize &amp;)size;
</code></pre>

<h2>CKRatioLayoutComponent</h2>

<p>For when the content should respect a certain inherent ratio but can be scaled (think photos or videos).
The ratio passed is the ratio of height / width you expect.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS知识小集-170417]]></title>
    <link href="http://sxgfxm.github.io/blog/2017/05/17/ioszhi-shi-xiao-ji-170417/"/>
    <updated>2017-05-17T16:33:08+08:00</updated>
    <id>http://sxgfxm.github.io/blog/2017/05/17/ioszhi-shi-xiao-ji-170417</id>
    <content type="html"><![CDATA[<h1>ComponentKit Tutorial - Component</h1>

<h2>CKComponent</h2>

<p>A component is an immutable object that specifies how to configure a view, loosely inspired by React.</p>

<pre><code>+ (instancetype)newWithView:(const CKComponentViewConfiguration &amp;)view
                       size:(const CKComponentSize &amp;)size;
</code></pre>

<p>Example:</p>

<pre><code>CKComponent *component = [CKComponent
    newWithView:{
        [UIView class],
        {
            {@selector(setBackgroundColor:),[UIColor redColor]},
            {@selector(setUserInteractionEnabled:), @YES},
            {CKComponentTapGestureAttribute(@selector(didTap))},
            {CKComponentViewAttribute::LayerAttribute(@selector(setCornerRadius:)), @10.0}
        }
    }
    size:{50,50}];

- (void)didTap{
  [self updateState:^(NSNumber *oldState){
    return [oldState boolValue] ? @NO : @YES;
  } mode:CKUpdateModeSynchronous];
}
</code></pre>

<!-- more -->


<h2>CKLabelComponent</h2>

<p>多行文字通过size.width控制。</p>

<pre><code>CKLabelComponent *titleComponent = [CKLabelComponent newWithLabelAttributes:{
    .string = newsModel.title,
    .color = [UIColor whiteColor],
    .alignment = NSTextAlignmentLeft,
    .font = [UIFont systemFontOfSize:20]
  }
  viewAttributes:{
    { @selector(setBackgroundColor:), [UIColor clearColor] }
  }
  size:{}];
</code></pre>

<h2>CKButtonComponent</h2>

<pre><code> CKButtonComponent *buttonComponent = [CKButtonComponent
    newWithTitles:{
      {UIControlStateNormal,@"button"}
    }
    titleColors:{
      {UIControlStateNormal,[UIColor whiteColor]}
    }
    images:{}
    backgroundImages:{}
    titleFont:[UIFont systemFontOfSize:17]
    selected:NO
    enabled:YES
    action:{@selector(tapAction)}
    size:{}
    attributes:{}
    accessibilityConfiguration:{}];
</code></pre>

<h2>CKImageComponent</h2>

<pre><code>CKImageComponent *image = [CKImageComponent newWithImage:
    [UIImage imageNamed:newsModel.imageURL]
    attributes:{
        { @selector(setBackgroundColor:), [UIColor whiteColor] },
        {CKComponentViewAttribute::LayerAttribute(@selector(setCornerRadius:)), @10.0}
    }
    size:{60, 60}];
</code></pre>

<h2>CKInsetComponent</h2>

<p>A component that wraps another component, applying insets around it.</p>

<pre><code>+ (instancetype)newWithView:(const CKComponentViewConfiguration &amp;)view
                     insets:(UIEdgeInsets)insets
                  component:(CKComponent *)component;

+ (instancetype)newWithInsets:(UIEdgeInsets)insets component:(CKComponent *)child;
</code></pre>

<p>Example:</p>

<pre><code>CKInsetComponent *insetComponent = [CKInsetComponent
    newWithInsets:{.top = 10,.left = 20,.right = 10,.bottom = 20}
    component:[CKComponent
        newWithView:{}
        size:{}]
    ];
</code></pre>

<h2>CKOverlayLayoutComponent</h2>

<p>This component lays out a single component and then overlays a component on top of it streched to its size.</p>

<pre><code>+ (instancetype)newWithComponent:(CKComponent *)component
                         overlay:(CKComponent *)overlay;
</code></pre>

<h2>State</h2>

<p>Simply ask three questions about each piece of data:<br/>
1. Is it passed in from a parent via props? If so, it probably isn&rsquo;t state.<br/>
2. Does it remain unchanged over time? If so, it probably isn&rsquo;t state.<br/>
3. Can you compute it based on any other state or props in your component? If so, it isn&rsquo;t state.</p>

<p>For each piece of state in your application:<br/>
1. Identify every component that renders something based on that state.<br/>
2. Find a common owner component (a single component above all the components that need the state in the hierarchy).<br/>
3. Either the common owner or another component higher up in the hierarchy should own the state.<br/>
4. If you can&rsquo;t find a component where it makes sense to own the state, create a new component simply for holding the state and add it somewhere in the hierarchy above the common owner component.</p>

<h2>Scope</h2>

<ol>
<li>Components that have state must have a scope.</li>
<li>Components that have a controller must have a scope.</li>
<li>Components that have child components with state or controllers may need a scope, even if they don’t have state or controllers.</li>
</ol>


<h2>ComponentController</h2>

<p>与component写在同一个文件里，系统自动创建。<br/>
用来处理代理、事件响应等，有持续的生命周期。<br/>
scope必须唯一，与controller一一对应。</p>
]]></content>
  </entry>
  
</feed>

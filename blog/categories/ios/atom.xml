<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Ios | Light's Blog]]></title>
  <link href="http://sxgfxm.github.io/blog/categories/ios/atom.xml" rel="self"/>
  <link href="http://sxgfxm.github.io/"/>
  <updated>2017-04-05T09:12:09+08:00</updated>
  <id>http://sxgfxm.github.io/</id>
  <author>
    <name><![CDATA[Light]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[iOS知识小集-170327]]></title>
    <link href="http://sxgfxm.github.io/blog/2017/04/05/ioszhi-shi-xiao-ji-170403/"/>
    <updated>2017-04-05T09:07:16+08:00</updated>
    <id>http://sxgfxm.github.io/blog/2017/04/05/ioszhi-shi-xiao-ji-170403</id>
    <content type="html"><![CDATA[<h2>转换</h2>

<p>NSURL -> NSString：<code>NSString *path = [url path];</code><br/>
NSString -> NSURL：<code>NSURL *url = [NSURL fileURLWithPath:path];</code> <br/>
UIImage -> NSData：<code>NSData *data = UIImagePNGRepresentation(image);</code><br/>
NSData -> UIImage：<code>UIImage *image = [UIImage imageWithData:data];</code></p>

<!-- more -->


<h2>向歌曲中写入metadata信息</h2>

<p>导入第三方库<a href="https://github.com/larsbs/id3v2lib">id3v2lib</a>。</p>

<pre><code>  //  文件路径
  const char *cPath = [[url path] cStringUsingEncoding:NSUTF8StringEncoding];
  //  创建tag
  ID3v2_tag *tag = load_tag(cPath);
  if (tag == NULL) {
    tag = new_tag();
  }
  //  设置tag
  char *title = (char *)[item.title cStringUsingEncoding:NSUTF8StringEncoding];
  tag_set_title(title, 0, tag);
  char *artist = (char *)[item.artist cStringUsingEncoding:NSUTF8StringEncoding];
  tag_set_artist(artist, 0, tag);
  UIImage *image = [item.artwork imageWithSize:CGSizeMake(400, 400)];
  NSData *data = UIImagePNGRepresentation(image);
  NSString *coverPath = [[NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES) firstObject]
      stringByAppendingPathComponent:[NSString stringWithFormat:@"%@.png", item.title]];
  [[NSFileManager defaultManager] removeItemAtPath:coverPath error:nil];
  [[NSFileManager defaultManager] createFileAtPath:coverPath contents:data attributes:nil];
  tag_set_album_cover([coverPath cStringUsingEncoding:NSUTF8StringEncoding], tag);
  [[NSFileManager defaultManager] removeItemAtPath:coverPath error:nil];
  //  写入tag
  set_tag(cPath, tag);
</code></pre>

<h2>MPMediaItem</h2>

<p>isCloudItem：是否为云端文件；<br/>
hasProtectedAsset：是否含有被保护文件；<br/>
以上两个原因可能导致assertURL为nil。</p>

<h2>NSOperation内存泄露</h2>

<p>operation.completionBlock会引起循环引用。<br/>
在block中创建对象注意生命周期。</p>

<h2>GCDWebServer监听传输状态</h2>

<p>继承<code>GCDWebServerConnection</code>，重写<code>- (void)didWriteBytes:(const void *)bytes length:(NSUInteger)length</code>方法，以通知的形式传递值。</p>

<h2>c string in OC</h2>

<p><code>char *cString = (char *)[string cStringUsingEncoding:NSUTF8StringEncoding]</code>，
无需手动释放，当receiver被释放或者内存不足时，会自动释放cString。</p>

<h2>WiFi ap隔离</h2>

<h2>观察者模式</h2>

<h2>工厂模式</h2>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS知识小集-170320]]></title>
    <link href="http://sxgfxm.github.io/blog/2017/03/27/ioszhi-shi-xiao-ji-170320/"/>
    <updated>2017-03-27T09:58:51+08:00</updated>
    <id>http://sxgfxm.github.io/blog/2017/03/27/ioszhi-shi-xiao-ji-170320</id>
    <content type="html"><![CDATA[<h2>iOS系统分享</h2>

<p>需增加版本判断：<code>UIActivityTypeOpenInIBooks</code>iOS 9.0之后才有。</p>

<h2>iOS导出音乐</h2>

<p>如何导出mp3：先按mov格式导出，再转为mp3。<br/>
如何包含metadata信息：m4a格式自动包含metadata信息，mp3无。<br/>
路径去除特殊字符。</p>

<!-- more -->


<h2>GCDWebserver后台运行</h2>

<p>设置option</p>

<pre><code>- (BOOL)startServer {
  for (int i = 0; i &lt; 10; i++) {
    //  随机端口号
    NSInteger port = arc4random_uniform(64510) + 1025;
    NSDictionary *options = @{
      GCDWebServerOption_ConnectedStateCoalescingInterval : @(20),
      GCDWebServerOption_Port : @(port)
    };
    NSError *error = nil;
    if ([self.webServer startWithOptions:options error:&amp;error]) {
      DDLogDebug(@"Start local server: %@", self.webServer.serverURL);
      return YES;
    }
  }
  return NO;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS知识小集-170313]]></title>
    <link href="http://sxgfxm.github.io/blog/2017/03/20/ioszhi-shi-xiao-ji-170313/"/>
    <updated>2017-03-20T16:50:46+08:00</updated>
    <id>http://sxgfxm.github.io/blog/2017/03/20/ioszhi-shi-xiao-ji-170313</id>
    <content type="html"><![CDATA[<h2>Masonry</h2>

<p>需要先添加到父视图，再设置约束。<br/>
block中无需使用weakself。<br/>
添加约束：makeConstrains。<br/>
更新约束：updateConstrains，与之相关的布局自动调整。<br/>
重设约束：remakeConstrains，删除之前的约束重新添加。</p>

<pre><code>[self.view updateConstraints:^(MASConstraintMaker *make){
  //  updateConstraints
}];
[self.view updateConstraints];
[self.view setNeedsLayout];
[UIView animateWithDuration:3 animations:^{
  [self.view layoutIfNeeded];
}];
</code></pre>

<!-- more -->


<h2>Autolayout</h2>

<p><code>setNeedsLayout</code>：使当前布局失效，并在下一个更新循环中触发布局更新，遍历view的结构。<br/>
<code>layoutIfNeeded</code>：强制立即更新布局，可以实现动画效果。<br/>
scrollview自动布局：添加tmpview，在tmpview上添加view，最后约束tmpview和contentsize。</p>

<h2>退出viewcontroller事件监听</h2>

<h2>IQActionSheetPickerView</h2>

<pre><code>IQActionSheetPickerView *picker = [IQActionSheetPickerView actionSheetWithTitle:@"Age" delegate:self];
NSArray *dataSource = @[@"10",@"20",@"30",@"40",@"50",@"60"];
[picker setTitlesForComponents:@[dataSource]];
[picker setSelectedTitles:@[@"20"]];
[picker show];
</code></pre>

<p>代理回调</p>

<pre><code>- (void)actionSheetPickerView:(IQActionSheetPickerView *)pickerView didSelectTitles:(NSArray *)titles {
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS知识小集-170306]]></title>
    <link href="http://sxgfxm.github.io/blog/2017/03/10/ioszhi-shi-xiao-ji-170306/"/>
    <updated>2017-03-10T17:00:41+08:00</updated>
    <id>http://sxgfxm.github.io/blog/2017/03/10/ioszhi-shi-xiao-ji-170306</id>
    <content type="html"><![CDATA[<h2>异步回调</h2>

<ol>
<li>明确知道操作执行完成；</li>
<li>操作时间未知；</li>
</ol>


<!-- more -->


<h2>Block</h2>

<ol>
<li>对block中的内容强引用；</li>
<li>循环引用，类A的强property类B的强property block强引用self；</li>
<li>单例不用管循环引用；</li>
</ol>


<h2>内存划分</h2>

<ol>
<li>全局区；</li>
<li>静态区；</li>
<li>堆区；</li>
<li>栈区；</li>
</ol>


<h2>单例</h2>

<ol>
<li>如何创建单例？</li>
<li>何时创建单例？</li>
<li>单例的特性？</li>
</ol>


<h2>NSOperation</h2>

<pre><code>-(void)start;
-(void)main;
-(void)cancel;
-(void)addDependency:(NSOperation*)op;
-(void)removeDependency:(NSOperation*)op;
@property BOOL executing;
@property BOOL cancelled;
@property BOOL finished;
@property copy void (^completionBlock)(void);
</code></pre>

<p>使用方法：<br/>
1、继承NSOperation，通过init方法初始化，重写main方法执行任务；<br/>
2、可以通过completionBlock设置执行完成回调；<br/>
3、可以方便的判断任务执行状态，取消任务等；<br/>
4、可以添加和删除依赖关系，依赖其他operation的执行；<br/>
5、可以通过NSCondition阻塞，加锁，生产者-消费者；</p>

<h2>NSOperationQueue</h2>

<pre><code>@property NSInteger maxCoucurrentOperationCount;
@property NSInteger operationCount;
-(void)addOperation:(NSOperation*)op;
-(void)cancelAllOperations;
-(void)waitUntilAllOperationsAreFinished;
</code></pre>

<p>使用方法：<br/>
1、初始化NSOperationQueue，设置同时可并行任务数量；<br/>
2、创建任务，并将其加入队列中，任务自动开始执行；<br/>
3、可以通过operationCount判断还有多少任务未执行；</p>

<h2>HealthKit</h2>

<p>功能：存放健康数据，自动合并；<br/>
读：读某一类别健康数据；<br/>
写：写某一类别健康数据；<br/>
改：改自己写的健康数据。<br/>
锁屏时无法读数据，保护用户数据安全。</p>

<h2>UIPasteboard</h2>

<p>将信息写到剪切板中。</p>

<pre><code>UIPasteboard *pasteboard = [UIPasteboard generalPasteboard];
[pasteboard setString:string];
</code></pre>

<h2>发送本地通知</h2>

<pre><code>// 创建一个本地推送
UILocalNotification *notification = [UILocalNotification new];
if (notification != nil) {
  // 推送声音
  notification.soundName = UILocalNotificationDefaultSoundName;
  // 推送内容
  notification.alertBody = NSLocalizedString(@"stopWatch.timing", @"已将打点计时信息复制到剪切板");
  // 显示在icon上的红色圈中的数子
  notification.applicationIconBadgeNumber++;
  // 设置userinfo 方便在之后需要撤销的时候使用
  NSDictionary *info = [NSDictionary dictionaryWithObject:kStopWatchKey forKey:kNotificationKey];
  notification.userInfo = info;
  // 添加推送到UIApplication
  UIApplication *app = [UIApplication sharedApplication];
  [app scheduleLocalNotification:notification];
}
</code></pre>

<h2>string label</h2>

<pre><code>NSStringDrawingUsesLineFragmentOrigin | NSStringDrawingUsesFontLeading
ceil()
</code></pre>

<h2>相册和相机</h2>

<p>取消选择照片和选择没有照片是不同的回调。<br/>
相片可以编辑，相机不可以编辑。</p>

<h2>类方法、类变量、单例</h2>

<h2>埋点</h2>

<p>点击量；<br/>
人次；<br/>
存留；<br/>
停留时间；</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS知识小集-170227]]></title>
    <link href="http://sxgfxm.github.io/blog/2017/03/06/ioszhi-shi-xiao-ji-170227/"/>
    <updated>2017-03-06T16:15:46+08:00</updated>
    <id>http://sxgfxm.github.io/blog/2017/03/06/ioszhi-shi-xiao-ji-170227</id>
    <content type="html"><![CDATA[<h2>OC中的锁</h2>

<pre><code>@implementation TestObj

-(void)method1{
  NSLog(@"Method1");
}
-(void)method2{
  NSLog(@"Method2");
}

@end
</code></pre>

<!--more-->


<h3>NSLock</h3>

<pre><code>NSLock *lock = [[NSLock alloc] init];
//线程1
dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
    [lock lock];
    [obj method1];
    sleep(10);
    [lock unlock];
});
//线程2
dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
    sleep(1);//以保证让线程2的代码后执行
    [lock lock];
    [obj method2];
    [lock unlock];
});
</code></pre>

<h3>synchronized关键字。</h3>

<pre><code>//主线程中
TestObj *obj = [[TestObj alloc] init];
//线程1
dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
    @synchronized(obj){
        [obj method1];
        sleep(10);
    }
});
//线程2
dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
    sleep(1);
    @synchronized(obj){
        [obj method2];
    }
});
</code></pre>

<h3>phread_mutex_t。</h3>

<pre><code>//主线程中
TestObj *obj = [[TestObj alloc] init];
__block pthread_mutex_t mutex;
pthread_mutex_init(&amp;mutex, NULL);
//线程1
dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
    pthread_mutex_lock(&amp;mutex);
    [obj method1];
    sleep(5);
    pthread_mutex_unlock(&amp;mutex);
});
//线程2
dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
    sleep(1);
    pthread_mutex_lock(&amp;mutex);
    [obj method2];
    pthread_mutex_unlock(&amp;mutex);
});
</code></pre>

<h3>GCD。</h3>

<pre><code>//主线程中
TestObj *obj = [[TestObj alloc] init];
dispatch_semaphore_t semaphore = dispatch_semaphore_create(1);
//线程1
dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
    dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);
    [obj method1];
    sleep(10);
    dispatch_semaphore_signal(semaphore);
});
//线程2
dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
    sleep(1);
    dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);
    [obj method2];
    dispatch_semaphore_signal(semaphore);
});
</code></pre>

<h2>生成圆形透明背景图片</h2>

<pre><code>+ (UIImage *)circularScaleAndCropImage:(UIImage *)image {
  // Create the bitmap graphics context
  UIGraphicsBeginImageContextWithOptions(CGSizeMake(image.size.width, image.size.height), NO, 0.0);
  CGContextRef context = UIGraphicsGetCurrentContext();

  // Get the width and heights
  CGFloat imageWidth = image.size.width;
  CGFloat imageHeight = image.size.height;

  // Calculate the centre of the circle
  CGFloat imageCentreX = imageWidth / 2;
  CGFloat imageCentreY = imageHeight / 2;

  // Create and CLIP to a CIRCULAR Path
  CGFloat radius = imageWidth / 2;
  CGContextBeginPath(context);
  CGContextAddArc(context, imageCentreX, imageCentreY, radius, 0, 2 * M_PI, 0);
  CGContextClosePath(context);
  CGContextClip(context);

  // Draw the IMAGE
  CGRect myRect = CGRectMake(0, 0, imageWidth, imageHeight);
  [image drawInRect:myRect];

  UIImage *newImage = UIGraphicsGetImageFromCurrentImageContext();
  UIGraphicsEndImageContext();

  return newImage;
}
</code></pre>

<h2>RxJava</h2>

<p>响应式函数编程<br/>
订阅的思想<br/>
多层异步回调逻辑更清晰</p>

<h2>Socket</h2>

<p><strong>Packet-based communication</strong><br/>
<strong>Stream-based clients </strong></p>
]]></content>
  </entry>
  
</feed>

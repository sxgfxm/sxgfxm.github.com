<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Ios | Light's Blog]]></title>
  <link href="http://sxgfxm.github.io/blog/categories/ios/atom.xml" rel="self"/>
  <link href="http://sxgfxm.github.io/"/>
  <updated>2018-03-12T15:27:41+08:00</updated>
  <id>http://sxgfxm.github.io/</id>
  <author>
    <name><![CDATA[Light]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[iOS知识小集-171211]]></title>
    <link href="http://sxgfxm.github.io/blog/2018/03/12/ioszhi-shi-xiao-ji-171211/"/>
    <updated>2018-03-12T15:26:20+08:00</updated>
    <id>http://sxgfxm.github.io/blog/2018/03/12/ioszhi-shi-xiao-ji-171211</id>
    <content type="html"><![CDATA[<h2>layoutIfNeeded</h2>

<p>布局其子视图。</p>

<h2>UIViewContentModeScaleAspectFill</h2>

<p>需要设置<code>clipsToBounds</code>为<code>YES</code>，否则图片显示可能会溢出。</p>

<h2>UITableView Edit Cell</h2>

<h2>UITableView Move Cell</h2>

<h2>数据与界面同步</h2>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS知识小集-171204]]></title>
    <link href="http://sxgfxm.github.io/blog/2017/12/11/ioszhi-shi-xiao-ji-171204/"/>
    <updated>2017-12-11T16:49:04+08:00</updated>
    <id>http://sxgfxm.github.io/blog/2017/12/11/ioszhi-shi-xiao-ji-171204</id>
    <content type="html"><![CDATA[<h2>UIViewController Transition</h2>

<p>自定义Present和Dismiss动画。</p>

<!-- more -->


<h3>设置待Present的UIViewController的transitioningDelegate</h3>

<p><code>modalPresentationStyle</code>为<code>FullScreen</code>时，dismiss时会自动移除<code>fromView</code>。<br/>
<code>modalPresentationStyle</code>为<code>Custom</code>时，dismiss时会需手动移除<code>fromView</code>。</p>

<pre><code class="objective-c">@interface ViewController : UIViewController &lt;UIViewControllerTransitioningDelegate&gt;

@end

@implementation ViewController

- (instancetype)init{
  if (self = [super init]) {
    self.modalPresentationStyle = UIModalPresentationOverFullScreen;
    self.transitioningDelegate = self;
  }
  return self;
}

#pragma mark - UIViewControllerTransitioningDelegate
- (id&lt;UIViewControllerAnimatedTransitioning&gt;)animationControllerForPresentedController:(UIViewController *)presented
                                                                  presentingController:(UIViewController *)presenting
                                                                      sourceController:(UIViewController *)source {
  return [PresentAnimator new];
}

- (id&lt;UIViewControllerAnimatedTransitioning&gt;)animationControllerForDismissedController:(UIViewController *)dismissed{
  return [DismissAnimator new];
}

@end
</code></pre>

<h3>创建PresentAnimator</h3>

<pre><code class="objective-c">@interface PresentAnimator : NSObject &lt;UIViewControllerAnimatedTransitioning&gt;

@end

@implementation PresentAnimator

#pragma mark - UIViewControllerContextTransitioning
- (void)animateTransition:(nonnull id&lt;UIViewControllerContextTransitioning&gt;)transitionContext {
  //  from -&gt; to
  UIViewController *fromViewController = [transitionContext viewControllerForKey:UITransitionContextFromViewControllerKey];
  UIViewController *toViewController = [transitionContext viewControllerForKey:UITransitionContextToViewControllerKey];
  //  contrainer
  UIView *containerView = transitionContext.containerView;
  //  from -&gt; to
  UIView *fromView = [transitionContext viewForKey:UITransitionContextFromViewKey];
  UIView *toView = [transitionContext viewForKey:UITransitionContextToViewKey];
  //  add
  [containerView addSubview:toView];
  //  animation
  toView.alpha = 0;
  toView.frame = CGRectMake(fromView.frame.origin.x, CGRectGetMaxY(fromView.frame) / 2, fromView.frame.size.width, fromView.frame.size.height);
  [UIView animateWithDuration:[self transitionDuration:transitionContext] animations:^{
    toView.alpha = 1;
    toView.frame = [transitionContext finalFrameForViewController:toViewController];
  } completion:^(BOOL finished) {
    [transitionContext completeTransition:![transitionContext transitionWasCancelled]];
  }];
}

- (NSTimeInterval)transitionDuration:(nullable id&lt;UIViewControllerContextTransitioning&gt;)transitionContext {
  return 0.25;
}

@end
</code></pre>

<h3>创建DismissAnimator</h3>

<pre><code class="objective-c">@interface DismissAnimator : NSObject &lt;UIViewControllerAnimatedTransitioning&gt;

@end

@implementation DismissAnimator

#pragma mark - UIViewControllerContextTransitioning
- (void)animateTransition:(nonnull id&lt;UIViewControllerContextTransitioning&gt;)transitionContext {
  //  from -&gt; to
  UIView *fromView = [transitionContext viewForKey:UITransitionContextFromViewKey];
  //  animation
  fromView.alpha = 1;
  [UIView animateWithDuration:[self transitionDuration:transitionContext] animations:^{
    fromView.alpha = 0;
  } completion:^(BOOL finished) {
    [transitionContext completeTransition:![transitionContext transitionWasCancelled]];
  }];
}

- (NSTimeInterval)transitionDuration:(nullable id&lt;UIViewControllerContextTransitioning&gt;)transitionContext {
  return 0.25;
}

@end
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS知识小集-171127]]></title>
    <link href="http://sxgfxm.github.io/blog/2017/12/02/ioszhi-shi-xiao-ji-171127/"/>
    <updated>2017-12-02T18:08:07+08:00</updated>
    <id>http://sxgfxm.github.io/blog/2017/12/02/ioszhi-shi-xiao-ji-171127</id>
    <content type="html"><![CDATA[<h2>ContentInset</h2>

<p>内容偏移，可用于下拉刷新调整界面位置。</p>

<h2>嵌套UINavigationController的UIViewController设置preferredStatusBarStyle无效</h2>

<p>如果<code>UIViewController</code>有<code>UINavigationController</code>，则会先调<code>UINavigationController</code>的<code>childViewControllerForStatusBarStyle</code>方法，该方法默认返回nil，所以子<code>UIViewController</code>设置的<code>preferredStatusBarStyle</code>无效。<br/>
解决办法，继承<code>UINavigationController</code>，并重写<code>childViewControllerForStatusBarStyle</code>方法：<br/>
<code>objective-c
- (UIViewController *)childViewControllerForStatusBarStyle{
    return self.topViewController;
}
</code></p>

<!-- more -->


<h2>Present可Push的ViewController</h2>

<p>需要在present之前用<code>UINavigationController</code>包装一下待present的<code>UIViewController</code>。</p>

<h2>UITableView insert or delete or move cell</h2>

<pre><code class="objective-c">#pragma mark - Edit
- (BOOL)tableView:(UITableView *)tableView canEditRowAtIndexPath:(NSIndexPath *)indexPath{
  return YES;
}

- (UITableViewCellEditingStyle)tableView:(UITableView *)tableView editingStyleForRowAtIndexPath:(NSIndexPath *)indexPath{
  return indexPath.section ? UITableViewCellEditingStyleInsert : UITableViewCellEditingStyleDelete;
}

- (void)tableView:(UITableView *)tableView commitEditingStyle:(UITableViewCellEditingStyle)editingStyle forRowAtIndexPath:(NSIndexPath *)indexPath{
  switch (editingStyle) {
    case UITableViewCellEditingStyleDelete:{
      NSString *item = self.selectCategoies[indexPath.row];
      [self.selectCategoies removeObject:item];
      [tableView deleteRowsAtIndexPaths:@[indexPath] withRowAnimation:UITableViewRowAnimationFade];
      [self.unselectCategoies insertObject:item atIndex:0];
      [tableView insertRowsAtIndexPaths:@[[NSIndexPath indexPathForRow:0 inSection:1]] withRowAnimation:UITableViewRowAnimationFade];
      break;
    }
    case UITableViewCellEditingStyleInsert:{
      NSString *item = self.unselectCategoies[indexPath.row];
      [self.unselectCategoies removeObject:item];
      [tableView deleteRowsAtIndexPaths:@[indexPath] withRowAnimation:UITableViewRowAnimationFade];
      [self.selectCategoies addObject:item];
      [tableView insertRowsAtIndexPaths:@[[NSIndexPath indexPathForRow:self.selectCategoies.count - 1 inSection:0]] withRowAnimation:UITableViewRowAnimationFade];
      break;
    }
    case UITableViewCellEditingStyleNone:
      break;
  }
  [self uploadCategorySetting];
}

- (NSString *)tableView:(UITableView *)tableView titleForDeleteConfirmationButtonForRowAtIndexPath:(NSIndexPath *)indexPath{
  return @"删除";
}

#pragma mark - Move
- (BOOL)tableView:(UITableView *)tableView canMoveRowAtIndexPath:(NSIndexPath *)indexPath{
  if (indexPath.section == 0) {
    return YES;
  }else{
    return NO;
  }
}

- (void)tableView:(UITableView *)tableView moveRowAtIndexPath:(NSIndexPath *)sourceIndexPath toIndexPath:(NSIndexPath *)destinationIndexPath{
  [self.selectCategoies exchangeObjectAtIndex:sourceIndexPath.row withObjectAtIndex:destinationIndexPath.row];
  [tableView exchangeSubviewAtIndex:sourceIndexPath.row withSubviewAtIndex:destinationIndexPath.row];
  [self uploadCategorySetting];
}
</code></pre>

<h2>CLLocation逆向地理编码</h2>

<p>逆向地理编码是一个异步操作，如需使用解析后的地址，需要在block回调时添加代码，而不是在<code>-locationManager:didUpdateLocations:</code>时添加代码。</p>

<pre><code>- (void)reverseGeocodeLocation:(CLLocation *)location {
  // 逆向地理编码
  CLGeocoder *geocoder = [[CLGeocoder alloc] init];
  [geocoder reverseGeocodeLocation:location
                 completionHandler:^(NSArray *placemarks, NSError *error) {
                   CLLocationCoordinate2D coordinate = location.coordinate;
                   // 中国坐标转换
                   if (![TQLocationConverter isLocationOutOfChina:coordinate]) {
                     coordinate = [TQLocationConverter transformFromWGSToGCJ:coordinate];
                     coordinate = [TQLocationConverter transformFromGCJToBaidu:coordinate];
                   }

                   if (error == nil &amp;&amp; [placemarks count] &gt; 0) {
                     CLPlacemark *placemark = [placemarks objectAtIndex:0];
                     [self.currentLocation setLocationInfoWithPlacemark:placemark
                                                               latitude:coordinate.latitude
                                                              longitude:coordinate.longitude];
                   } else {
                     DDLogInfo(@"No results were returned.");
                     [self.currentLocation setLocationInfoWithPlacemark:nil
                                                               latitude:coordinate.latitude
                                                              longitude:coordinate.longitude];
                   }

                   DDLogInfo(@"获取逆向地理编码成功 : %@", [self.currentLocation commaSeparatedAddress]);
                 }];
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS知识小集-171120]]></title>
    <link href="http://sxgfxm.github.io/blog/2017/11/27/ioszhi-shi-xiao-ji-171120/"/>
    <updated>2017-11-27T11:25:53+08:00</updated>
    <id>http://sxgfxm.github.io/blog/2017/11/27/ioszhi-shi-xiao-ji-171120</id>
    <content type="html"><![CDATA[<h2>iOS 10.3之后删除线失效解决办法</h2>

<p>iOS 10.3之前写法：</p>

<pre><code class="objective-c">[attr addAttributes:@{
    NSStrikethroughStyleAttributeName: @(NSUnderlineStyleSingle)
  }
              range:NSMakeRange(0, string.length)];
</code></pre>

<p>iOS 10.3之后写法：</p>

<pre><code class="objective-c">[attr addAttributes:@{
    NSStrikethroughStyleAttributeName: @(NSUnderlineStyleSingle),
    NSBaselineOffsetAttributeName: @(NSUnderlineStyleNone)
  }
              range:NSMakeRange(0, string.length)];
</code></pre>

<!-- more -->


<h2>设置状态栏style</h2>

<p>在<code>info.plist</code>文件中设置<code>View controller-based status bar appearance</code>为<code>YES</code>。<br/>
在对应ViewController中添加下面的方法：</p>

<pre><code class="objective-c">- (UIStatusBarStyle)preferredStatusBarStyle {
  return UIStatusBarStyleLightContent;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS知识小集-171113]]></title>
    <link href="http://sxgfxm.github.io/blog/2017/11/17/ioszhi-shi-xiao-ji-171113/"/>
    <updated>2017-11-17T17:28:01+08:00</updated>
    <id>http://sxgfxm.github.io/blog/2017/11/17/ioszhi-shi-xiao-ji-171113</id>
    <content type="html"><![CDATA[<h2>include vs. import vs. class</h2>

<h3>include</h3>

<p>C语言中引用头文件的语法，无法防止重复引用头文件。</p>

<h3>import</h3>

<p>OC中引用头文件的语法，可以防止重复引用头文件，无法防止循环引用头文件。</p>

<h3>class</h3>

<p>使用<code>@class</code>告知编译器有这样一个类，书写代码时不要报错，真正调用该类的方法时，再<code>#import</code>该类。
可以防止循环引用头文件。</p>

<p>一般来讲，头文件中使用<code>@class</code>引用其他类，在源文件中<code>#import</code>该类。</p>

<!-- more -->


<h2>目录结构</h2>

<p>工程目录结构看出技术水平。<br/>
高内聚，低耦合原则。</p>

<h2>Group vs. Folder</h2>

<p>Group创建引用，并不会创建实际文件夹，方便工程内移动；<br/>
Folder会创建实际文件夹，方便磁盘文件与工程文件对应；</p>

<h2>下拉刷新</h2>

<p><code>-scrollViewDidScroll:</code>，下拉播放header view的动画；<br/>
<code>-scrollViewDidEndDragging:willDecelerate:</code>，松手后请求数据；<br/>
数据返回后切换到正在状态。</p>

<h2>AFNetworking 内存泄露</h2>

<p>如果在一个ViewController中发起网络请求，在数据返回之前退出ViewController，网络请求持有的两个block不会被释放。</p>

<h2>UIBaselineAdjustment</h2>

<p>当文字缩放时的对齐方法：<br/>
<code>UIBaselineAdjustmentNone</code>：top和top对齐；<br/>
<code>UIBaselineAdjustmentAlignBaselines</code>：top和centerY对齐；<br/>
<code>UIBaselineAdjustmentAlignCenters</code>：centerY和centerY对齐。</p>

<h2>Generated duplicate UUIDs</h2>

<p>解决CocoaPods 重复生成 UUID。<br/>
在<code>Podfile</code>中添加<code>install! 'cocoapods', :deterministic_uuids =&gt; false</code>。</p>
]]></content>
  </entry>
  
</feed>

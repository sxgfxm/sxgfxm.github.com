<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Ios | Light's Blog]]></title>
  <link href="http://sxgfxm.github.io/blog/categories/ios/atom.xml" rel="self"/>
  <link href="http://sxgfxm.github.io/"/>
  <updated>2017-03-06T16:22:38+08:00</updated>
  <id>http://sxgfxm.github.io/</id>
  <author>
    <name><![CDATA[Light]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[iOS知识小集-170227]]></title>
    <link href="http://sxgfxm.github.io/blog/2017/03/06/ioszhi-shi-xiao-ji-170227/"/>
    <updated>2017-03-06T16:15:46+08:00</updated>
    <id>http://sxgfxm.github.io/blog/2017/03/06/ioszhi-shi-xiao-ji-170227</id>
    <content type="html"><![CDATA[<h2>OC中的锁</h2>

<pre><code>@implementation TestObj

-(void)method1{
  NSLog(@"Method1");
}
-(void)method2{
  NSLog(@"Method2");
}

@end
</code></pre>

<!--more-->


<h3>NSLock</h3>

<pre><code>NSLock *lock = [[NSLock alloc] init];
//线程1
dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
    [lock lock];
    [obj method1];
    sleep(10);
    [lock unlock];
});
//线程2
dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
    sleep(1);//以保证让线程2的代码后执行
    [lock lock];
    [obj method2];
    [lock unlock];
});
</code></pre>

<h3>synchronized关键字。</h3>

<pre><code>//主线程中
TestObj *obj = [[TestObj alloc] init];
//线程1
dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
    @synchronized(obj){
        [obj method1];
        sleep(10);
    }
});
//线程2
dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
    sleep(1);
    @synchronized(obj){
        [obj method2];
    }
});
</code></pre>

<h3>phread_mutex_t。</h3>

<pre><code>//主线程中
TestObj *obj = [[TestObj alloc] init];
__block pthread_mutex_t mutex;
pthread_mutex_init(&amp;mutex, NULL);
//线程1
dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
    pthread_mutex_lock(&amp;mutex);
    [obj method1];
    sleep(5);
    pthread_mutex_unlock(&amp;mutex);
});
//线程2
dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
    sleep(1);
    pthread_mutex_lock(&amp;mutex);
    [obj method2];
    pthread_mutex_unlock(&amp;mutex);
});
</code></pre>

<h3>GCD。</h3>

<pre><code>//主线程中
TestObj *obj = [[TestObj alloc] init];
dispatch_semaphore_t semaphore = dispatch_semaphore_create(1);
//线程1
dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
    dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);
    [obj method1];
    sleep(10);
    dispatch_semaphore_signal(semaphore);
});
//线程2
dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
    sleep(1);
    dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);
    [obj method2];
    dispatch_semaphore_signal(semaphore);
});
</code></pre>

<h2>生成圆形透明背景图片</h2>

<pre><code>+ (UIImage *)circularScaleAndCropImage:(UIImage *)image {
  // Create the bitmap graphics context
  UIGraphicsBeginImageContextWithOptions(CGSizeMake(image.size.width, image.size.height), NO, 0.0);
  CGContextRef context = UIGraphicsGetCurrentContext();

  // Get the width and heights
  CGFloat imageWidth = image.size.width;
  CGFloat imageHeight = image.size.height;

  // Calculate the centre of the circle
  CGFloat imageCentreX = imageWidth / 2;
  CGFloat imageCentreY = imageHeight / 2;

  // Create and CLIP to a CIRCULAR Path
  CGFloat radius = imageWidth / 2;
  CGContextBeginPath(context);
  CGContextAddArc(context, imageCentreX, imageCentreY, radius, 0, 2 * M_PI, 0);
  CGContextClosePath(context);
  CGContextClip(context);

  // Draw the IMAGE
  CGRect myRect = CGRectMake(0, 0, imageWidth, imageHeight);
  [image drawInRect:myRect];

  UIImage *newImage = UIGraphicsGetImageFromCurrentImageContext();
  UIGraphicsEndImageContext();

  return newImage;
}
</code></pre>

<h2>RxJava</h2>

<p>响应式函数编程<br/>
订阅的思想<br/>
多层异步回调逻辑更清晰</p>

<h2>Socket</h2>

<p><strong>Packet-based communication</strong><br/>
<strong>Stream-based clients </strong></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS知识小集-170220]]></title>
    <link href="http://sxgfxm.github.io/blog/2017/03/06/ioszhi-shi-xiao-ji-170220/"/>
    <updated>2017-03-06T16:06:34+08:00</updated>
    <id>http://sxgfxm.github.io/blog/2017/03/06/ioszhi-shi-xiao-ji-170220</id>
    <content type="html"><![CDATA[<h2>App生命周期</h2>

<p><strong>main.m</strong>：app程序入口，将控制权交给UIKit framework。<br/>
<strong>UIApplication</strong>：管理事件循环和高级行为，传递通知给代理。<br/>
<strong>App Delegate</strong>：处理应用初始化，状态转换，等高级行为。每个应用都要有。<br/>
<strong>Data Model</strong>：存储应用数据。<br/>
<strong>View Controller</strong>：管理应用展示内容。<br/>
<strong>View</strong>：展示内容。<br/>
<strong>Main Run Loop</strong>：Main run loop由UIApplication在主线程中开启，保证用户操作串行执行。
用户操作 -> 操作系统 -> 端口 -> 事件队列 -> Main run loop -> App object -> Core object
-> 操作系统 -> 屏幕反馈。<br/>
<strong>执行状态</strong>：<br/>
- 关闭状态。<br/>
- 未激活状态：在前台运行，但未接收到事件。<br/>
- 激活状态：在前台运行，接收到事件。<br/>
- 后台状态：在后台，且正在执行程序，通常会接着进入挂起状态。<br/>
- 挂起状态：在后台，且没有执行程序。当内存不足时会清理挂起应用。</p>

<!--more-->


<h2>后台执行</h2>

<p><strong>限时操作</strong>：调用<code>beginBackgroundTaskWithName:expirationHandler:</code>或<code>beginBackgroundTaskWithExpirationHandler:</code>开启后台执行，在执行完成后必须调用<code>endBackgroundTask:</code>表示结束后台执行，否则程序会被终止。可以通过<code>application.backgroundTimeRemaining</code>查看剩余后台执行时间，一般为180秒。</p>

<pre><code>- (void)applicationDidEnterBackground:(UIApplication *)application
{
    bgTask = [application beginBackgroundTaskWithName:@"MyTask" expirationHandler:^{
        // Clean up any unfinished task business by marking where you
        // stopped or ending the task outright.
        [application endBackgroundTask:bgTask];
        bgTask = UIBackgroundTaskInvalid;
    }];

    // Start the long-running task and return immediately.
    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{

        // Do the work associated with the task, preferably in chunks.

        NSLog(@"begin %.f", application.backgroundTimeRemaining);
        [NSThread sleepForTimeInterval:10];
        NSLog(@"end %.f", application.backgroundTimeRemaining);

        [application endBackgroundTask:bgTask];
        bgTask = UIBackgroundTaskInvalid;
    });
}
</code></pre>

<p><strong>下载操作</strong>：必须使用<strong>NSURLSession</strong>开启下载操作，需要通过<strong>NSURLSessionConfiguration</strong>进行设置。</p>

<pre><code>- (void)startDownloadTask {
  //  Configuration
  NSURLSessionConfiguration *config = [NSURLSessionConfiguration
      backgroundSessionConfigurationWithIdentifier:@"DownloadTask"];
  //  下载完成时唤醒应用
  config.sessionSendsLaunchEvents = YES;
  //  在前台时开启下载任务时有效
  config.discretionary = YES;
  //  NSURLSession
  NSURLSession *session = [NSURLSession sessionWithConfiguration:config];
  //  开启下载任务
  NSURLSessionTask *task =
      [session dataTaskWithURL:[NSURL URLWithString:@"www.baidu.com"]
             completionHandler:^(NSData *_Nullable data,
                                 NSURLResponse *_Nullable response,
                                 NSError *_Nullable error){

             }];
  //  当挂起时恢复任务
  [task resume];
}
</code></pre>

<p><strong>耗时操作</strong>：只有特殊的耗时操作可以在后台被执行，且必须申请权限。如后台音乐播放、录音、定位信息更新、蓝牙连接、远程通知、语音服务等。</p>

<h2>ViewController生命周期</h2>

<h2>权限操作</h2>

<p>iOS 10开始，获取<strong>隐私</strong>敏感数据需要在<strong>plist.info</strong>文件中配置，否则app会crash。<br/>
配置方法：添加对应权限的key和value，value不许为空。<br/>
常用权限：</p>

<ul>
<li>Network：无需添加key</li>
<li>Location：Privacy - Location Always Usage Description</li>
<li>Photo：Privacy - Photo Library Usage Description</li>
<li>Camera：Privacy - Camera Usage Description</li>
<li>Microphone：Privacy - Microphone Usage Description</li>
<li>Contact：Privacy - Contacts Usage Description</li>
<li>Media：Privacy - Media Library Usage Description</li>
</ul>


<p>手动请求权限：当用户拒绝授权某权限时，需要手动再次请求。<br/>
跳转至权限设置界面：</p>

<pre><code>[[UIApplication sharedApplication]
                openURL:[NSURL URLWithString:UIApplicationOpenSettingsURLString]
                options:@{}
      completionHandler:nil];
</code></pre>

<p><a href="https://github.com/sxgfxm/AuthorizationDemo">Demo地址</a></p>

<h2>文件操作</h2>

<ul>
<li>NSString I/O</li>
<li>NSArray I/O</li>
<li>NSDictionary I/O</li>
<li>NSData I/O</li>
<li>NSObject I/O</li>
<li>NSFileManager</li>
<li>NSFileHandle</li>
</ul>


<p><a href="https://github.com/sxgfxm/FileOperationDemo">Demo地址</a></p>

<h2>weakself</h2>

<p>作用：<strong>防止循环引用</strong>。<br/>
声明：<code>__weak typeof(self) weakself = self;</code>。<br/>
使用：
1. 是不是所有的block中都需要使用weakself？<br/>
   Masonry自动约束中无需使用weakself。
2. 详细解释循环引用及防止方法？</p>

<h2>单元测试</h2>

<blockquote><p>If your code isn’t easy to test, it’s not going to be easy to maintain or debug.</p></blockquote>

<p>验证某个类的某种行为在某种上下文中能得到预期结果。<br/>
保证每个测试用例所针对的仅仅是一个基本单元，而不是一个有很多复杂依赖的综合行为。<br/>
依赖于抽象而不是具体实现细节。<br/>
不应关注于<strong>测试</strong>，而应关注<strong>行为</strong>。测试对象的行为方式。<br/>
降低未来的变化所带来的成本。<br/>
<strong>功能检测</strong><br/>
<strong>依赖提取</strong><br/>
<strong>依赖注入</strong><br/>
<strong>行为方式</strong><br/>
1. 单元测试测什么？<br/>
   方法？行为？<br/>
2. 如何处理依赖关系？<br/>
   Mock？Stub？<br/>
3. 单元测试的优缺点？<br/>
   优点：验证模块的功能正确，行为正确，模块化编程，尽早发现问题，检验修改，重构；<br/>
   缺点：增加代码量，写好测试不容易，不能保证不出错，考虑后期维护，尽量减少源代码耦合。<br/>
4. 测试库？<br/>
   <a href="https://github.com/jonreid/OCMockito">OCMockito</a><br/>
5. 断言？<br/>
   同步断言？异步断言（block，代理）？</p>

<h2>A/B Test</h2>

<h2>同步策略</h2>

<h2>JavaScriptCore</h2>

<p><strong>JSContext</strong>：是运行JavaScript代码的环境。<br/>
<strong>JSValue</strong>：JSContext的运行结果封装在JSValue中。<br/>
OC -> JavaScript：<strong>SubscriptValue</strong>、<strong>CallFunction</strong>，<strong>HandleException</strong>。<br/>
JavaScript -> OC：<strong>Block</strong>或<strong>JSExport</strong>。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS System Authorization]]></title>
    <link href="http://sxgfxm.github.io/blog/2017/02/25/ios-system-authorization/"/>
    <updated>2017-02-25T14:17:43+08:00</updated>
    <id>http://sxgfxm.github.io/blog/2017/02/25/ios-system-authorization</id>
    <content type="html"><![CDATA[<p>iOS 10开始，获取<strong>隐私</strong>敏感数据需要在<strong>plist.info</strong>文件中配置，否则app会crash。<br/>
配置方法：添加对应权限的key和value，value不许为空。<br/>
常用权限：</p>

<ul>
<li>Network：无需添加key</li>
<li>Location：Privacy - Location Always Usage Description</li>
<li>Photo：Privacy - Photo Library Usage Description</li>
<li>Camera：Privacy - Camera Usage Description</li>
<li>Microphone：Privacy - Microphone Usage Description</li>
<li>Contact：Privacy - Contacts Usage Description</li>
<li>Media：Privacy - Media Library Usage Description</li>
</ul>


<p>手动请求权限：当用户拒绝授权某权限时，需要手动再次请求。<br/>
跳转至权限设置界面：</p>

<pre><code>[[UIApplication sharedApplication]
                openURL:[NSURL URLWithString:UIApplicationOpenSettingsURLString]
                options:@{}
      completionHandler:nil];
</code></pre>

<p><a href="https://github.com/sxgfxm/AuthorizationDemo">Demo地址</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS Core Animation Advanced Techniques]]></title>
    <link href="http://sxgfxm.github.io/blog/2017/02/20/ios-core-animation-advanced-techniques/"/>
    <updated>2017-02-20T22:10:40+08:00</updated>
    <id>http://sxgfxm.github.io/blog/2017/02/20/ios-core-animation-advanced-techniques</id>
    <content type="html"><![CDATA[<h1>Introduction</h1>

<p>本文主要为<strong>iOS Core Animation Advanced Techniques</strong>的笔记。</p>

<!--more-->


<h2>CALayer和UIView</h2>

<p>1.CALayer和UIView有什么关系？<br/>
UIView是对CALayer的封装，可以处理touch事件。<br/>
UIView是通过CALayer显示的。<br/>
UIView会自动重绘，CALayer需要手动重绘。<br/>
UIView是二维的，CALayer是三维的。<br/>
UIView支持autoLayout，CALayer不支持autoLayout。<br/>
2、CALayer的特性是什么？<br/>
可以绘制阴影、圆角、彩色边框；<br/>
可以处理3D变换；<br/>
可以处理非矩形边界；<br/>
可以处理透明遮罩；<br/>
可以处理多级非线性动画。<br/>
3、什么情况下会使用CALayer？<br/>
开发跨平台应用；<br/>
与特殊图层打交道；<br/>
提高性能。<br/>
4、为什么不把CALayer和UIView合二为一，而是有两套并列的层次结构？<br/>
把绘图和事件处理分离，是为了减少重复的代码。<br/>
在Mac OS上已经有CALayer，但在iPhone和Mac的交互是有本质不同的，所以UIView来处理。</p>

<h3>Contents</h3>

<p>1、如何让UIView等比清晰显示图片的右上角？<br/>
<code>layer.contents = (__bridge id)image.CGImage;</code><br/>
<code>layer.contentsGravity = kCAGravityResizeAspect;</code><br/>
<code>layer.contentsScale = [UIScreen mainScreen].scale;</code><br/>
<code>layer.contentsRect = CGRectMake(0.5,0,0.5,0.5);</code><br/>
2、-drawRect:方法的作用是什么？空的-drawRect:方法有何影响？<br/>
UIView自定义绘图。<br/>
如果自己实现-drawRect:方法，会为view创建一个backing image。<br/>
3、如何绘制带阴影的有裁剪效果的UIView？<br/>
设置layer阴影；<br/>
通过layer代理绘图；</p>

<h3>Geometry</h3>

<p>1、center, position的区别？<br/>
center对应view；position对应layer。<br/>
两者都表示anchorPoint在父视图中的位置。<br/>
因为UIView并没有暴露anchorPoint属性，所以被称作center。<br/>
2、anchorPoint理解？<br/>
控制点。<br/>
3、frame的理解？<br/>
是否可以改变view的frame而不改变layer的frame。<br/>
frame是由bounds，position和transform计算而来的。<br/>
4、坐标转换？</p>

<pre><code>- (CGPoint)convertPoint:(CGPoint)point fromLayer:(CALayer *)layer;
- (CGPoint)convertPoint:(CGPoint)point toLayer:(CALayer *)layer;
- (CGRect)convertRect:(CGRect)rect fromLayer:(CALayer *)layer;
- (CGRect)convertRect:(CGRect)rect toLayer:(CALayer *)layer;
</code></pre>

<p>5、坐标翻转</p>

<p><code>layer.geometryFlipped = YES;</code></p>

<p>6、如何在不修改layer层次结构的情况下，使下层的layer在顶层显示？<br/>
zPosition，用来改变layer的显示层次；<br/>
zAnchorPoint?<br/>
7、如何用CALayer实现touch handling？<br/>
-containsPoint:<br/>
-hitTest: 严格按照layer tree的层次结构判断，与zPosition无关。<br/>
8、如何实现CALayer的自动布局？<br/>
<code>- (void)layoutSublayersOfLayer:(CALayer *)layer;</code>，<br/>
当bounds改变或调用<code>-setNeedsLayout</code>时触发。</p>

<h3>Visual Effects</h3>

<p>1、如何实现圆角？曲率不同的圆角？</p>

<pre><code>layer.cornerRadius = 5.0f;
layer.maskToBounds = YES;
</code></pre>

<p>2、如何实现彩色边框？</p>

<pre><code>layer.borderWidth = 1;
layer.borderColor = [UIColor redColor].CGColor;
</code></pre>

<p>border只与bounds相关。<br/>
3、如何添加阴影？</p>

<pre><code>layer.shadowOpacity = 1;
layer.shadowColor = [UIColor redColor].CGColor;
layer.shadowOffset = CGSizeMake(0,1);
layer.shadowRadius = 5;
</code></pre>

<p>shadow与形状有关。<br/>
如何添加maskToBounds = YES时的阴影？<br/>
两层。<br/>
如何绘制不规则阴影？<br/>
<code>layer.shadowPath = path;</code>
4、不规则裁剪，动态裁剪<br/>
<code>layer.mask = maskLayer;</code>
5、scaling filter<br/>
kCAFilterNearest，适用于无对角线，对比明显的图片，保留像素，像素图；<br/>
kCAFilterLinear，适用于复杂图片，保留轮廓；<br/>
6、group opacity<br/>
opacity作用于层次结构，0.5+0.5 = 0.75<br/>
UIViewGroupOpacity = YES，Info.plist，降低性能。<br/>
<code>layer.shouldRasterize = YES</code>，在渲染前合成一张图片，防止alpha值影响。<br/>
<code>layer.rasterizationScale = [UIScreen mainScreen].scale;</code></p>

<h3>Transform</h3>

<p>1、Affine Transforms，仿射变换<br/>
CGAffineTransform，用来表示二维旋转，缩放和变换。对一个2D点做2D变换。<br/>
它是一个3行2列的矩阵。<br/>
做运算时需要扩展。<br/>
变换前平行的线，变换后依然平行。<br/>
2、创建仿射变换</p>

<pre><code>CGAffineTransformMakeRotation(CGFloat angle);
CGAffineTransformMakeScale(CGFloat sx, CGFloat sy);
CGAffineTransformMakeTranslation(CGFloat tx, CGFloat ty);
</code></pre>

<p>角度弧度转换</p>

<pre><code>#define RADIANS_TO_DEGREES(x) ((x)/M_PI*180.0)
#define DEGREES_TO_RADIANS(x) ((x)/180.0*M_PI)
</code></pre>

<p>3、连续变换</p>

<pre><code>CGAffineTransformRotate(CGAffineTransform t, CGFloat angle);
CGAffineTransformScale(CGAffineTransform t, CGFloat sx, CGFloat sy);
CGAffineTransformTranslate(CGAffineTransform t, CGFloat tx, CGFloat ty);
或
CGAffineTransformConcat(CGAffineTransform t1, CGAffineTransform t2);
</code></pre>

<p>单位矩阵，CGAffineTransformIdentity。<br/>
变换顺序不同，结果不同。因为矩阵运算不符合交换律。<br/>
4、shear变换</p>

<pre><code>CGAffineTransform CGAffineTransformMakeShear(CGFloat x, CGFloat y) {
  CGAffineTransform transform = CGAffineTransformIdentity; transform.c = -x;
  transform.b = y;
  return transform;
}
</code></pre>

<p>5、3D Transform，3D变换<br/>
CATransform3D，是一个4行4列的矩阵。对一个3D点做3D变换。</p>

<pre><code>CATransform3DMakeRotation(CGFloat angle, CGFloat x, CGFloat y, CGFloat z);
CATransform3DMakeScale(CGFloat sx, CGFloat sy, CGFloat sz);
CATransform3DMakeTranslation(Gloat tx, CGFloat ty, CGFloat tz);
</code></pre>

<p>6、Perspective Projection，透视<br/>
矩阵中m34的值用来设置透视，值越小透视约明显，值越大透视越不明显。<br/>
7、The Vanishing Point，消失点<br/>
定义消失点为anchorPoint。<br/>
8、sublayer共享透视视角<br/>
设置sublayerTransform<br/>
9、Backfaces，<br/>
layer是两面都有的。可以设置取消。</p>

<h2>Specialized Layers</h2>

<h3>CAShapeLayer</h3>

<p>CAShapeLayer比Core Graphics效率更高，硬件加速；<br/>
CAShapeLayer节省内存空间，不会创建backing image；<br/>
CAShapeLayer不会受bounds限制，Core Graphics不行；<br/>
CAShapeLayer不会变换后不会像素化。<br/>
基本使用方法：<br/>
<code>
CAShapeLayer *shapeLayer = [CAShapeLayer layer];
shapeLayer.strokeColor = [UIColor redColor].CGColor;
shapeLayer.fillColor = [UIColor clearColor].CGColor;
shapeLayer.lineWidth = 5;
shapeLayer.lineJoin = kCALineJoinRound;
shapeLayer.lineCap = kCALineCapRound;
shapeLayer.path = path.CGPath;
</code></p>

<h3>CATextLayer</h3>

<p>UILabel，通过layer代理方法使用CG绘制string。<br/>
CATextLayer，用于显示文字，特效，效率比UILabel高。<br/>
基本使用方法：<br/>
<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>//set text attributes
</span><span class='line'>textLayer.foregroundColor = [UIColor blackColor].CGColor;
</span><span class='line'>textLayer.alignmentMode = kCAAlignmentJustified;
</span><span class='line'>textLayer.wrapped = YES;&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;//choose a font
</span><span class='line'>UIFont *font = [UIFont systemFontOfSize:15];&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;//set layer font
</span><span class='line'>CFStringRef fontName = (__bridge CFStringRef)font.fontName;
</span><span class='line'>CGFontRef fontRef = CGFontCreateWithFontName(fontName);
</span><span class='line'>textLayer.font = fontRef;
</span><span class='line'>textLayer.fontSize = font.pointSize;
</span><span class='line'>CGFontRelease(fontRef);&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;//text
</span><span class='line'>textLayer.string = @&ldquo;Text&rdquo;;&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;//scale
</span><span class='line'>textLayer.contentsScale = [UIScreen mainScreen].scale;
</span><span class='line'>&lt;code&gt;
</span><span class='line'>富文本：  
</span><span class='line'>&lt;/code&gt;
</span><span class='line'>//create attributed string
</span><span class='line'>NSMutableAttributedString *string = nil;
</span><span class='line'>string = [[NSMutableAttributedString alloc] initWithString:text];&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;//convert UIFont to a CTFont
</span><span class='line'>CFStringRef fontName = (__bridge CFStringRef)font.fontName; CGFloat fontSize = font.pointSize;
</span><span class='line'>CTFontRef fontRef = CTFontCreateWithName(fontName, fontSize, NULL);&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;//set text attributes
</span><span class='line'>NSDictionary *attribs = @{
</span><span class='line'>  (&lt;strong&gt;bridge id)kCTForegroundColorAttributeName:(&lt;/strong&gt;bridge id)[UIColor blackColor].CGColor,
</span><span class='line'>  (&lt;strong&gt;bridge id)kCTFontAttributeName: (&lt;/strong&gt;bridge id)fontRef
</span><span class='line'>};
</span><span class='line'>[string setAttributes:attribs range:NSMakeRange(0, [text length])];
</span><span class='line'>attribs = @{
</span><span class='line'>  (&lt;strong&gt;bridge id)kCTForegroundColorAttributeName: (&lt;/strong&gt;bridge id)[UIColor redColor].CGColor,
</span><span class='line'>  (&lt;strong&gt;bridge id)kCTUnderlineStyleAttributeName: @(kCTUnderlineStyleSingle),
</span><span class='line'>  (&lt;/strong&gt;bridge id)kCTFontAttributeName: (__bridge id)fontRef
</span><span class='line'>};
</span><span class='line'>[string setAttributes:attribs range:NSMakeRange(6, 5)];&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;//release the CTFont we created earlier
</span><span class='line'>CFRelease(fontRef);&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;//set layer text
</span><span class='line'>textLayer.string = string;
</span><span class='line'>&lt;code&gt;
</span><span class='line'>修改view的根layer。  
</span><span class='line'>&lt;/code&gt;
</span><span class='line'>+ (Class)layerClass {
</span><span class='line'>  //this makes our label create a CATextLayer
</span><span class='line'>  //instead of a regular CALayer for its backing layer
</span><span class='line'>  return [CATextLayer class];
</span><span class='line'>}
</span><span class='line'>- (CATextLayer &lt;em&gt;)textLayer {
</span><span class='line'>  return (CATextLayer &lt;/em&gt;)self.layer;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure></p>

<h3>CATransformLayer</h3>

<p>保存变换后的layer</p>

<h3>CAGradientLayer</h3>

<p>用于绘制渐变层。<br/>
线性渐变。<br/>
<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>//create gradient layer and add it to our container view
</span><span class='line'>CAGradientLayer *gradientLayer = [CAGradientLayer layer];
</span><span class='line'>gradientLayer.frame = self.containerView.bounds;
</span><span class='line'>[self.containerView.layer addSublayer:gradientLayer];&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;//set gradient colors
</span><span class='line'>gradientLayer.colors = @[
</span><span class='line'>  (&lt;strong&gt;bridge id)[UIColor redColor].CGColor,
</span><span class='line'>  (&lt;/strong&gt;bridge id)[UIColor blueColor].CGColor,
</span><span class='line'>  (__bridge id)[UIColor greenColor].CGColor
</span><span class='line'>];&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;//set locations
</span><span class='line'>gradientLayer.locations = @[@0.0, @0.25, @0.5];&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;//set gradient start and end points
</span><span class='line'>gradientLayer.startPoint = CGPointMake(0, 0);
</span><span class='line'>gradientLayer.endPoint = CGPointMake(1, 1);</span></code></pre></td></tr></table></div></figure>
放射性渐变。</p>

<h3>CAReplicatorLayer</h3>

<p>用于高效绘制相似的layer。<br/>
<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>//create a replicator layer and add it to our view
</span><span class='line'>CAReplicatorLayer *replicator = [CAReplicatorLayer layer];
</span><span class='line'>replicator.frame = self.containerView.bounds;
</span><span class='line'>[self.containerView.layer addSublayer:replicator];&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;//configure the replicator
</span><span class='line'>replicator.instanceCount = 10;&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;//apply a transform for each instance
</span><span class='line'>CATransform3D transform = CATransform3DIdentity;
</span><span class='line'>transform = CATransform3DTranslate(transform, 0, 200, 0);
</span><span class='line'>transform = CATransform3DRotate(transform, M_PI / 5.0, 0, 0, 1);
</span><span class='line'>transform = CATransform3DTranslate(transform, 0, -200, 0);
</span><span class='line'>replicator.instanceTransform = transform;&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;//apply a color shift for each instance
</span><span class='line'>replicator.instanceBlueOffset = -0.1;
</span><span class='line'>replicator.instanceGreenOffset = -0.1;&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;//create a sublayer and place it inside the replicator
</span><span class='line'>CALayer &lt;em&gt;layer = [CALayer layer];
</span><span class='line'>layer.frame = CGRectMake(100.0f, 100.0f, 100.0f, 100.0f);
</span><span class='line'>layer.backgroundColor = [UIColor whiteColor].CGColor;
</span><span class='line'>[replicator addSublayer:layer];
</span><span class='line'>&lt;code&gt;
</span><span class='line'>绘制镜面  
</span><span class='line'>&lt;/code&gt;
</span><span class='line'>+ (Class)layerClass {
</span><span class='line'>  return [CAReplicatorLayer class];
</span><span class='line'>}
</span><span class='line'>- (void)setUp {
</span><span class='line'>  //configure replicator
</span><span class='line'>  CAReplicatorLayer &lt;/em&gt;layer = (CAReplicatorLayer *)self.layer;
</span><span class='line'>  layer.instanceCount = 2;&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;  //move reflection instance below original and flip vertically
</span><span class='line'>  CATransform3D transform = CATransform3DIdentity;
</span><span class='line'>  CGFloat verticalOffset = self.bounds.size.height + 2;
</span><span class='line'>  transform = CATransform3DTranslate(transform, 0, verticalOffset, 0);
</span><span class='line'>  transform = CATransform3DScale(transform, 1, -1, 0);
</span><span class='line'>  layer.instanceTransform = transform;&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;  //reduce alpha of reflection layer
</span><span class='line'>  layer.instanceAlphaOffset = -0.6;
</span><span class='line'>}&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;ul&gt;
</span><span class='line'>&lt;li&gt;(id)initWithFrame:(CGRect)frame {
</span><span class='line'>//this is called when view is created in code
</span><span class='line'>if ((self = [super initWithFrame:frame])) {
</span><span class='line'>  [self setUp];
</span><span class='line'>}
</span><span class='line'>return self;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure></li>
</ul>


<h3>CAScrollLayer</h3>

<p>用于绘制可以滑动的layer。<br/>
<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>+ (Class)layerClass {
</span><span class='line'>  return [CAScrollLayer class];
</span><span class='line'>}&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;ul&gt;
</span><span class='line'>&lt;li&gt;&lt;p&gt;(void)setUp {
</span><span class='line'>//enable clipping
</span><span class='line'>self.layer.masksToBounds = YES;&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;//attach pan gesture recognizer
</span><span class='line'>UIPanGestureRecognizer *recognizer = nil;
</span><span class='line'>recognizer = [[UIPanGestureRecognizer alloc] initWithTarget:self action:@selector(pan:)];
</span><span class='line'>[self addGestureRecognizer:recognizer];
</span><span class='line'>}&lt;/p&gt;&lt;/li&gt;
</span><span class='line'>&lt;li&gt;&lt;p&gt;(id)initWithFrame:(CGRect)frame {
</span><span class='line'>//this is called when view is created in code
</span><span class='line'>if ((self = [super initWithFrame:frame])) {
</span><span class='line'>  [self setUp];
</span><span class='line'>}
</span><span class='line'>return self;
</span><span class='line'>}&lt;/p&gt;&lt;/li&gt;
</span><span class='line'>&lt;li&gt;&lt;p&gt;(void)pan:(UIPanGestureRecognizer *)recognizer {
</span><span class='line'>//get the offset by subtracting the pan gesture
</span><span class='line'>//translation from the current bounds origin
</span><span class='line'>CGPoint offset = self.bounds.origin;
</span><span class='line'>offset.x -= [recognizer translationInView:self].x;
</span><span class='line'>offset.y -= [recognizer translationInView:self].y;&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;//scroll the layer
</span><span class='line'>[(CAScrollLayer *)self.layer scrollToPoint:offset];&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;//reset the pan gesture translation
</span><span class='line'>[recognizer setTranslation:CGPointZero inView:self];
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure></p></li>
</ul>


<h3>CATiledLayer</h3>

<p>用于加载尺寸巨大的图片。<br/>
<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>//add the tiled layer
</span><span class='line'>CATiledLayer *tileLayer = [CATiledLayer layer];
</span><span class='line'>tileLayer.frame = CGRectMake(0, 0, 2048, 2048);
</span><span class='line'>tileLayer.delegate = self; [self.scrollView.layer addSublayer:tileLayer];&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;//configure the scroll view
</span><span class='line'>self.scrollView.contentSize = tileLayer.frame.size;&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;//draw layer
</span><span class='line'>[tileLayer setNeedsDisplay];&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;ul&gt;
</span><span class='line'>&lt;li&gt;&lt;p&gt;(void)drawLayer:(CATiledLayer *)layer inContext:(CGContextRef)ctx {
</span><span class='line'>//determine tile coordinate
</span><span class='line'>CGRect bounds = CGContextGetClipBoundingBox(ctx);
</span><span class='line'>NSInteger x = floor(bounds.origin.x / layer.tileSize.width);
</span><span class='line'>NSInteger y = floor(bounds.origin.y / layer.tileSize.height);&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;//load tile image
</span><span class='line'>NSString &lt;em&gt;imageName = [NSString stringWithFormat: @&ldquo;Snowman&lt;em&gt;%02i&lt;/em&gt;%02i, x, y];
</span><span class='line'>NSString &lt;/em&gt;imagePath = [[NSBundle mainBundle] pathForResource:imageName ofType:@"jpg&rdquo;];
</span><span class='line'>UIImage *tileImage = [UIImage imageWithContentsOfFile:imagePath];&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;//draw tile
</span><span class='line'>UIGraphicsPushContext(ctx);
</span><span class='line'>[tileImage drawInRect:bounds];
</span><span class='line'>UIGraphicsPopContext();
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure></p></li>
</ul>


<h3>CAEmitterLayer</h3>

<p>粒子特效。<br/>
<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>//create particle emitter layer
</span><span class='line'>CAEmitterLayer *emitter = [CAEmitterLayer layer];
</span><span class='line'>emitter.frame = self.containerView.bounds;
</span><span class='line'>[self.containerView.layer addSublayer:emitter];&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;//configure emitter
</span><span class='line'>emitter.renderMode = kCAEmitterLayerAdditive;
</span><span class='line'>emitter.emitterPosition = CGPointMake(emitter.frame.size.width / 2.0,emitter.frame.size.height / 2.0);&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;//create a particle template
</span><span class='line'>CAEmitterCell *cell = [[CAEmitterCell alloc] init];
</span><span class='line'>cell.contents = (__bridge id)[UIImage imageNamed:@&ldquo;Spark.png&rdquo;].CGImage;
</span><span class='line'>cell.birthRate = 150;
</span><span class='line'>cell.lifetime = 5.0;
</span><span class='line'>cell.color = [UIColor colorWithRed:1 green:0.5 blue:0.1 alpha:1.0].CGColor;
</span><span class='line'>cell.alphaSpeed = -0.4;
</span><span class='line'>cell.velocity = 50;
</span><span class='line'>cell.velocityRange = 50;
</span><span class='line'>cell.emissionRange = M_PI * 2.0;&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;//add particle template to emitter
</span><span class='line'>emitter.emitterCells = @[cell];</span></code></pre></td></tr></table></div></figure></p>

<h3>AVPlayerLayer</h3>

<p>播放视频。<br/>
<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>//get video URL
</span><span class='line'>NSURL *URL = [[NSBundle mainBundle] URLForResource:@&ldquo;Ship&rdquo; withExtension:@&ldquo;mp4&rdquo;];&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;//create player and player layer
</span><span class='line'>AVPlayer &lt;em&gt;player = [AVPlayer playerWithURL:URL];
</span><span class='line'>AVPlayerLayer &lt;/em&gt;playerLayer = [AVPlayerLayer playerLayerWithPlayer:player];&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;//set player layer frame and attach it to our view
</span><span class='line'>playerLayer.frame = self.containerView.bounds;
</span><span class='line'>[self.containerView.layer addSublayer:playerLayer];&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;//play the video
</span><span class='line'>[player play];</span></code></pre></td></tr></table></div></figure></p>

<h2>Implicit Animations</h2>

<p>隐式动画。改变支持动画的属性，自动生成动画。<br/>
duration -> transaction，默认为0.25秒<br/>
type -> layer action<br/>
transaction只能begin和commit。<br/>
每次runloop会执行一次transaction。<br/>
<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>//begin a new transaction
</span><span class='line'>[CATransaction begin];&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;//set the animation duration to 1 second
</span><span class='line'>[CATransaction setAnimationDuration:1.0];&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;//add the spin animation on completion
</span><span class='line'>[CATransaction setCompletionBlock:^{
</span><span class='line'>  //rotate the layer 90 degrees
</span><span class='line'>  CGAffineTransform transform = self.colorLayer.affineTransform;
</span><span class='line'>  transform = CGAffineTransformRotate(transform, M_PI_2);
</span><span class='line'>  self.colorLayer.affineTransform = transform;
</span><span class='line'>}];&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;//randomize the layer background color
</span><span class='line'>CGFloat red = arc4random() / (CGFloat)INT_MAX;
</span><span class='line'>CGFloat green = arc4random() / (CGFloat)INT_MAX;
</span><span class='line'>CGFloat blue = arc4random() / (CGFloat)INT_MAX;
</span><span class='line'>self.colorLayer.backgroundColor = [UIColor colorWithRed:red green:green blue:blue alpha:1.0].CGColor;&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;//commit the transaction
</span><span class='line'>[CATransaction commit];
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>
隐式动画流程：<br/>
-actionForLayer:forKey<br/>
actions dictionary<br/>
style dictionary<br/>
-defaultActionForKey:</p>

<p>UIView默认不开启隐式动画。<br/>
CATransition</p>

<p>修改layer属性会立即生效，但是并不会立刻显示。</p>

<p>presentation layer，记录当前layer在哪儿，同步动画和处理点击事件。<br/>
model layer，记录当前layer要去哪儿</p>

<h2>Explicit Aniamtions</h2>

<p>显式动画。</p>

<h3>Property Animations</h3>

<p>只与一个属性相关的动画。</p>

<p>CABasicAnimation : CAPropertyAnimation : CAAnimation<br/>
fromeValue<br/>
toValue<br/>
byValue</p>

<p>Animations只作用于presentation，而不作用于model。<br/>
<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (void)applyBasicAnimation:(CABasicAnimation &lt;em&gt;)animation toLayer:(CALayer &lt;/em&gt;)layer{
</span><span class='line'>  //set the from value (using presentation layer if available)&lt;br/&gt;
</span><span class='line'>  animation.fromValue = [layer.presentationLayer ?: layer valueForKeyPath:animation.keyPath];&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;  //update the property in advance
</span><span class='line'>  //note: this approach will only work if toValue != nil
</span><span class='line'>  [CATransaction begin];
</span><span class='line'>  [CATransaction setDisableActions:YES];
</span><span class='line'>  [layer setValue:animation.toValue forKeyPath:animation.keyPath];
</span><span class='line'>  [CATransaction commit];&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;  //apply animation to layer
</span><span class='line'>  [layer addAnimation:animation forKey:nil];
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure></p>

<p>CAKeyframeAnimation : CAPropertyAnimation : CAAnimation<br/>
values<br/>
path<br/>
rotationMode = kCAAnimationRotateAuto</p>

<p>CAAnimationGroup<br/>
animations<br/>
duration</p>

<p>Transitions<br/>
CATransition : CAAnimation<br/>
type<br/>
subtype</p>

<p>视图控制器切换时使用，效果更平滑；</p>

<h3>Cancel animations</h3>

<p><code>-removeAnimationForKey: </code></p>

<h2>Layer time</h2>

<h2>Tuning for speed</h2>

<p>合理分配绘图任务至CPU和GPU。</p>

<h3>The Stages of an Animation</h3>

<p>Layout：setup layers<br/>
Display：draw backing image，call -drawRect:<br/>
Prepare：prepare send animation data to render server<br/>
Commit：package up and send over IPC<br/>
render server form render tree:<br/>
  calculate intermediate values<br/>
  render to screen<br/>
只有最后一步通过GPU处理。<br/>
开发者只能控制前两步，layout和display。</p>

<p>影响GPU绘图效率的因素：<br/>
1、过多的layer；<br/>
2、过多的半透明layer；<br/>
3、离屏绘制，如圆角、遮罩、阴影、光栅化；<br/>
4、过大的图片。</p>

<p>影响CPU绘图效率的因素：<br/>
1、复杂的layout计算；<br/>
2、view的懒加载，从数据库获取数据，从nib中加载view，加载图片；<br/>
3、Core Graphics 绘图；<br/>
4、图片解压缩；</p>

<p>IO限制因素：<br/>
IO操作耗时严重；</p>

<p>通过测量发现实际的瓶颈点：<br/>
1、在真机上测试，使用release版本，在低性能机器上测试；<br/>
2、保持稳定的帧率；<br/>
3、instrument：</p>

<pre><code>Time Profiler：查看CPU时间开销；
    Separate by Thread：按线程将方法分组；
    Hide System Libraries：隐藏系统库；
    Show Obj-C Only：只显示OC方法调用；
Core Animation：查看Core Animation性能；
    Color Blended Layers：标记出混合的图层，从绿到红表示严重程度，最好没有；
    Color Hits Green and Misses Red：标记出重复缓存的图层；
    Color Copied Images：标记出backing image，最好没有；
    Color Immediately：随时反馈；
    Color Misaligned Images：标记非正确缩放的图片；
    Color Offscreen-Rendered Yellow：标记出需要离屏绘制的layer，通过栅格化优化；
    Color OpenGL Fast Path Blue：标记出OpenGL绘图；
    Flash Updated Regions：标记出重绘的layer，最好没有；
OpenGL ES Driver：查看GPU性能；
    Tiler Utilization
    Renderer Utilization
组合使用效果更佳。
</code></pre>

<p>优化方法：<br/>
cache offscreen render layer：</p>

<pre><code>layer.shouldRasterize = YES;
layer.rasterizationScale = [UIScreen mainScreen].scale;
</code></pre>

<h2>Efficient Drawing</h2>

<h3>Software Drawing</h3>

<p>速度慢并且需要大量内存空间。<br/>
少写drawRect方法。</p>

<h3>Vector Graphics</h3>

<p>多边形；<br/>
对角线和曲线；<br/>
文字；<br/>
渐变。<br/>
使用CAShapeLayer</p>

<h3>Dirty Rectangles</h3>

<p>需要重绘的区域<br/>
调用-setNeedsDisplayInRect:方法指定重绘区域。</p>

<h3>Asynchronous Drawing</h3>

<p>在子线程绘图，将结果直接作为layer的contents。<br/>
CATiledLayer。<br/>
drawsAsynchronously属性。</p>

<h2>Image IO</h2>

<pre><code>//  通过tag防止重复创建
UIImageView *imageView = (UIImageView *)[cell viewWithTag:imageTag];
if (!imageView){
  imageView = [UIImageView alloc] init];
  [cell.contentView addSubview:imageView];
}
</code></pre>

<h3>Loading and Latency</h3>

<p>button的响应时间要保持在0.2秒以下。</p>

<h3>Threaded Loading</h3>

<p>gcd</p>

<pre><code>//  标记cell
cell.tag = indexPath.row;
imageView.image = nil;
//  异步加载图片
dispatch_aysnc(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_LOW),0),^{
  //  加载图片
  NSInteger index = indexPath.row;
  NSString *imagePath = self.imagePaths[index];
  UIImageView *image = [UIImage imageWithContentsOfFile:imagePath];

  //  在主线程显示图片
  dispatch_async(dispatch_get_main_queue(),^{
    if (index == cell.tag){
      imageView.image = image;
    }
  });
});
</code></pre>

<h3>Deferred Decompression</h3>

<p>PNG图片大，但解压快；<br/>
JPEG图片小，但解压慢。<br/>
图片通常在需要绘制前才开始解压。<br/>
[UIImage imageWithName:imageName] 该方法载入图片后即开始解压。<br/>
layer的contents或UIImageView的image。<br/>
ImageIO.framework</p>

<pre><code>NSInteger index = indexPath.row;
NSURL *imageURL = [NSURL fileURLWithPath:self.imagePaths[index]];
NSDictionary *options = @{(__bridge id)kCGImageSourceShouldCache:@YES};
CGImageSourceRef source = CGImageSourceCreateWithURL((__bridge CFURLRef)imageURL,NULL);
CGImageRef imageRef = CGImageSourceCreateImageAtIndex(source,0,(__bridge CFDictionaryRef)options);
UIImage *image = [UIImage imageWithCGImage:imageRef];
CGImageRelease(imageRef);
CFRelease(source);
</code></pre>

<p>NSCache</p>

<h2>Layer Performance</h2>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Export Music From Itunes to Local App's Sandbox on iPhone]]></title>
    <link href="http://sxgfxm.github.io/blog/2017/02/10/export-music-from-itunes-to-local-apps-sandbox-on-iphone/"/>
    <updated>2017-02-10T15:31:20+08:00</updated>
    <id>http://sxgfxm.github.io/blog/2017/02/10/export-music-from-itunes-to-local-apps-sandbox-on-iphone</id>
    <content type="html"><![CDATA[<h2>Introduction</h2>

<p>本文主要介绍app如何获取iTunes中音乐列表，并把iTunes中音乐文件导出至app的沙盒目录下。</p>

<!--more-->


<h2>import</h2>

<p>导入所需的头文件。</p>

<pre><code class="c">#import &lt;AVFoundation/AVAssetExportSession.h&gt;
#import &lt;MediaPlayer/MediaPlayer.h&gt;
</code></pre>

<h2>注册通知</h2>

<p>注册<strong>MPMediaLibraryDidChangeNotification</strong>通知，当iTunes音乐库文件发生变化时，做出响应。</p>

<pre><code class="c">[[NSNotificationCenter defaultCenter]
    addObserver:self
    selector:@selector(mediaLibraryDidChange:)
    name:MPMediaLibraryDidChangeNotification
    object:nil];
</code></pre>

<h2>开启通知</h2>

<p>开启<strong>MPMediaLibrary</strong>通知。</p>

<pre><code class="c">[[MPMediaLibrary defaultMediaLibrary] beginGeneratingLibraryChangeNotifications];
</code></pre>

<h2>关闭通知</h2>

<p>关闭<strong>MPMediaLibrary</strong>通知。</p>

<pre><code class="c">[[MPMediaLibrary defaultMediaLibrary] endGeneratingLibraryChangeNotifications];
</code></pre>

<h2>MPMediaQuery</h2>

<p>通过<strong>MPMediaQuery</strong>获取iTunes中音乐列表，可以自定义列表类型，调用<code>-collection</code>方法，返回对应列表的数组。数组中元素为<strong>MPMediaItemCollection</strong>类型。</p>

<pre><code class="c">//  create
MPMediaQuery *mediaQuery = [MPMediaQuery playlistQuery];
//  groupType
mediaQuery.groupingType = MPMediaGroupingAlbumArtist;
//  query
NSArray&lt;MPMediaItemCollection *&gt; *mediaCollections = [mediaQuery collections];
</code></pre>

<h2>MPMediaItem</h2>

<p>通过<strong>MPMediaItemCollection</strong>获取对应的<strong>MPMediaItem</strong>，对应多媒体文件。通过<strong>MPMediaItem</strong>获取文件相关信息。导出时需要文件地址<strong>assetURL</strong>。</p>

<pre><code class="c">NSMutableArray&lt;MPMediaItem *&gt; mediaItems = [NSMutableArray array];
for (MPMediaItemCollection *collection in mediaCollections) {
  //  mediaItem
  MPMediaItem *mediaItem = [collection representativeItem];
  //  歌曲名称
  NSString *title = [mediaItem valueForProperty:MPMediaItemPropertyTitle];
  //  演唱者
  NSString *artist = [mediaItem valueForProperty:MPMediaItemPropertyArtist];
  //  歌曲封面
  MPMediaItemArtwork *artwork = [mediaItem valueForProperty:MPMediaItemPropertyArtwork];
  //  歌曲格式
  NSString *form = self.assetURL.pathExtension;
  //  歌曲地址，本地iTunes中地址，可用于导出歌曲
  NSURL *assetURL = [mediaItem valueForProperty:MPMediaItemPropertyAssetURL];
  //  add
  [mediaItems addObject:mediaItem];
}
</code></pre>

<h2>Play</h2>

<p>获取到<strong>MPMediaItemCollection</strong>后，可以选择使用iTunes直接播放该文件。</p>

<pre><code class="c">MPMediaItemCollection *mediaItemCollection = [mediaCollections firstObject];
MPMediaItem *selectedItem = [collection representativeItem];
[[MPMusicPlayerController iPodMusicPlayer] setQueueWithItemCollection:mediaItemCollection];
[[MPMusicPlayerController iPodMusicPlayer] setNowPlayingItem:selectedItem];
[[MPMusicPlayerController iPodMusicPlayer] play];
</code></pre>

<h2>Export Music to Local Sandbox</h2>

<p>导出音乐文件至本地沙盒目录下：</p>

<p>1、获取音乐文件名（title）及input地址（<strong>assetURL</strong>）；</p>

<p>2、获取沙盒目录，并创建output地址（<strong>outputURL</strong>）；</p>

<p>3、获取<strong>AVURLAsset</strong>；</p>

<p>4、使用<strong>AVAssetExportSession</strong>导出AVURLAsset。</p>

<pre><code class="c">for (MPMediaItem *musicItem in musicItems) {
    //  获取文件名及地址
    NSString *title = [mediaItem valueForProperty:MPMediaItemPropertyTitle];
    NSURL *assetURL = [mediaItem valueForProperty:MPMediaItemPropertyAssetURL];
    if (assetURL &amp;&amp; [self validIpodLibraryURL:assetURL]) {
      //  创建 output URL，存入沙盒目录下，以文件名为标识
      NSString *pathExtension = assetURL.pathExtension;
      NSArray *paths = NSSearchPathForDirectoriesInDomains(
          NSDocumentDirectory, NSUserDomainMask, YES);
      NSString *documentsDirectory = [paths firstObject];
      NSURL *outputURL =
          [[NSURL fileURLWithPath:[documentsDirectory
                                      stringByAppendingPathComponent:title]]
              URLByAppendingPathExtension:pathExtension];
      //  保证无重复路径
      [[NSFileManager defaultManager] removeItemAtURL:outputURL error:nil];
      //  获取Asset
      NSDictionary *options = [[NSDictionary alloc] init];
      AVURLAsset *asset = [AVURLAsset URLAssetWithURL:assetURL options:options];
      if (asset) {
        //  创建export session
        AVAssetExportSession *exportSession = [[AVAssetExportSession alloc]
            initWithAsset:asset
               presetName:AVAssetExportPresetPassthrough];
        if (exportSession) {
            //  导出类型
            if ([pathExtension compare:@"m4a"] == NSOrderedSame) {
              exportSession.outputFileType = AVFileTypeAppleM4A;
            } else if ([pathExtension compare:@"wav"] == NSOrderedSame) {
              exportSession.outputFileType = AVFileTypeWAVE;
            } else if ([pathExtension compare:@"aif"] == NSOrderedSame) {
              exportSession.outputFileType = AVFileTypeAIFF;
            } else if ([pathExtension compare:@"m4v"] == NSOrderedSame) {
              exportSession.outputFileType = AVFileTypeAppleM4V;
            }
            //  导出地址
            exportSession.outputURL = outputURL;
            //  导出
            [exportSession exportAsynchronouslyWithCompletionHandler:^{
              //  状态回调
              if (completion) {
                switch (exportSession.status) {
                case AVAssetExportSessionStatusFailed:
                  NSLog(@"Failed");
                  break;
                case AVAssetExportSessionStatusCancelled:
                  NSLog(@"Cancelled");
                  break;
                case AVAssetExportSessionStatusCompleted:
                  NSLog(@"Completed");
                  break;
                default:
                  break;
                }
              }
            }];
        }
      }
    }
  }
</code></pre>

<pre><code class="c">- (BOOL)validIpodLibraryURL:(NSURL *)url {
  NSString *IPOD_SCHEME = @"ipod-library";
  if (nil == url)
    return NO;
  if (nil == url.scheme)
    return NO;
  if ([url.scheme compare:IPOD_SCHEME] != NSOrderedSame)
    return NO;
  if ([url.pathExtension compare:@"aif"] != NSOrderedSame &amp;&amp;
      [url.pathExtension compare:@"m4a"] != NSOrderedSame &amp;&amp;
      [url.pathExtension compare:@"wav"] != NSOrderedSame &amp;&amp;
      [url.pathExtension compare:@"m4v"] != NSOrderedSame) {
    return NO;
  }
  return YES;
}
</code></pre>
]]></content>
  </entry>
  
</feed>

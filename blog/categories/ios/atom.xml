<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Ios | Light's Blog]]></title>
  <link href="http://sxgfxm.github.io/blog/categories/ios/atom.xml" rel="self"/>
  <link href="http://sxgfxm.github.io/"/>
  <updated>2016-10-19T11:05:01+08:00</updated>
  <id>http://sxgfxm.github.io/</id>
  <author>
    <name><![CDATA[Light]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[iOS判断GPS坐标是否在中国]]></title>
    <link href="http://sxgfxm.github.io/blog/2016/10/19/iospan-duan-gpszuo-biao-shi-fou-zai-zhong-guo/"/>
    <updated>2016-10-19T10:29:23+08:00</updated>
    <id>http://sxgfxm.github.io/blog/2016/10/19/iospan-duan-gpszuo-biao-shi-fou-zai-zhong-guo</id>
    <content type="html"><![CDATA[<h2>Background</h2>

<p>GPS定位已经深入生活的方方面面。现实生活中存在着多种GPS坐标系：</p>

<ul>
<li><strong>WGS-84坐标系</strong>（World Geodetic System——1984 Coordinate System），国际通用GPS坐标系。</li>
<li><strong>GCJ-02坐标系</strong>（Guojia Cehui Ju Coordinate System），中国专用坐标系，加入随机偏差，俗称火星坐标。</li>
<li><strong>百度坐标系</strong>，百度自己定义的坐标系。</li>
</ul>


<p>在iOS应用开发中，<strong>CoreLocation</strong>返回<strong>WGS坐标</strong>，当定位在中国时，如果直接用<strong>MKMapView</strong>显示位置，由于中国地图使用<strong>GCJ坐标</strong>，会使定位出现偏差，达不到预期效果。为解决这一问题，在显示位置之前，需要判断<strong>WGS坐标</strong>是否在中国，并作出相应的坐标转换。</p>

<p>该问题抽象为<strong>判断点是否在多边形内部</strong>。</p>

<h2>判断点是否在多边形内部算法</h2>

<ul>
<li>面积和判别法：判断目标点与多边形的每条边组成的三角形面积和是否等于该多边形，相等则在多边形内部。</li>
<li>夹角和判别法：判断目标点与所有边的夹角和是否为360度，为360度则在多边形内部。</li>
<li>引射线法：从目标点出发引一条射线，看这条射线和多边形所有边的交点数目。如果有奇数个交点，则说明在内部，如果有偶数个交点，则说明在外部。</li>
</ul>


<p>算法原理在此不再赘述，主要关注算法的实现问题。</p>

<h2>采用引射线法判断GPS坐标是否在中国</h2>

<h4>构造中国大陆轮廓</h4>

<p>因为<strong>GCJ坐标系</strong>不包含港澳台地区，所有选取中国大陆地区的采样点。</p>

<p>本文使用的采样点有限，某些边界可能存在偏差，仅供参考。</p>

<pre><code class="objective-c">//  中国大陆多边形，用于判断坐标是否在中国
//  因为港澳台地区使用WGS坐标，所以多边形不包含港澳台地区
+ (NSMutableArray *)polygonOfChina {
  static NSMutableArray *polygonOfChina = nil;
  static dispatch_once_t onceToken;
  dispatch_once(&amp;onceToken, ^{
    polygonOfChina = [[NSMutableArray alloc] init];
    [polygonOfChina
     addObject:[NSValue valueWithCGPoint:CGPointMake(49.1506690000,
                                                     87.4150810000)]];
    [polygonOfChina
     addObject:[NSValue valueWithCGPoint:CGPointMake(48.3664501790,
                                                     85.7527085300)]];
    [polygonOfChina
     addObject:[NSValue valueWithCGPoint:CGPointMake(47.0253058185,
                                                     85.3847443554)]];
    [polygonOfChina
     addObject:[NSValue valueWithCGPoint:CGPointMake(45.2406550000,
                                                     82.5214000000)]];
    [polygonOfChina
     addObject:[NSValue valueWithCGPoint:CGPointMake(44.8957121295,
                                                     79.9392351487)]];
    [polygonOfChina
     addObject:[NSValue valueWithCGPoint:CGPointMake(43.1166843846,
                                                     80.6751253982)]];
    [polygonOfChina
     addObject:[NSValue valueWithCGPoint:CGPointMake(41.8701690000,
                                                     79.6882160000)]];
    [polygonOfChina
     addObject:[NSValue valueWithCGPoint:CGPointMake(39.2896190000,
                                                     73.6171080000)]];
    [polygonOfChina
     addObject:[NSValue valueWithCGPoint:CGPointMake(34.2303430000,
                                                     78.9155300000)]];
    [polygonOfChina
     addObject:[NSValue valueWithCGPoint:CGPointMake(31.0238860000,
                                                     79.0627080000)]];
    [polygonOfChina
     addObject:[NSValue valueWithCGPoint:CGPointMake(27.9989800000,
                                                     88.7028920000)]];
    [polygonOfChina
     addObject:[NSValue valueWithCGPoint:CGPointMake(27.1793590000,
                                                     88.9972480000)]];
    [polygonOfChina
     addObject:[NSValue valueWithCGPoint:CGPointMake(28.0969170000,
                                                     89.7331400000)]];
    [polygonOfChina
     addObject:[NSValue valueWithCGPoint:CGPointMake(26.9157800000,
                                                     92.1615830000)]];
    [polygonOfChina
     addObject:[NSValue valueWithCGPoint:CGPointMake(28.1947640000,
                                                     96.0986050000)]];
    [polygonOfChina
     addObject:[NSValue valueWithCGPoint:CGPointMake(27.4094760000,
                                                     98.6742270000)]];
    [polygonOfChina
     addObject:[NSValue valueWithCGPoint:CGPointMake(23.9085500000,
                                                     97.5703890000)]];
    [polygonOfChina
     addObject:[NSValue valueWithCGPoint:CGPointMake(24.0775830000,
                                                     98.7846100000)]];
    [polygonOfChina
     addObject:[NSValue valueWithCGPoint:CGPointMake(22.1375640000,
                                                     99.1893510000)]];
    [polygonOfChina
     addObject:[NSValue valueWithCGPoint:CGPointMake(21.1398950000,
                                                     101.7649720000)]];
    [polygonOfChina
     addObject:[NSValue valueWithCGPoint:CGPointMake(22.2746220000,
                                                     101.7281780000)]];
    [polygonOfChina
     addObject:[NSValue valueWithCGPoint:CGPointMake(23.2641940000,
                                                     105.3708430000)]];
    [polygonOfChina
     addObject:[NSValue valueWithCGPoint:CGPointMake(22.7191200000,
                                                     106.6954480000)]];
    [polygonOfChina
     addObject:[NSValue valueWithCGPoint:CGPointMake(21.9945711661,
                                                     106.7256731791)]];
    [polygonOfChina
     addObject:[NSValue valueWithCGPoint:CGPointMake(21.4847050000,
                                                     108.0200530000)]];
    [polygonOfChina
     addObject:[NSValue valueWithCGPoint:CGPointMake(20.4478440000,
                                                     109.3814530000)]];
    [polygonOfChina
     addObject:[NSValue valueWithCGPoint:CGPointMake(18.6689850000,
                                                     108.2408210000)]];
    [polygonOfChina
     addObject:[NSValue valueWithCGPoint:CGPointMake(17.4017340000,
                                                     109.9333720000)]];
    [polygonOfChina
     addObject:[NSValue valueWithCGPoint:CGPointMake(19.5085670000,
                                                     111.4051560000)]];
    [polygonOfChina
     addObject:[NSValue valueWithCGPoint:CGPointMake(21.2716775175,
                                                     111.2514995205)]];
    [polygonOfChina
     addObject:[NSValue valueWithCGPoint:CGPointMake(21.9936323233,
                                                     113.4625292629)]];
    [polygonOfChina
     addObject:[NSValue valueWithCGPoint:CGPointMake(22.1818312942,
                                                     113.4258358111)]];
    [polygonOfChina
     addObject:[NSValue valueWithCGPoint:CGPointMake(22.2249729295,
                                                     113.5913115000)]];
    [polygonOfChina
     addObject:[NSValue valueWithCGPoint:CGPointMake(22.4501912753,
                                                     113.8946844490)]];
    [polygonOfChina
     addObject:[NSValue valueWithCGPoint:CGPointMake(22.5959159322,
                                                     114.3623797842)]];
    [polygonOfChina
     addObject:[NSValue valueWithCGPoint:CGPointMake(22.4334610000,
                                                     114.5194740000)]];
    [polygonOfChina
     addObject:[NSValue valueWithCGPoint:CGPointMake(22.9680954377,
                                                     116.8326939975)]];
    [polygonOfChina
     addObject:[NSValue valueWithCGPoint:CGPointMake(25.3788220000,
                                                     119.9667980000)]];
    [polygonOfChina
     addObject:[NSValue valueWithCGPoint:CGPointMake(28.3261276204,
                                                     121.7724402562)]];
    [polygonOfChina
     addObject:[NSValue valueWithCGPoint:CGPointMake(31.9883610000,
                                                     123.8808230000)]];
    [polygonOfChina
     addObject:[NSValue valueWithCGPoint:CGPointMake(39.8759700000,
                                                     124.4695370000)]];
    [polygonOfChina
     addObject:[NSValue valueWithCGPoint:CGPointMake(41.7350890000,
                                                     126.9531720000)]];
    [polygonOfChina
     addObject:[NSValue valueWithCGPoint:CGPointMake(41.5142160000,
                                                     128.3145720000)]];
    [polygonOfChina
     addObject:[NSValue valueWithCGPoint:CGPointMake(42.9842081790,
                                                     131.0676468344)]];
    [polygonOfChina
     addObject:[NSValue valueWithCGPoint:CGPointMake(45.2690810000,
                                                     131.8468530000)]];
    [polygonOfChina
     addObject:[NSValue valueWithCGPoint:CGPointMake(45.0608370000,
                                                     133.0610740000)]];
    [polygonOfChina
     addObject:[NSValue valueWithCGPoint:CGPointMake(48.4480260000,
                                                     135.0111880000)]];
    [polygonOfChina
     addObject:[NSValue valueWithCGPoint:CGPointMake(48.0054800000,
                                                     131.6628800000)]];
    [polygonOfChina
     addObject:[NSValue valueWithCGPoint:CGPointMake(50.2270740000,
                                                     127.6890640000)]];
    [polygonOfChina
     addObject:[NSValue valueWithCGPoint:CGPointMake(53.3516070000,
                                                     125.3710040000)]];
    [polygonOfChina
     addObject:[NSValue valueWithCGPoint:CGPointMake(53.4176040000,
                                                     119.9254040000)]];
    [polygonOfChina
     addObject:[NSValue valueWithCGPoint:CGPointMake(47.5590810000,
                                                     115.1421070000)]];
    [polygonOfChina
     addObject:[NSValue valueWithCGPoint:CGPointMake(47.1339370000,
                                                     119.1159230000)]];
    [polygonOfChina
     addObject:[NSValue valueWithCGPoint:CGPointMake(44.8256460000,
                                                     111.2786750000)]];
    [polygonOfChina
     addObject:[NSValue valueWithCGPoint:CGPointMake(42.5293560000,
                                                     109.2549720000)]];
    [polygonOfChina
     addObject:[NSValue valueWithCGPoint:CGPointMake(43.2598160000,
                                                     97.2967290000)]];
    [polygonOfChina
     addObject:[NSValue valueWithCGPoint:CGPointMake(45.4247620000,
                                                     90.9680590000)]];
    [polygonOfChina
     addObject:[NSValue valueWithCGPoint:CGPointMake(47.8075570000,
                                                     90.6737020000)]];
    [polygonOfChina
     addObject:[NSValue valueWithCGPoint:CGPointMake(49.1506690000,
                                                     87.4150810000)]];
  });
  return polygonOfChina;
}
</code></pre>

<h4>采用引射线法判断</h4>

<pre><code class="objective-c">/**
 *  判断是不是在中国
 *  用引射线法判断 点是否在多边形内部
 *  算法参考：http://www.cnblogs.com/luxiaoxun/p/3722358.html
 */
+ (BOOL)isLocationOutOfChina:(CLLocationCoordinate2D)location {
  CGPoint point = CGPointMake(location.latitude, location.longitude);
  BOOL oddFlag = NO;
  NSInteger j = [self polygonOfChina].count - 1;
  for (NSInteger i = 0; i &lt; [self polygonOfChina].count; i++) {
    CGPoint polygonPointi = [[self polygonOfChina][i] CGPointValue];
    CGPoint polygonPointj = [[self polygonOfChina][j] CGPointValue];
    if (((polygonPointi.y &lt; point.y &amp;&amp; polygonPointj.y &gt;= point.y) ||
         (polygonPointj.y &lt; point.y &amp;&amp; polygonPointi.y &gt;= point.y)) &amp;&amp;
        (polygonPointi.x &lt;= point.x || polygonPointj.x &lt;= point.x)) {
      oddFlag ^= (polygonPointi.x +
                  (point.y - polygonPointi.y) /
                  (polygonPointj.y - polygonPointi.y) *
                  (polygonPointj.x - polygonPointi.x) &lt;
                  point.x);
    }
    j = i;
  }
  return !oddFlag;
}
</code></pre>

<h4>测试结果</h4>

<p> <img src="../images/Map/result.png" alt="result" /></p>

<p>如上图所示，红色多边形为所构造的中国大陆轮廓。随机生成经纬度坐标进行测试，如果在中国，标记为红色；如果不在中国，标记为蓝色。</p>

<h2>参考资料</h2>

<p><a href="http://www.cnblogs.com/luxiaoxun/p/3722358.html">阿凡卢博客</a></p>

<p><a href="https://github.com/TinyQ/TQLocationConverter">Github源码地址</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[UICollectionView iOS 10 New Features]]></title>
    <link href="http://sxgfxm.github.io/blog/2016/10/18/uicollectionview-ios10-new-features/"/>
    <updated>2016-10-18T20:01:45+08:00</updated>
    <id>http://sxgfxm.github.io/blog/2016/10/18/uicollectionview-ios10-new-features</id>
    <content type="html"><![CDATA[<h2>Background</h2>

<p>iPhone屏幕的刷新频率固定为60fps，为了达到流畅的滑动效果，iOS应用展示必须满足该条件。当帧率很低时，就会出现明显的卡顿现象。</p>

<p>60fps相当于每帧16.67毫秒，在这么短的时间内collection view可能并不能完成从相对较慢的数据源加载数据。为了提升collection view性能，一个常用的技巧是使<code>cellForItemAtIndexPath</code>尽可能快的返回cell，比如异步加载网络图片等。为了进一步提高collection view性能，并且尽量减少开发者的工作，在iOS 10中引入了新特性。</p>

<h2>UICollectionView API变化</h2>

<h4>新增UICollectionViewDataSourcePrefetching协议</h4>

<pre><code class="objective-c">@protocol UICollectionViewDataSourcePrefetching &lt;NSObject&gt;

@required
// indexPaths are ordered ascending by geometric distance from the collection view
- (void)collectionView:(UICollectionView *)collectionView prefetchItemsAtIndexPaths:(NSArray&lt;NSIndexPath *&gt; *)indexPaths NS_AVAILABLE_IOS(10_0);

@optional
// indexPaths that previously were considered as candidates for pre-fetching, but were not actually used; may be a subset of the previous call to -collectionView:prefetchItemsAtIndexPaths:
- (void)collectionView:(UICollectionView *)collectionView cancelPrefetchingForItemsAtIndexPaths:(NSArray&lt;NSIndexPath *&gt; *)indexPaths  NS_AVAILABLE_IOS(10_0);

@end
</code></pre>

<p>这两个方法均异步执行，可用于异步加载图片等。</p>

<h4>新增prefetchDataSource代理</h4>

<pre><code class="objective-c">@property (nonatomic, weak, nullable) id&lt;UICollectionViewDataSourcePrefetching&gt; prefetchDataSource NS_AVAILABLE_IOS(10_0);
</code></pre>

<h4>新增prefetchingEnabled属性</h4>

<pre><code class="objective-c">@property (nonatomic, getter=isPrefetchingEnabled) BOOL prefetchingEnabled NS_AVAILABLE_IOS(10_0);
</code></pre>

<h2>Prefetching</h2>

<p>当collection view滑动速率将要超过<code>cellForItemAtIndexPath</code>返回cell的速率时，collection view会调用<code>prefetchItemAtIndexPaths:</code>方法。</p>

<p>collection view会把<strong>可能</strong>即将需要展示的cell的IndexPath放入数组中传递给prefetch方法。这为我们提供了预处理数据机会。比如，当我们需要加载网络图片时，可以在prefetch方法中请求网络数据，并把下载的数据插入到<strong>data source</strong>中，为<code>cellForItemAtIndexPath</code>的使用做准备。</p>

<p>当collection view滑动方向改变时，collection view会调用<code>cancelPrefetchingForItemsAtIndexPaths</code>方法。</p>

<p>该方法的目的是取消<strong>原本可能</strong>即将展示的cell的预加载数据工作。参数同样是IndexPath的数组。</p>

<h2>UICollectionView Cell生命周期变化</h2>

<h4>UICollectionViewCell Lifecycle: iOS &lt;= 9</h4>

<p> <img src="../images/UICollectionViewCell/UICollectionViewLifecycle_iOS_9.jpeg" alt="UICollectionViewLifecycle_iOS_9" /></p>

<ol>
<li>首先，调用<code>cellForItemAtIndexPath:</code>，从复用队列中弹出一个<strong>cell</strong>，准备对其调用<code>prepareForReuse</code>。</li>
<li>然后，根据需求设置<strong>cell</strong>的内容，比如<strong>labels</strong>等。</li>
<li>当<strong>cell</strong>即将出现时，调用<code>collectionView:willDisplayCell:forItemAtindexPath:</code>。</li>
<li>当<strong>cell</strong>消失时，调用<code>collectionView:didEndDisplayingCell:forItemAtIndexPath:</code>。此时<strong>cell</strong>会重新进入复用队列，等待复用。</li>
<li>当用户向相反方向再次把<strong>cell</strong>滑回屏幕时，会重新从第一步开始执行。</li>
</ol>


<h4>UICollectionViewCell Lifecycle: iOS 10</h4>

<p> <img src="../images/UICollectionViewCell/UICollectionViewLifecycle_iOS_10.jpeg" alt="UICollectionViewLifecycle_iOS_10" /></p>

<p>在iOS 10中，前3个步骤与iOS 9是相同的，新的变化发生在<strong>cell</strong>滑出屏幕的时候。</p>

<p>当调用<code>collectionView:didEndDisplayingCell:forItemAtIndexPath:</code>后，<strong>cell</strong>不会立刻进入复用队列，系统会<strong>keeps it around for a bit</strong>。相当于会缓存该<strong>cell</strong>一小段时间，在这段时间内如果该<strong>cell</strong>再次回到屏幕中，便不会重新调用<code>cellForItemAtIndexPath:</code>，而是直接显示。</p>

<p>至于系统会缓存多久，官方并没有给出明确的时间，感觉跟程序运行时开销有关。</p>

<p>如果想关闭该功能，需要设置<code>collectionView.prefetchingEnabled = NO;</code>。</p>

<p> <img src="../images/UICollectionViewCell/multiple_cells.jpeg" alt="multiple_cells" /></p>

<p>collection view包含多列的情况，主要体现cell的<strong>独立性</strong>。</p>

<p>当某一行需要展示时，每个cell独立出队并调用<code>cellForItemAtIndexPath:</code>方法；</p>

<p>当该行即将展示时，每个cell调用<code>willDisplayCell:atIndexPath:</code>。</p>

<h2>总结</h2>

<ul>
<li>这些变化对开发者都是透明的，对开发者来说只需利用好prefetch特性。</li>
<li>prefetch进一步提升了collection view的性能，尤其是获取cell数据开销比较大或者比较慢时。</li>
<li>每个cell独立出队，单独设置，确保cell在展示之前总是ready。</li>
<li>UITableView拥有相同的新特性。</li>
</ul>


<h2>参考资料：</h2>

<p><a href="https://developer.apple.com/videos/play/wwdc2016/219/">WWDC2016 UICollectionView相关视频</a></p>

<p><a href="https://adoptioncurve.net/archives/2016/06/collection-view-updates-in-ios10/">Adoption Curve Dot Net</a></p>

<p><a href="https://littlebitesofcocoa.com/241-uicollectionview-cell-pre-fetching">little bites of cocoa</a></p>
]]></content>
  </entry>
  
</feed>

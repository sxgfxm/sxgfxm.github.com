<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Ios | Light's Blog]]></title>
  <link href="http://sxgfxm.github.io/blog/categories/ios/atom.xml" rel="self"/>
  <link href="http://sxgfxm.github.io/"/>
  <updated>2016-10-25T20:18:20+08:00</updated>
  <id>http://sxgfxm.github.io/</id>
  <author>
    <name><![CDATA[Light]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[XGChart_README]]></title>
    <link href="http://sxgfxm.github.io/blog/2016/10/25/xgchart-readme/"/>
    <updated>2016-10-25T19:52:46+08:00</updated>
    <id>http://sxgfxm.github.io/blog/2016/10/25/xgchart-readme</id>
    <content type="html"><![CDATA[<h2>Introduction</h2>

<p><a href="https://github.com/sxgfxm/XGChart">XGChart</a>是一个简洁的iOS 图表库，可以快速集成自定义折线图，曲线图和条形图。</p>

<!-- more -->


<h2>Install</h2>

<p>首先，下载<strong>XGChart</strong>，将<strong>XGChart</strong>文件夹拖入工程。</p>

<p><img src="http://ofj92itlz.bkt.clouddn.com/XGChart:import2.jpeg" alt="import" /></p>

<p>然后，导入<strong>XGChart.h</strong>头文件，配置参数，创建即可。</p>

<pre><code class="objective-c">#import "XGChart.h"
</code></pre>

<pre><code class="objective-c"> //  configuration
  XGChartConfiguration *configuration = [[XGChartConfiguration alloc] init];
  configuration.chartType = XGChartTypeLineChart;
  configuration.paddingTop = 20;
  configuration.paddingLeft = 20;
  configuration.paddingBottom = 20;
  configuration.paddingRight = 20;
  configuration.xGridCount = 3;
  configuration.yGridCount = 4;
  configuration.gridColor = [UIColor grayColor];
  configuration.xAxisLabelColor = [UIColor whiteColor];
  configuration.xAxisLabelFontSize = 12;
  configuration.yAxisLabelColor = [UIColor whiteColor];
  configuration.yAxisLabelFontSize = 12;
  NSMutableArray&lt;XGChartPoint *&gt; *chartPoints = [[NSMutableArray alloc] init];
  for (int i = 1; i &lt; 31; i++) {
    XGChartPoint *point =
        [[XGChartPoint alloc] initWithX:i andY:arc4random_uniform(100)];
    [chartPoints addObject:point];
  }
  configuration.chartPoints = chartPoints;
  configuration.strokeColor = [UIColor redColor];
  configuration.fillColor = [UIColor redColor];
  configuration.lineWidth = 3;
  //  line chart
  XGChart *lineChart = [[XGChart alloc]
      initWithFrame:CGRectMake(0, 64, self.view.bounds.size.width,
                               (self.view.bounds.size.height - 64) / 3)
      configuration:configuration];
  lineChart.backgroundColor = [UIColor blackColor];
  [self.view addSubview:lineChart];
</code></pre>

<h2>Result</h2>

<p><img src="http://ofj92itlz.bkt.clouddn.com/XGChart:result2.png" alt="" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ShareSDK接入]]></title>
    <link href="http://sxgfxm.github.io/blog/2016/10/21/sharesdkjie-ru/"/>
    <updated>2016-10-21T14:12:36+08:00</updated>
    <id>http://sxgfxm.github.io/blog/2016/10/21/sharesdkjie-ru</id>
    <content type="html"><![CDATA[<h2>iOS接入ShareSDK实现第三方分享</h2>

<p>因为<strong>友盟</strong>被阿里收购在Android平台的各种令人不悦的后台操作，改用<strong>ShareSDK</strong>实现第三方分享。以下为简单接入流程。详情可参考官方文档<a href="http://wiki.mob.com/ios%E7%AE%80%E6%B4%81%E7%89%88%E5%BF%AB%E9%80%9F%E9%9B%86%E6%88%90/">http://wiki.mob.com/ios%E7%AE%80%E6%B4%81%E7%89%88%E5%BF%AB%E9%80%9F%E9%9B%86%E6%88%90/</a></p>

<!--more-->


<h2>获取AppKey</h2>

<p>在官网注册，并按要求创建应用，获取AppKey，比如为<strong>182947e7afac0</strong>。</p>

<h2>下载所需版本的ShareSDK</h2>

<p>解压后，将<strong>ShareSDK</strong>导入工程中，记得勾选<strong>Copy items into destination group&rsquo;s folder(if needed)</strong>。</p>

<h2>添加依赖库</h2>

<pre><code>//  ShareSDK
libicucore.dylib
libz.dylib
libstdc++.dylib
JavaScriptCore.framework

//  新浪微博SDK
ImageIO.framework
libsqlite3.dylib

//  QQ空间SDK
libsqlite3.dylib

//  微信SDK
libsqlite3.dylib

//  根据需要添加
</code></pre>

<h2>初始化对应的第三方平台</h2>

<p>在<strong>AppDelegate.m</strong>中，导入所需头文件。</p>

<pre><code class="objective-c">#import &lt;ShareSDK/ShareSDK.h&gt;
#import &lt;ShareSDKConnector/ShareSDKConnector.h&gt;

//腾讯开放平台（对应QQ和QQ空间）SDK头文件
#import &lt;TencentOpenAPI/TencentOAuth.h&gt;
#import &lt;TencentOpenAPI/QQApiInterface.h&gt;

//微信SDK头文件
#import "WXApi.h"

//新浪微博SDK头文件
#import "WeiboSDK.h"
//新浪微博SDK需要在项目Build Settings中的Other Linker Flags添加"-ObjC"
</code></pre>

<p>在<code>application:didFinishLaunchingWithOptions:</code>方法中初始化。</p>

<pre><code class="objective-c">- (BOOL)application:(UIApplication *)application
    didFinishLaunchingWithOptions:(NSDictionary *)launchOptions {

  /**
   *  设置ShareSDK的appKey，如果尚未在ShareSDK官网注册过App，请移步到http://mob.com/login
   * 登录后台进行应用注册
   *  在将生成的AppKey传入到此方法中。
   *  方法中的第二个第三个参数为需要连接社交平台SDK时触发，
   *  在此事件中写入连接代码。第四个参数则为配置本地社交平台时触发，根据返回的平台类型来配置平台信息。
   *  如果您使用的时服务端托管平台信息时，第二、四项参数可以传入nil，第三项参数则根据服务端托管平台来决定要连接的社交SDK。
   */
  [ShareSDK registerApp:@"182947e7afac0"

      activePlatforms:@[
        @(SSDKPlatformTypeSinaWeibo),
        @(SSDKPlatformTypeWechat),
        @(SSDKPlatformTypeQQ),
      ]
      onImport:^(SSDKPlatformType platformType) {
        switch (platformType) {
        case SSDKPlatformTypeWechat:
          [ShareSDKConnector connectWeChat:[WXApi class]];
          break;
        case SSDKPlatformTypeQQ:
          [ShareSDKConnector connectQQ:[QQApiInterface class]
                     tencentOAuthClass:[TencentOAuth class]];
          break;
        case SSDKPlatformTypeSinaWeibo:
          [ShareSDKConnector connectWeibo:[WeiboSDK class]];
          break;
        default:
          break;
        }
      }
      onConfiguration:^(SSDKPlatformType platformType,
                        NSMutableDictionary *appInfo) {

        switch (platformType) {
        case SSDKPlatformTypeSinaWeibo:
          //设置新浪微博应用信息,其中authType设置为使用SSO＋Web形式授权
          [appInfo
              SSDKSetupSinaWeiboByAppKey:@"3144028685"
                               appSecret:@"11abfe456bc8eefbab49fe7bbcd90bf0"
                             redirectUri:@"http://www.sharesdk.cn"
                                authType:SSDKAuthTypeBoth];
          break;
        case SSDKPlatformTypeWechat:
          [appInfo SSDKSetupWeChatByAppId:@"wx4868b35061f87885"
                                appSecret:@"64020361b8ec4c99936c0e3999a9f249"];
          break;
        case SSDKPlatformTypeQQ:
          [appInfo SSDKSetupQQByAppId:@"100371282"
                               appKey:@"aed9b0303e3ed1e27bae87c33761161d"
                             authType:SSDKAuthTypeBoth];
          break;
        default:
          break;
        }
      }];
  return YES;
}
</code></pre>

<p>接入不同的平台均需要注册并获取<strong>AppKey</strong>和<strong>AppSecret</strong>值。</p>

<h2>添加分享实现代码</h2>

<p>在<strong>ViewController.m</strong>中触发分享的方法中，添加分享代码。</p>

<pre><code class="objective-c">- (void)shareAction {
  [self.tf endEditing:YES];
  // 1、创建分享参数
  NSArray *imageArray = @[ [UIImage imageNamed:@"junxi5.jpg"] ];
  if (imageArray) {

    NSMutableDictionary *shareParams = [NSMutableDictionary dictionary];
    [shareParams SSDKSetupShareParamsByText:self.tf.text
                                     images:imageArray
                                        url:nil
                                      title:@"Ticwatch Sport"
                                       type:SSDKContentTypeAuto];
    // 2、分享（可以弹出我们的分享菜单和编辑界面）
    [ShareSDK showShareActionSheet:nil
                             items:nil
                       shareParams:shareParams
               onShareStateChanged:^(
                   SSDKResponseState state, SSDKPlatformType platformType,
                   NSDictionary *userData, SSDKContentEntity *contentEntity,
                   NSError *error, BOOL end) {

                 switch (state) {
                 case SSDKResponseStateSuccess: {
                   NSLog(@"分享成功");
                   break;
                 }
                 case SSDKResponseStateFail: {
                   NSLog(@"分享失败");
                   NSLog(@"%@", error);
                   break;
                 }
                 default:
                   break;
                 }
               }];
  }
}
</code></pre>

<h2>添加URL Schemes</h2>

<p> <img src="http://ofj92itlz.bkt.clouddn.com/ShareSDK:WhiteList.jpeg" alt="urlscheme" /></p>

<h2>适配iOS 9问题</h2>

<h3>退回http协议，并设置域</h3>

<p><img src="http://ofj92itlz.bkt.clouddn.com/ShareSDK:Https.jpeg" alt="http" /></p>

<h3>添加scheme白名单</h3>

<p><img src="http://ofj92itlz.bkt.clouddn.com/ShareSDK:UrlScheme.jpeg" alt="白名单" /></p>

<h2>分享平台title为英文问题</h2>

<p>默认语言为英文，需要在项目中添加中文本地化。</p>

<p><img src="http://ofj92itlz.bkt.clouddn.com/ShareSDK:Localization.jpeg" alt="localization" /></p>

<p>如需修改标题可以修改对应的本地化文件。</p>

<p> <img src="http://ofj92itlz.bkt.clouddn.com/ShareSDK:CustomLocalization.jpeg" alt="customLocalization" /></p>

<h2>Github源码</h2>

<p><a href="https://github.com/sxgfxm/ShareSDKDemo">ShareSDKDemo</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[3D Touch]]></title>
    <link href="http://sxgfxm.github.io/blog/2016/10/20/3d-touch/"/>
    <updated>2016-10-20T15:51:27+08:00</updated>
    <id>http://sxgfxm.github.io/blog/2016/10/20/3d-touch</id>
    <content type="html"><![CDATA[<h2>3D Touch简介</h2>

<p>3D Touch是智能手机领域最先进技术之一，目前只有Apple在iPhone上构建了相对良好的生态，并在最新推出的iOS 10中进一步优化了用户体验，Android系统和手机厂商还未提供较为成熟的支持。 本文主要介绍3D Touch相关技术的基本实现方法，包括：</p>

<p>1、Home Screen Quick Actions，主屏幕快捷访问；</p>

<p>2、Peek and Pop，预览和进入；</p>

<p>3、3D Touch Force，3D touch压力值运用。</p>

<!--more-->


<h2>Home Screen Quick Action</h2>

<h3>显示效果</h3>

<p>在主屏幕按下应用图标，会弹出设定好的快捷访问入口。本文采用纯代码创建，也可以通过设置Info.plist实现。</p>

<h3>代码实现</h3>

<p>首先，在<strong>AppDelegate.m</strong>的<code>application:didFinishLaunchingWithOptions:</code>方法中添加<strong>UIApplicationShortcutItems</strong>。</p>

<pre><code class="objective-c">- (BOOL)application:(UIApplication *)application
    didFinishLaunchingWithOptions:(NSDictionary *)launchOptions {
  // Override point for customization after application launch.
  //  主界面入口
  ViewController *vc = [[ViewController alloc] init];
  self.mainNav = [[UINavigationController alloc] initWithRootViewController:vc];
  self.window.rootViewController = self.mainNav;

  //  创建快捷访问Items
  UIApplicationShortcutIcon *icon1 = [UIApplicationShortcutIcon
      iconWithType:UIApplicationShortcutIconTypeTask];
  UIApplicationShortcutItem *item1 =
      [[UIApplicationShortcutItem alloc] initWithType:@"item1"
                                       localizedTitle:@"item1"
                                    localizedSubtitle:@"1"
                                                 icon:icon1
                                             userInfo:nil];
  UIApplicationShortcutIcon *icon2 = [UIApplicationShortcutIcon
      iconWithType:UIApplicationShortcutIconTypeMail];
  UIApplicationShortcutItem *item2 =
      [[UIApplicationShortcutItem alloc] initWithType:@"item2"
                                       localizedTitle:@"item2"
                                    localizedSubtitle:@"2"
                                                 icon:icon2
                                             userInfo:nil];
  //  添加快捷访问Items
  application.shortcutItems = @[ item1, item2 ];
  return YES;
}
</code></pre>

<p>然后，在<strong>AppDelegate.m</strong>中添加如下方法，用于响应快捷访问事件。</p>

<pre><code class="objective-c">- (void)application:(UIApplication *)application
    performActionForShortcutItem:(UIApplicationShortcutItem *)shortcutItem
               completionHandler:(void (^)(BOOL))completionHandler {
  //  响应Item对应的操作，跳转至对应controller
  if ([shortcutItem.type isEqualToString:@"item1"]) {
    Item1ViewController *vc = [[Item1ViewController alloc] init];
    [self.mainNav pushViewController:vc animated:YES];
  }
  if ([shortcutItem.type isEqualToString:@"item2"]) {
    Item2ViewController *vc = [[Item2ViewController alloc] init];
    [self.mainNav pushViewController:vc animated:YES];
  }
}
</code></pre>

<p>运行效果：</p>

<p> <img src="http://ofj92itlz.bkt.clouddn.com/3DTouch:step1.jpeg" alt="step1" /></p>

<h2>Peek and Pop</h2>

<p>3D Touch按压力度可以分为两级，一级力度触发<strong>peek</strong>，二级力度触发<strong>pop</strong>。</p>

<p><strong>peek</strong>相当于<strong>预览</strong>与按压view相关的<strong>view controller</strong>。<strong>pop</strong>相当于<strong>跳转</strong>至对应的<strong>view controller</strong>。</p>

<h3>为view添加3D Touch响应</h3>

<p>本文以UIImageView为例，实现图片的预览效果。</p>

<pre><code class="objective-c">  //  创建ImageView
  self.imageView = [[UIImageView alloc]
      initWithFrame:CGRectMake(self.view.bounds.size.width / 2 - 50, 300, 100,
                               100)];
  self.imageView.image = [UIImage imageNamed:@"junxi3.jpeg"];
  //  非常重要
  self.imageView.userInteractionEnabled = YES;
  [self.view addSubview:self.imageView];
  //  添加3D Touch 响应
  if (self.traitCollection.forceTouchCapability ==
      UIForceTouchCapabilityAvailable) {
    [self registerForPreviewingWithDelegate:self sourceView:self.imageView];
  } else {
    NSLog(@"您的设备不支持3D Touch");
  }
</code></pre>

<p>通过<strong>UIViewController</strong>的 <code>registerForPreviewingWithDelegate:sourceView:</code>方法添加3D Touch响应。需要遵守<strong>UIViewControllerPreviewingDelegate</strong>协议，并实现分别对应<strong>peek</strong>和<strong>pop</strong>的代理方法。</p>

<p>注意，添加3D Touch响应的view，一定要使<strong>userInteractionEnabled = YES</strong>，否则无法响应。</p>

<h3>peek相关代理方法实现</h3>

<p>实现代理方法<code>previewingContext:viewControllerForLocation:</code>，在该代理方法中创建并返回待预览的<strong>view controller</strong>。</p>

<pre><code class="objective-c">//  peek
- (UIViewController *)previewingContext:
                          (id&lt;UIViewControllerPreviewing&gt;)previewingContext
              viewControllerForLocation:(CGPoint)location {
  //  log信息
  NSLog(@"peek");
  NSLog(@"point %@", NSStringFromCGPoint(location));
  NSLog(@"rect %@", NSStringFromCGRect(previewingContext.sourceRect));
  //  创建待预览view controller
  PreviewViewController *previewVC = [[PreviewViewController alloc] init];
  //  设置大小
  previewVC.preferredContentSize = CGSizeMake(0.0f, 0.0f);
  //  设置内容
  previewVC.image = self.imageView.image;
  //  设置高亮显示区域，其他区域会模糊显示
  previewingContext.sourceRect = self.imageView.frame;
  //  返回待预览view controller
  return previewVC;
}
</code></pre>

<p>其中，previewingContext.sourceRect用于设置高亮区域，location为点击手势在view中的位置，preferredContentSize用于设置预览区域大小，为0时系统会设为最佳显示大小。</p>

<p>运行效果：</p>

<p><img src="http://ofj92itlz.bkt.clouddn.com/3DTouch:step2.jpeg" alt="step2" />      <img src="http://ofj92itlz.bkt.clouddn.com/3DTouch:step3.jpeg" alt="step3" /></p>

<h3>在PreviewViewController中添加预览状态快捷选项</h3>

<p>在<strong>peek</strong>状态下，向上滑动，即可弹出快捷选项。</p>

<pre><code class="objective-c">- (NSArray&lt;id&lt;UIPreviewActionItem&gt;&gt; *)previewActionItems {
  // setup a list of preview actions
  UIPreviewAction *action1 = [UIPreviewAction
      actionWithTitle:@"Aciton1"
                style:UIPreviewActionStyleDefault
              handler:^(UIPreviewAction *_Nonnull action,
                        UIViewController *_Nonnull previewViewController) {
                NSLog(@"Aciton1");
              }];

  UIPreviewAction *action2 = [UIPreviewAction
      actionWithTitle:@"Aciton2"
                style:UIPreviewActionStyleDefault
              handler:^(UIPreviewAction *_Nonnull action,
                        UIViewController *_Nonnull previewViewController) {
                NSLog(@"Aciton2");
              }];

  UIPreviewAction *action3 = [UIPreviewAction
      actionWithTitle:@"Aciton3"
                style:UIPreviewActionStyleDefault
              handler:^(UIPreviewAction *_Nonnull action,
                        UIViewController *_Nonnull previewViewController) {
                NSLog(@"Aciton3");
              }];

  NSArray *actions = @[ action1, action2, action3 ];
  return actions;
}
</code></pre>

<p>运行效果：</p>

<p> <img src="http://ofj92itlz.bkt.clouddn.com/3DTouch:step5.jpeg" alt="step4" /></p>

<h3>pop相关代理方法</h3>

<p>实现代理方法<code>previewingContext:commitViewController:</code>，在该代理方法中跳转。</p>

<pre><code class="objective-c">//  pop
- (void)previewingContext:(id&lt;UIViewControllerPreviewing&gt;)previewingContext
     commitViewController:(UIViewController *)viewControllerToCommit {
  //  log信息
  NSLog(@"pop");
  //  跳转至对应view controller
  [self showViewController:viewControllerToCommit sender:self];
}
</code></pre>

<p>运行效果：</p>

<p> <img src="http://ofj92itlz.bkt.clouddn.com/3DTouch:step4.jpeg" alt="step5" /></p>

<h2>3D Touch Force简单运用</h2>

<p>在<code>touchesMoved:withEvent:</code>方法中，获取touch对象，可以根据force属性值做相应操作。</p>

<pre><code class="objective-c">- (void)touchesMoved:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event {
  NSArray *arrayTouch = [touches allObjects];
  UITouch *touch = (UITouch *)[arrayTouch lastObject];
  NSLog(@"force = %f", touch.force);
}
</code></pre>

<h2>参考资料</h2>

<p><a href="https://developer.apple.com/library/content/documentation/UserExperience/Conceptual/Adopting3DTouchOniPhone/#//apple_ref/doc/uid/TP40016543-CH1-SW1">Adopting 3D Touch on iPhone</a></p>

<p><a href="http://www.tuicool.com/articles/auIJbiN">iOS9新特性 3DTouch 开发教程全解</a></p>

<h3>Github源码</h3>

<p><a href="https://github.com/sxgfxm/3DTouchDemo">3DTouchDemo</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Today Extension - Widget]]></title>
    <link href="http://sxgfxm.github.io/blog/2016/10/19/today-extension-widget/"/>
    <updated>2016-10-19T21:05:18+08:00</updated>
    <id>http://sxgfxm.github.io/blog/2016/10/19/today-extension-widget</id>
    <content type="html"><![CDATA[<h2>Widget简介</h2>

<p>从iOS 8开始，引入<strong>widget</strong>特性。可以在通知中心的<strong>Today</strong>栏中添加widget。widget可以简单理解为一个小的扩展程序，可以展示相关应用的简略信息，提供快捷访问等功能。</p>

<p>widget的概念在Android中已经十分成熟，iOS widget与自由度相当高的Android widget有显著的区别。iOS widget的刷新时间为展示widget时，而不是像Android widget时刻保持在后台，消耗系统资源。iOS widget只是作为很小的配角存在，Apple的中心思想还是希望开发者关注App本身的设计和性能。</p>

<p>尽管iOS widget是一种约束状态下的自由，但已经逐渐改变用户的交互行为。</p>

<!--more-->


<h2>创建Widget</h2>

<p>1、创建工程；</p>

<p>2、为工程添加新<strong>Target</strong>，并选择<strong>Today Extension</strong>模板；</p>

<p><img src="http://ofj92itlz.bkt.clouddn.com/Widget:step1.jpeg" alt="step1" /> <img src="http://ofj92itlz.bkt.clouddn.com/Widget:step2.jpeg" alt="stept" /></p>

<p> <img src="http://ofj92itlz.bkt.clouddn.com/Widget:step3.jpeg" alt="step3" /></p>

<p>3、改为纯代码创建界面，默认会创建<strong>MainInterface.storyboard</strong>设计界面。删除Info.plist文件中的字段，并添加<strong>NSExtensionPrincipalClass</strong>字段，设为对应的<strong>TodayViewController</strong>； <img src="http://ofj92itlz.bkt.clouddn.com/Widget:step5.jpeg" alt="step4" /></p>

<p>4、在TodayViewController中创建界面。</p>

<h2>点击Widget跳转至主应用</h2>

<p>为widget添加跳转至主应用的快捷入口。</p>

<p>为widget添加一层透明UIView，并添加tap手势，当点击widget时，执行下面方法：</p>

<pre><code class="objective-c">- (void)tapAction {
  [self.extensionContext openURL:[NSURL URLWithString:@"customScheme://url"]
               completionHandler:nil];
}
</code></pre>

<p>其中<strong>customScheme</strong>可以自定义为需要的名字，字符串整体一定要符合<strong>URL</strong>格式，否则无法跳转。</p>

<h2>主应用响应跳转</h2>

<p>tapAction方法发出打开URL请，系统会查找注册过相同scheme的应用，并对其通知。所以主应用要注册相同的scheme，并且实现对通知的响应。</p>

<p>首先，在主应用的<strong>Info.plist</strong>文件中，添加<strong>URL types</strong>字段，并最终添加对应的scheme。</p>

<p><img src="http://ofj92itlz.bkt.clouddn.com/Widget:step4.jpeg" alt="step5" /></p>

<p>然后，在主应用<strong>AppDelegate.m</strong>中添加如下方法：</p>

<pre><code class="objective-c">- (BOOL)application:(UIApplication *)application
            openURL:(NSURL *)url
  sourceApplication:(NSString *)sourceApplication
         annotation:(id)annotation {
  if ([[url scheme] isEqualToString:@"customScheme"]) {
    //  scheme相同，打开应用
    return YES;
  }
  //    scheme不同，退出
  return NO;
}
</code></pre>

<h2>不同应用间跳转</h2>

<p>大致过程与widget跳转至主应用相同，差别在于发送跳转请求的方法不同，如下：</p>

<pre><code class="objective-c">- (void)jumpToApp2 {
  [[UIApplication sharedApplication]
      openURL:[NSURL URLWithString:[NSString stringWithFormat:@"customScheme://"
                                                              @"www.ticwath."
                                                              @"com?name=%@",
                                                              self.tf.text]]
      options:@{}
      completionHandler:^(BOOL success) {
        if (success) {
          NSLog(@"success");
        } else {
          NSLog(@"failed");
        }
      }];
}
</code></pre>

<p>一定要保持两者约定的scheme相同。跳转时传递的信息保存在<strong>URL</strong>中，按约定解析即可。</p>

<h2>Github源码</h2>

<p><a href="https://github.com/sxgfxm/WidgetDemo/tree/master">WidgetDemo</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS判断GPS坐标是否在中国]]></title>
    <link href="http://sxgfxm.github.io/blog/2016/10/19/iospan-duan-gpszuo-biao-shi-fou-zai-zhong-guo/"/>
    <updated>2016-10-19T10:29:23+08:00</updated>
    <id>http://sxgfxm.github.io/blog/2016/10/19/iospan-duan-gpszuo-biao-shi-fou-zai-zhong-guo</id>
    <content type="html"><![CDATA[<h2>Background</h2>

<p>GPS定位已经深入生活的方方面面。现实生活中存在着多种GPS坐标系：</p>

<ul>
<li><strong>WGS-84坐标系</strong>（World Geodetic System——1984 Coordinate System），国际通用GPS坐标系。</li>
<li><strong>GCJ-02坐标系</strong>（Guojia Cehui Ju Coordinate System），中国专用坐标系，加入随机偏差，俗称火星坐标。</li>
<li><strong>百度坐标系</strong>，百度自己定义的坐标系。</li>
</ul>


<p>在iOS应用开发中，<strong>CoreLocation</strong>返回<strong>WGS坐标</strong>，当定位在中国时，如果直接用<strong>MKMapView</strong>显示位置，由于中国地图使用<strong>GCJ坐标</strong>，会使定位出现偏差，达不到预期效果。为解决这一问题，在显示位置之前，需要判断<strong>WGS坐标</strong>是否在中国，并作出相应的坐标转换。</p>

<p>该问题抽象为<strong>判断点是否在多边形内部</strong>。</p>

<!--more-->


<h2>判断点是否在多边形内部算法</h2>

<ul>
<li>面积和判别法：判断目标点与多边形的每条边组成的三角形面积和是否等于该多边形，相等则在多边形内部。</li>
<li>夹角和判别法：判断目标点与所有边的夹角和是否为360度，为360度则在多边形内部。</li>
<li>引射线法：从目标点出发引一条射线，看这条射线和多边形所有边的交点数目。如果有奇数个交点，则说明在内部，如果有偶数个交点，则说明在外部。</li>
</ul>


<p>算法原理在此不再赘述，主要关注算法的实现问题。</p>

<h2>采用引射线法判断GPS坐标是否在中国</h2>

<h4>构造中国大陆轮廓</h4>

<p>因为<strong>GCJ坐标系</strong>不包含港澳台地区，所有选取中国大陆地区的采样点。</p>

<p>本文使用的采样点有限，某些边界可能存在偏差，仅供参考。</p>

<pre><code class="objective-c">//  中国大陆多边形，用于判断坐标是否在中国
//  因为港澳台地区使用WGS坐标，所以多边形不包含港澳台地区
+ (NSMutableArray *)polygonOfChina {
  static NSMutableArray *polygonOfChina = nil;
  static dispatch_once_t onceToken;
  dispatch_once(&amp;onceToken, ^{
    polygonOfChina = [[NSMutableArray alloc] init];
    [polygonOfChina
     addObject:[NSValue valueWithCGPoint:CGPointMake(49.1506690000,
                                                     87.4150810000)]];
    [polygonOfChina
     addObject:[NSValue valueWithCGPoint:CGPointMake(48.3664501790,
                                                     85.7527085300)]];
    [polygonOfChina
     addObject:[NSValue valueWithCGPoint:CGPointMake(47.0253058185,
                                                     85.3847443554)]];
    [polygonOfChina
     addObject:[NSValue valueWithCGPoint:CGPointMake(45.2406550000,
                                                     82.5214000000)]];
    [polygonOfChina
     addObject:[NSValue valueWithCGPoint:CGPointMake(44.8957121295,
                                                     79.9392351487)]];
    [polygonOfChina
     addObject:[NSValue valueWithCGPoint:CGPointMake(43.1166843846,
                                                     80.6751253982)]];
    [polygonOfChina
     addObject:[NSValue valueWithCGPoint:CGPointMake(41.8701690000,
                                                     79.6882160000)]];
    [polygonOfChina
     addObject:[NSValue valueWithCGPoint:CGPointMake(39.2896190000,
                                                     73.6171080000)]];
    [polygonOfChina
     addObject:[NSValue valueWithCGPoint:CGPointMake(34.2303430000,
                                                     78.9155300000)]];
    [polygonOfChina
     addObject:[NSValue valueWithCGPoint:CGPointMake(31.0238860000,
                                                     79.0627080000)]];
    [polygonOfChina
     addObject:[NSValue valueWithCGPoint:CGPointMake(27.9989800000,
                                                     88.7028920000)]];
    [polygonOfChina
     addObject:[NSValue valueWithCGPoint:CGPointMake(27.1793590000,
                                                     88.9972480000)]];
    [polygonOfChina
     addObject:[NSValue valueWithCGPoint:CGPointMake(28.0969170000,
                                                     89.7331400000)]];
    [polygonOfChina
     addObject:[NSValue valueWithCGPoint:CGPointMake(26.9157800000,
                                                     92.1615830000)]];
    [polygonOfChina
     addObject:[NSValue valueWithCGPoint:CGPointMake(28.1947640000,
                                                     96.0986050000)]];
    [polygonOfChina
     addObject:[NSValue valueWithCGPoint:CGPointMake(27.4094760000,
                                                     98.6742270000)]];
    [polygonOfChina
     addObject:[NSValue valueWithCGPoint:CGPointMake(23.9085500000,
                                                     97.5703890000)]];
    [polygonOfChina
     addObject:[NSValue valueWithCGPoint:CGPointMake(24.0775830000,
                                                     98.7846100000)]];
    [polygonOfChina
     addObject:[NSValue valueWithCGPoint:CGPointMake(22.1375640000,
                                                     99.1893510000)]];
    [polygonOfChina
     addObject:[NSValue valueWithCGPoint:CGPointMake(21.1398950000,
                                                     101.7649720000)]];
    [polygonOfChina
     addObject:[NSValue valueWithCGPoint:CGPointMake(22.2746220000,
                                                     101.7281780000)]];
    [polygonOfChina
     addObject:[NSValue valueWithCGPoint:CGPointMake(23.2641940000,
                                                     105.3708430000)]];
    [polygonOfChina
     addObject:[NSValue valueWithCGPoint:CGPointMake(22.7191200000,
                                                     106.6954480000)]];
    [polygonOfChina
     addObject:[NSValue valueWithCGPoint:CGPointMake(21.9945711661,
                                                     106.7256731791)]];
    [polygonOfChina
     addObject:[NSValue valueWithCGPoint:CGPointMake(21.4847050000,
                                                     108.0200530000)]];
    [polygonOfChina
     addObject:[NSValue valueWithCGPoint:CGPointMake(20.4478440000,
                                                     109.3814530000)]];
    [polygonOfChina
     addObject:[NSValue valueWithCGPoint:CGPointMake(18.6689850000,
                                                     108.2408210000)]];
    [polygonOfChina
     addObject:[NSValue valueWithCGPoint:CGPointMake(17.4017340000,
                                                     109.9333720000)]];
    [polygonOfChina
     addObject:[NSValue valueWithCGPoint:CGPointMake(19.5085670000,
                                                     111.4051560000)]];
    [polygonOfChina
     addObject:[NSValue valueWithCGPoint:CGPointMake(21.2716775175,
                                                     111.2514995205)]];
    [polygonOfChina
     addObject:[NSValue valueWithCGPoint:CGPointMake(21.9936323233,
                                                     113.4625292629)]];
    [polygonOfChina
     addObject:[NSValue valueWithCGPoint:CGPointMake(22.1818312942,
                                                     113.4258358111)]];
    [polygonOfChina
     addObject:[NSValue valueWithCGPoint:CGPointMake(22.2249729295,
                                                     113.5913115000)]];
    [polygonOfChina
     addObject:[NSValue valueWithCGPoint:CGPointMake(22.4501912753,
                                                     113.8946844490)]];
    [polygonOfChina
     addObject:[NSValue valueWithCGPoint:CGPointMake(22.5959159322,
                                                     114.3623797842)]];
    [polygonOfChina
     addObject:[NSValue valueWithCGPoint:CGPointMake(22.4334610000,
                                                     114.5194740000)]];
    [polygonOfChina
     addObject:[NSValue valueWithCGPoint:CGPointMake(22.9680954377,
                                                     116.8326939975)]];
    [polygonOfChina
     addObject:[NSValue valueWithCGPoint:CGPointMake(25.3788220000,
                                                     119.9667980000)]];
    [polygonOfChina
     addObject:[NSValue valueWithCGPoint:CGPointMake(28.3261276204,
                                                     121.7724402562)]];
    [polygonOfChina
     addObject:[NSValue valueWithCGPoint:CGPointMake(31.9883610000,
                                                     123.8808230000)]];
    [polygonOfChina
     addObject:[NSValue valueWithCGPoint:CGPointMake(39.8759700000,
                                                     124.4695370000)]];
    [polygonOfChina
     addObject:[NSValue valueWithCGPoint:CGPointMake(41.7350890000,
                                                     126.9531720000)]];
    [polygonOfChina
     addObject:[NSValue valueWithCGPoint:CGPointMake(41.5142160000,
                                                     128.3145720000)]];
    [polygonOfChina
     addObject:[NSValue valueWithCGPoint:CGPointMake(42.9842081790,
                                                     131.0676468344)]];
    [polygonOfChina
     addObject:[NSValue valueWithCGPoint:CGPointMake(45.2690810000,
                                                     131.8468530000)]];
    [polygonOfChina
     addObject:[NSValue valueWithCGPoint:CGPointMake(45.0608370000,
                                                     133.0610740000)]];
    [polygonOfChina
     addObject:[NSValue valueWithCGPoint:CGPointMake(48.4480260000,
                                                     135.0111880000)]];
    [polygonOfChina
     addObject:[NSValue valueWithCGPoint:CGPointMake(48.0054800000,
                                                     131.6628800000)]];
    [polygonOfChina
     addObject:[NSValue valueWithCGPoint:CGPointMake(50.2270740000,
                                                     127.6890640000)]];
    [polygonOfChina
     addObject:[NSValue valueWithCGPoint:CGPointMake(53.3516070000,
                                                     125.3710040000)]];
    [polygonOfChina
     addObject:[NSValue valueWithCGPoint:CGPointMake(53.4176040000,
                                                     119.9254040000)]];
    [polygonOfChina
     addObject:[NSValue valueWithCGPoint:CGPointMake(47.5590810000,
                                                     115.1421070000)]];
    [polygonOfChina
     addObject:[NSValue valueWithCGPoint:CGPointMake(47.1339370000,
                                                     119.1159230000)]];
    [polygonOfChina
     addObject:[NSValue valueWithCGPoint:CGPointMake(44.8256460000,
                                                     111.2786750000)]];
    [polygonOfChina
     addObject:[NSValue valueWithCGPoint:CGPointMake(42.5293560000,
                                                     109.2549720000)]];
    [polygonOfChina
     addObject:[NSValue valueWithCGPoint:CGPointMake(43.2598160000,
                                                     97.2967290000)]];
    [polygonOfChina
     addObject:[NSValue valueWithCGPoint:CGPointMake(45.4247620000,
                                                     90.9680590000)]];
    [polygonOfChina
     addObject:[NSValue valueWithCGPoint:CGPointMake(47.8075570000,
                                                     90.6737020000)]];
    [polygonOfChina
     addObject:[NSValue valueWithCGPoint:CGPointMake(49.1506690000,
                                                     87.4150810000)]];
  });
  return polygonOfChina;
}
</code></pre>

<h4>采用引射线法判断</h4>

<pre><code class="objective-c">/**
 *  判断是不是在中国
 *  用引射线法判断 点是否在多边形内部
 *  算法参考：http://www.cnblogs.com/luxiaoxun/p/3722358.html
 */
+ (BOOL)isLocationOutOfChina:(CLLocationCoordinate2D)location {
  CGPoint point = CGPointMake(location.latitude, location.longitude);
  BOOL oddFlag = NO;
  NSInteger j = [self polygonOfChina].count - 1;
  for (NSInteger i = 0; i &lt; [self polygonOfChina].count; i++) {
    CGPoint polygonPointi = [[self polygonOfChina][i] CGPointValue];
    CGPoint polygonPointj = [[self polygonOfChina][j] CGPointValue];
    if (((polygonPointi.y &lt; point.y &amp;&amp; polygonPointj.y &gt;= point.y) ||
         (polygonPointj.y &lt; point.y &amp;&amp; polygonPointi.y &gt;= point.y)) &amp;&amp;
        (polygonPointi.x &lt;= point.x || polygonPointj.x &lt;= point.x)) {
      oddFlag ^= (polygonPointi.x +
                  (point.y - polygonPointi.y) /
                  (polygonPointj.y - polygonPointi.y) *
                  (polygonPointj.x - polygonPointi.x) &lt;
                  point.x);
    }
    j = i;
  }
  return !oddFlag;
}
</code></pre>

<h4>测试结果</h4>

<p> <img src="http://ofj92itlz.bkt.clouddn.com/Map:Result.png" alt="result" /></p>

<p>如上图所示，红色多边形为所构造的中国大陆轮廓。随机生成经纬度坐标进行测试，如果在中国，标记为红色；如果不在中国，标记为蓝色。</p>

<h2>参考资料</h2>

<p><a href="http://www.cnblogs.com/luxiaoxun/p/3722358.html">阿凡卢博客</a></p>

<p><a href="https://github.com/TinyQ/TQLocationConverter">Github源码地址</a></p>
]]></content>
  </entry>
  
</feed>

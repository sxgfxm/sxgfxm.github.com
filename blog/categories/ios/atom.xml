<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Ios | Light's Blog]]></title>
  <link href="http://sxgfxm.github.io/blog/categories/ios/atom.xml" rel="self"/>
  <link href="http://sxgfxm.github.io/"/>
  <updated>2018-04-18T14:22:58+08:00</updated>
  <id>http://sxgfxm.github.io/</id>
  <author>
    <name><![CDATA[Light]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[iOS知识小集-180319]]></title>
    <link href="http://sxgfxm.github.io/blog/2018/04/18/ioszhi-shi-xiao-ji-180319/"/>
    <updated>2018-04-18T14:20:28+08:00</updated>
    <id>http://sxgfxm.github.io/blog/2018/04/18/ioszhi-shi-xiao-ji-180319</id>
    <content type="html"><![CDATA[<h2>Today Extension 研究</h2>

<h3>Layout</h3>

<ol>
<li>self.view.frame是整个屏幕大小。</li>
</ol>


<h3>Life cycle</h3>

<ol>
<li>滑走后，会重新创建。</li>
</ol>


<h2>NEVPNManager</h2>

<p><code>NEVPNManager</code>是用来创建和管理VPN设置，并且处理VPN连接结果的。
每一个应用只允许创建一个VPA设置，所以<code>NEVPNManager</code>是一个单例。
由<code>NEVPNManager</code>创建的VPN称为私人VPN，在iOS和macOS上，非私人VPA的优先级高于私人VPN。
使用<code>NEVPNManager</code>需要<code>com.apple.developer.networking.vpn.api entitlement</code>，需要开启应用的<code>Personal VPN</code>权限。
在开启私人VPN前，必须从Network Extension preferences载入VPN设置，在修改VPN设置之后，必须写入Network Extension preferences。
<code>NEVPNManager</code>的对象是线程安全的。</p>

<p><code>#import &lt;NetworkExtension/NEVPNManager.h&gt;</code></p>

<h2>NEVPNProtocol</h2>

<p><code>NEVPNProtocol</code>用来配置VPN。</p>

<h2>NEVPNConnection</h2>

<p><code>NEVPNConnection</code>用来控制VPN连接。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS知识小集-180312]]></title>
    <link href="http://sxgfxm.github.io/blog/2018/03/18/ioszhi-shi-xiao-ji-180312/"/>
    <updated>2018-03-18T18:19:33+08:00</updated>
    <id>http://sxgfxm.github.io/blog/2018/03/18/ioszhi-shi-xiao-ji-180312</id>
    <content type="html"><![CDATA[<h2>embed pods frameworks error</h2>

<p><code>rm -rf ~/Library/Developer/Xcode/DerivedData</code></p>

<h2>armv7、armv7s、arm64、i386、x86_64指令集</h2>

<p>armv7 | armv7s | arm64 是ARM处理器指令集；
i386 | x86_64 是Intel处理器指令集。</p>

<p>设备相关
arm64： iPhone6s | iPhone5s | iPad Air
armv7s：iPhone5 | iPhone5c | iPad4
armv7： iPhone4 | iPhone4s | iPad3</p>

<p>模拟器32位处理器：i386架构；
模拟器64位处理器：x86_64架构；
真机32位处理器：armv7或armv7架构；
真机64位处理器：arm64架构。</p>

<p>而编译出哪种指令集的包，将由 <strong>Architectures</strong> 与 <strong>Valid Architectures</strong>（因此这个不能为空）的交集来确定。
<strong>Build Active Architecture Only</strong> 指定是否只对当前连接设备所支持的指令集编译。</p>

<h2>Git拉取远程分支</h2>

<p><code>git checkout -b branch_name remote_branch_name</code></p>

<h2>Today Extension 研究</h2>

<ol>
<li>self.view.frame是整个屏幕大小。</li>
<li>滑走后，会重新创建。</li>
</ol>


<h2>NEVPNManager</h2>

<p><code>#import &lt;NetworkExtension/NEVPNManager.h&gt;</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS知识小集-180129]]></title>
    <link href="http://sxgfxm.github.io/blog/2018/03/12/ioszhi-shi-xiao-ji-180129/"/>
    <updated>2018-03-12T15:28:49+08:00</updated>
    <id>http://sxgfxm.github.io/blog/2018/03/12/ioszhi-shi-xiao-ji-180129</id>
    <content type="html"><![CDATA[<h2>圆角动画与圆角定制</h2>

<pre><code>  UIView *view = [[UIView alloc] initWithFrame:CGRectMake(100, 100, 100, 100)];
  view.backgroundColor = [UIColor redColor];
  view.layer.cornerRadius = 20;
  //  圆角定制
  view.layer.maskedCorners = kCALayerMinXMaxYCorner | kCALayerMaxXMaxYCorner;
  [self.view addSubview:view];
  //  圆角动画
  [UIView animateWithDuration:0.5 animations:^{
    view.layer.cornerRadius = 0;
  }];
</code></pre>

<h2>NSMutableAttributedString crash</h2>

<pre><code>- (void)testAttributedStringInitCrash
{
  NSString *nilStr = nil;
  NSAttributedString *attributedStr = [[NSAttributedString alloc] initWithString:nilStr];
}
</code></pre>

<p>Crash Log
~~~
Terminating app due to uncaught exception &lsquo;NSInvalidArgumentException&rsquo;, reason: &lsquo;NSConcreteAttributedString initWithString:: nil value&rsquo;
~~~</p>

<pre><code>- (void)testMutableAttributedStringInitCrash
{
  NSString *nilStr = nil;
  NSMutableAttributedString *attributedStr = [[NSMutableAttributedString alloc] initWithString:nilStr];
}
</code></pre>

<p>Crash Log
~~~
Terminating app due to uncaught exception &lsquo;NSInvalidArgumentException&rsquo;, reason: &lsquo;NSConcreteMutableAttributedString initWithString:: nil value&rsquo;
~~~</p>

<pre><code>- (void)testMutableAttributedStringAddAttributeCrash
{
  NSString *nonnullStr = @"str";
  NSMutableAttributedString *attributedStr = [[NSMutableAttributedString alloc] initWithString:nonnullStr];

  NSString *nilValue = nil;
  [attributedStr addAttribute:NSAttachmentAttributeName value:nilValue range:NSMakeRange(0, 1)];
}
</code></pre>

<p>Crash Log
~~~
Terminating app due to uncaught exception &lsquo;NSInvalidArgumentException&rsquo;, reason: &lsquo;NSConcreteMutableAttributedString addAttribute:value:range:: nil value&rsquo;
~~~</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS知识小集-171211]]></title>
    <link href="http://sxgfxm.github.io/blog/2018/03/12/ioszhi-shi-xiao-ji-171211/"/>
    <updated>2018-03-12T15:26:20+08:00</updated>
    <id>http://sxgfxm.github.io/blog/2018/03/12/ioszhi-shi-xiao-ji-171211</id>
    <content type="html"><![CDATA[<h2>layoutIfNeeded</h2>

<p>布局其子视图。</p>

<h2>UIViewContentModeScaleAspectFill</h2>

<p>需要设置<code>clipsToBounds</code>为<code>YES</code>，否则图片显示可能会溢出。</p>

<h2>UITableView Edit Cell</h2>

<h2>UITableView Move Cell</h2>

<h2>数据与界面同步</h2>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS知识小集-171204]]></title>
    <link href="http://sxgfxm.github.io/blog/2017/12/11/ioszhi-shi-xiao-ji-171204/"/>
    <updated>2017-12-11T16:49:04+08:00</updated>
    <id>http://sxgfxm.github.io/blog/2017/12/11/ioszhi-shi-xiao-ji-171204</id>
    <content type="html"><![CDATA[<h2>UIViewController Transition</h2>

<p>自定义Present和Dismiss动画。</p>

<!-- more -->


<h3>设置待Present的UIViewController的transitioningDelegate</h3>

<p><code>modalPresentationStyle</code>为<code>FullScreen</code>时，dismiss时会自动移除<code>fromView</code>。<br/>
<code>modalPresentationStyle</code>为<code>Custom</code>时，dismiss时会需手动移除<code>fromView</code>。</p>

<pre><code class="objective-c">@interface ViewController : UIViewController &lt;UIViewControllerTransitioningDelegate&gt;

@end

@implementation ViewController

- (instancetype)init{
  if (self = [super init]) {
    self.modalPresentationStyle = UIModalPresentationOverFullScreen;
    self.transitioningDelegate = self;
  }
  return self;
}

#pragma mark - UIViewControllerTransitioningDelegate
- (id&lt;UIViewControllerAnimatedTransitioning&gt;)animationControllerForPresentedController:(UIViewController *)presented
                                                                  presentingController:(UIViewController *)presenting
                                                                      sourceController:(UIViewController *)source {
  return [PresentAnimator new];
}

- (id&lt;UIViewControllerAnimatedTransitioning&gt;)animationControllerForDismissedController:(UIViewController *)dismissed{
  return [DismissAnimator new];
}

@end
</code></pre>

<h3>创建PresentAnimator</h3>

<pre><code class="objective-c">@interface PresentAnimator : NSObject &lt;UIViewControllerAnimatedTransitioning&gt;

@end

@implementation PresentAnimator

#pragma mark - UIViewControllerContextTransitioning
- (void)animateTransition:(nonnull id&lt;UIViewControllerContextTransitioning&gt;)transitionContext {
  //  from -&gt; to
  UIViewController *fromViewController = [transitionContext viewControllerForKey:UITransitionContextFromViewControllerKey];
  UIViewController *toViewController = [transitionContext viewControllerForKey:UITransitionContextToViewControllerKey];
  //  contrainer
  UIView *containerView = transitionContext.containerView;
  //  from -&gt; to
  UIView *fromView = [transitionContext viewForKey:UITransitionContextFromViewKey];
  UIView *toView = [transitionContext viewForKey:UITransitionContextToViewKey];
  //  add
  [containerView addSubview:toView];
  //  animation
  toView.alpha = 0;
  toView.frame = CGRectMake(fromView.frame.origin.x, CGRectGetMaxY(fromView.frame) / 2, fromView.frame.size.width, fromView.frame.size.height);
  [UIView animateWithDuration:[self transitionDuration:transitionContext] animations:^{
    toView.alpha = 1;
    toView.frame = [transitionContext finalFrameForViewController:toViewController];
  } completion:^(BOOL finished) {
    [transitionContext completeTransition:![transitionContext transitionWasCancelled]];
  }];
}

- (NSTimeInterval)transitionDuration:(nullable id&lt;UIViewControllerContextTransitioning&gt;)transitionContext {
  return 0.25;
}

@end
</code></pre>

<h3>创建DismissAnimator</h3>

<pre><code class="objective-c">@interface DismissAnimator : NSObject &lt;UIViewControllerAnimatedTransitioning&gt;

@end

@implementation DismissAnimator

#pragma mark - UIViewControllerContextTransitioning
- (void)animateTransition:(nonnull id&lt;UIViewControllerContextTransitioning&gt;)transitionContext {
  //  from -&gt; to
  UIView *fromView = [transitionContext viewForKey:UITransitionContextFromViewKey];
  //  animation
  fromView.alpha = 1;
  [UIView animateWithDuration:[self transitionDuration:transitionContext] animations:^{
    fromView.alpha = 0;
  } completion:^(BOOL finished) {
    [transitionContext completeTransition:![transitionContext transitionWasCancelled]];
  }];
}

- (NSTimeInterval)transitionDuration:(nullable id&lt;UIViewControllerContextTransitioning&gt;)transitionContext {
  return 0.25;
}

@end
</code></pre>
]]></content>
  </entry>
  
</feed>

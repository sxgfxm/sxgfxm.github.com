<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Ios | Light's Blog]]></title>
  <link href="http://sxgfxm.github.io/blog/categories/ios/atom.xml" rel="self"/>
  <link href="http://sxgfxm.github.io/"/>
  <updated>2017-08-07T10:07:31+08:00</updated>
  <id>http://sxgfxm.github.io/</id>
  <author>
    <name><![CDATA[Light]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[iOS知识小集-170731]]></title>
    <link href="http://sxgfxm.github.io/blog/2017/08/07/ioszhi-shi-xiao-ji-170731/"/>
    <updated>2017-08-07T10:03:41+08:00</updated>
    <id>http://sxgfxm.github.io/blog/2017/08/07/ioszhi-shi-xiao-ji-170731</id>
    <content type="html"><![CDATA[<h2>UIImage Tint Color</h2>

<pre><code>[cell.icon sd_setImageWithURL:[NSURL URLWithString:myURL] placeholderImage:[UIImage imageNamed:imageName] options:SDWebImageRefreshCached completed:^(UIImage *image, NSError *error, SDImageCacheType cacheType, NSURL *imageURL) {           
    cell.icon.image = [image imageWithRenderingMode:UIImageRenderingModeAlwaysTemplate];            
}];
</code></pre>

<h2>调整屏幕亮度</h2>

<pre><code>[[UIScreen mainScreen] setBrightness:0.5];
</code></pre>

<h2>保持屏幕常亮</h2>

<pre><code>[UIApplication sharedApplication].idleTimerDisabled = YES;
</code></pre>

<!-- more -->


<h2>cell.contentView VS cell</h2>

<p>If you want to customize cells by simply adding additional views, you should add them to the content view so they will be positioned appropriately as the cell transitions into and out of editing mode.</p>

<h2>NSURLSession</h2>

<pre><code>NSURLSessionConfiguration *config = [NSURLSessionConfiguration defaultSessionConfiguration];
NSURLSession *session =
      [NSURLSession sessionWithConfiguration:config delegate:self delegateQueue:[NSOperationQueue mainQueue]];
[session dataTaskWithRequest:request];

- (void)URLSession:(NSURLSession *)session
                          task:(NSURLSessionTask *)task
    willPerformHTTPRedirection:(NSHTTPURLResponse *)response
                    newRequest:(NSURLRequest *)request
             completionHandler:(void (^)(NSURLRequest *_Nullable))completionHandler {
  NSLog(@"urlsession request %@", request.URL);
}
</code></pre>

<h2>后台运行</h2>

<p>Target -> Capabilities -> Background Modes -> Audio；<br/>
在info.plist中 添加<code>Required background modes</code> = <code>App plays audio or streams audio/video using AirPlay</code>。<br/>
如果启用后台录音，会有红色显示条。</p>

<h2>应用进入前台或后台通知</h2>

<pre><code>// app启动或者app从后台进入前台都会调用这个方法
[[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(applicationBecomeActive) name:UIApplicationDidBecomeActiveNotification object:nil];
// app从后台进入前台都会调用这个方法
[[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(applicationBecomeActive) name:UIApplicationWillEnterForegroundNotification object:nil];
// 添加检测app进入后台的观察者
[[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(applicationEnterBackground) name: UIApplicationDidEnterBackgroundNotification object:nil];
</code></pre>

<h2>Logging Malloc Stack</h2>

<p>如果不关闭，会导致大量无法自动清除的系统log，占用巨大磁盘空间。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS知识小集-170724]]></title>
    <link href="http://sxgfxm.github.io/blog/2017/07/31/ioszhi-shi-xiao-ji-170724/"/>
    <updated>2017-07-31T10:17:32+08:00</updated>
    <id>http://sxgfxm.github.io/blog/2017/07/31/ioszhi-shi-xiao-ji-170724</id>
    <content type="html"><![CDATA[<h2>JavaScriptCore</h2>

<pre><code>[self.webView stringByEvaluatingJavaScriptFromString:@"document.getElementsByTagName('audio')[0].play()"];
</code></pre>

<!-- more -->


<h2>调整button点击区域</h2>

<pre><code>self.playBtn.contentMode = UIViewContentModeScaleAspectFit;
self.closeBtn.contentMode = UIViewContentModeScaleAspectFit;
[self.playBtn setImageEdgeInsets:UIEdgeInsetsMake(0, 10, 0, 0)];
[self.closeBtn setImageEdgeInsets:UIEdgeInsetsMake(0, -10, 0, 0)];
</code></pre>

<h2>判断网络状态</h2>

<pre><code>- (BOOL)connected {
  NetworkStatus internetStatus = [[Reachability reachabilityForInternetConnection] currentReachabilityStatus];
  return internetStatus != NotReachable;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS知识小集-170717]]></title>
    <link href="http://sxgfxm.github.io/blog/2017/07/24/ioszhi-shi-xiao-ji-170717/"/>
    <updated>2017-07-24T09:36:53+08:00</updated>
    <id>http://sxgfxm.github.io/blog/2017/07/24/ioszhi-shi-xiao-ji-170717</id>
    <content type="html"><![CDATA[<h2>Set UITableViewHeaderFooterView backgroundColor transparent</h2>

<pre><code>self.backgroundView = [[UIImageView alloc] initWithImage:[UIImage new]];
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS知识小集-170710]]></title>
    <link href="http://sxgfxm.github.io/blog/2017/07/15/ioszhi-shi-xiao-ji-170710/"/>
    <updated>2017-07-15T15:08:46+08:00</updated>
    <id>http://sxgfxm.github.io/blog/2017/07/15/ioszhi-shi-xiao-ji-170710</id>
    <content type="html"><![CDATA[<h2><a href="https://github.com/airbnb/lottie-ios">Lottie</a></h2>

<p>Lottie is a mobile library for Android and iOS that parses Adobe After Effects animations exported as json with bodymovin and renders the vector animations natively on mobile and through React Native!<br/>
Common Animations</p>

<pre><code>LOTAnimationView *animation = [LOTAnimationView animationNamed:@"Lottie"];
[self.view addSubview:animation];
[animation playWithCompletion:^(BOOL animationFinished) {
  // Do Something
}];
</code></pre>

<!-- more -->


<p>UIViewController Transition</p>

<pre><code>- (id&lt;UIViewControllerAnimatedTransitioning&gt;)animationControllerForPresentedController:(UIViewController *)presented
                                                                  presentingController:(UIViewController *)presenting
                                                                      sourceController:(UIViewController *)source {
  LOTAnimationTransitionController *animationController = [[LOTAnimationTransitionController alloc] initWithAnimationNamed:@"vcTransition1"
                                                                                                          fromLayerNamed:@"outLayer"
                                                                                                            toLayerNamed:@"inLayer"];
  return animationController;
}

- (id&lt;UIViewControllerAnimatedTransitioning&gt;)animationControllerForDismissedController:(UIViewController *)dismissed {
  LOTAnimationTransitionController *animationController = [[LOTAnimationTransitionController alloc] initWithAnimationNamed:@"vcTransition2"
                                                                                                          fromLayerNamed:@"outLayer"
                                                                                                            toLayerNamed:@"inLayer"];
  return animationController;
}
</code></pre>

<h2>导航栏设为透明</h2>

<pre><code>[self.navigationController.navigationBar setBackgroundImage:[UIImage new] forBarMetrics:UIBarMetricsDefault];
[self.navigationController.navigationBar setShadowImage:[UIImage new]];
</code></pre>

<h2>导航栏还原</h2>

<pre><code>[self.navigationController.navigationBar setBackgroundImage:nil forBarMetrics:UIBarMetricsDefault];
[self.navigationController.navigationBar setShadowImage:nil];
</code></pre>

<h2>Change UITextField Placeholder Color</h2>

<pre><code>  NSString *string = @"请输入Wi-Fi名称";
  NSMutableAttributedString *attributedString = [[NSMutableAttributedString alloc] initWithString:string];
  [attributedString addAttribute:NSForegroundColorAttributeName value:[UIColor whiteColor] range:NSMakeRange(0, string.length)];
  self.wifiNameTF.attributedPlaceholder = attributedString;
</code></pre>

<h2>KVO NSKeyValueObservingOptions</h2>

<p>NSKeyValueObservingOptionNew：获取新值<br/>
NSKeyValueObservingOptionOld：获取旧值<br/>
NSKeyValueObservingOptionInitial：获取初始值<br/>
NSKeyValueObservingOptionPrior：获取新旧值</p>

<h2>UITextField nil While Editing</h2>

<pre><code>- (BOOL)textField:(UITextField*)textField shouldChangeCharactersInRange:(NSRange)range replacementString:(NSString*)string
{
    if (range.location == 0 &amp;&amp; string.length == 0)
    {
        //textField is empty
    }
    return YES;
}
</code></pre>

<h2>UIKeyboardAppearance</h2>

<pre><code>textField.keyboardAppearance = UIKeyboardAppearanceDark;
</code></pre>

<h2>UIView Transition Animation</h2>

<pre><code>[UIView transitionFromView:view1
                   toView:view2
                 duration:2
                  options:animationTransitionType
               completion:^(BOOL finished){
                            [view1 removeFromSuperview];
                          }];
[self.view addSubview:view2];
</code></pre>

<h2>UIView Fade In Fade Out</h2>

<pre><code>[view setAlpha:0.f];
[UIView animateWithDuration:2.f delay:0.f options:UIViewAnimationOptionCurveEaseIn animations:^{
    //  fade in
    [view setAlpha:1.f];
} completion:^(BOOL finished) {
    [UIView animateWithDuration:2.f delay:0.f options:UIViewAnimationOptionCurveEaseInOut animations:^{
        //  fade out
        [view setAlpha:0.f];
    } completion:nil];
}];
</code></pre>

<h2>Reachability</h2>

<p>ReachableViaWiFi</p>

<pre><code>self.reachability = [Reachability reachabilityForInternetConnection];
[self.reachability startNotifier];
[self.reachability stopNotifier];
</code></pre>

<p>Wi-Fi Name</p>

<pre><code>+ (NSString *)currentWifiName {
  NSArray *ifs = (__bridge_transfer NSArray *)CNCopySupportedInterfaces();
  NSString *ifnam = [ifs firstObject];
  if (!ifnam) {
    return nil;
  }
  NSDictionary *info = (__bridge_transfer NSDictionary *)CNCopyCurrentNetworkInfo((__bridge CFStringRef)ifnam);
  return info[@"SSID"];
}
</code></pre>

<h2>NetworkExtension</h2>

<p>Configure VPN tunnels. Customize and extend core networking features.</p>

<h3>Personal VPN</h3>

<p><code>NEVPNManager</code>: is used to create and manage VPN configurations and to control the resulting VPN tunnel connections.<br/>
Non-Personal VPN configurations take precedence over Personal VPN configurations.<br/>
Enable the &ldquo;Personal VPN&rdquo; capability for your app in Xcode.</p>

<h2>UIViewController</h2>

<h2>UINavigationController</h2>

<h2>UITabBarController</h2>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS知识小集-170703]]></title>
    <link href="http://sxgfxm.github.io/blog/2017/07/10/ioszhi-shi-xiao-ji-170703/"/>
    <updated>2017-07-10T11:09:16+08:00</updated>
    <id>http://sxgfxm.github.io/blog/2017/07/10/ioszhi-shi-xiao-ji-170703</id>
    <content type="html"><![CDATA[<h2>CAKeyFrameAnimation</h2>

<pre><code>- (CAKeyframeAnimation *)circleShake {
  if (!_circleShake) {
    CGFloat baseX = self.circleMask.position.x;
    _circleShake = [CAKeyframeAnimation animationWithKeyPath:@"position.x"];
    _circleShake.keyTimes = @[
      @0,
      @(0.1 / 0.8),
      @(0.2 / 0.8),
      @(0.3 / 0.8),
      @(0.5 / 0.8),
      @(0.76 / 0.8)
    ];
    _circleShake.values = @[
      @(baseX),
      @(baseX - 11),
      @(baseX + 11),
      @(baseX - 11),
      @(baseX + 11),
      @(baseX)
    ];
    _circleShake.duration = 0.8;
    _circleShake.removedOnCompletion = YES;
    _circleShake.fillMode = kCAFillModeForwards;
  }
  return _circleShake;
}
</code></pre>

<!-- more -->


<h2>Identify CAAnimation within the aniamtionDidStop delegate</h2>

<p>The animation is <strong>copied</strong> before being added to the layer, so any subsequent modifications to <code>anim</code> will have no affect unless it is added to another layer.<br/>
Use <code>animationForKey:</code> to identify.<br/>
Create one animation and add to multiple layers.</p>

<h2>Apply changes when animation finished</h2>

<pre><code>animation.removedOnCompletion = NO;
animation.fillMode = kCAFillModeForwards;
</code></pre>

<h2>Resume changes when animation finished</h2>

<pre><code>animation.removedOnCompletion = NO;
animation.fillMode = kCAFillModeBackwards;
</code></pre>

<h2>Use CAAnimationGroup to run animations cocurrently</h2>

<pre><code>- (CAAnimationGroup *)circleBig {
  if (!_circleBig) {
    _circleBig = [CAAnimationGroup animation];
    CABasicAnimation *circleBig =
        [CABasicAnimation animationWithKeyPath:@"path"];
    circleBig.fromValue = (__bridge id)self.circleMask.path;
    circleBig.toValue =
        (__bridge id)[UIBezierPath bezierPathWithArcCenter:self.centerPoint
                                                    radius:12.5
                                                startAngle:0
                                                  endAngle:M_PI * 2
                                                 clockwise:YES]
            .CGPath;
    circleBig.duration = self.spreadDuration;
    circleBig.removedOnCompletion = NO;
    circleBig.fillMode = kCAFillModeForwards;
    circleBig.timingFunction = [CAMediaTimingFunction
        functionWithName:kCAMediaTimingFunctionEaseInEaseOut];
    CABasicAnimation *changeWidth =
        [CABasicAnimation animationWithKeyPath:@"lineWidth"];
    changeWidth.fromValue = @(self.circleMask.lineWidth);
    changeWidth.toValue = @(5);
    changeWidth.duration = self.spreadDuration;
    changeWidth.removedOnCompletion = NO;
    changeWidth.fillMode = kCAFillModeForwards;
    _circleBig.animations = @[ circleBig, changeWidth ];
  }
  return _circleBig;
}
</code></pre>

<h2>TabBar背景设为透明色</h2>

<pre><code>[[UITabBar appearance] setShadowImage:[WWImageUtil imageWithColor:[UIColor clearColor]]];
[[UITabBar appearance] setBackgroundImage:[WWImageUtil imageWithColor:[UIColor clearColor]]];
[UITabBar appearance].translucent = YES;
</code></pre>

<h2>TabBar去除黑线</h2>

<pre><code>[[UITabBar appearance] setClipsToBounds:YES];
</code></pre>

<h2>self.title</h2>

<p><code>self.title</code>：同时设置导航栏和tabBar的title；<br/>
<code>self.navigationItem.title</code>：设置导航栏title；<br/>
<code>self.tabBarItem.title</code>：设置tabBartitle。</p>

<h2>InHouse 和 Debug配置不同</h2>
]]></content>
  </entry>
  
</feed>

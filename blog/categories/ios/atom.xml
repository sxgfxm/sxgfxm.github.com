<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Ios | Light's Blog]]></title>
  <link href="http://sxgfxm.github.io/blog/categories/ios/atom.xml" rel="self"/>
  <link href="http://sxgfxm.github.io/"/>
  <updated>2017-01-17T16:57:30+08:00</updated>
  <id>http://sxgfxm.github.io/</id>
  <author>
    <name><![CDATA[Light]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Prevent Duplicate Clicks]]></title>
    <link href="http://sxgfxm.github.io/blog/2017/01/17/prevent-duplicate-clicks/"/>
    <updated>2017-01-17T16:19:36+08:00</updated>
    <id>http://sxgfxm.github.io/blog/2017/01/17/prevent-duplicate-clicks</id>
    <content type="html"><![CDATA[<p>在应用开发过程中，点击事件为耗时操作或者延时响应，例如请求服务器数据，push至下一个界面，如果不处理用户重复点击事件，将会重复触发事件。下面介绍几种简单的处理方法。</p>

<h2>Button</h2>

<p>点击后button状态置为disabled；
操作完成后button状态置为enabled；</p>

<h2>View</h2>

<p>根据处理状态设置userInteractiveEnable。</p>

<h2>Push</h2>

<p>方法一：
    点击后button状态置为disabled；
    viewDidDisappear置为enabled；</p>

<p>方法二：在push前添加判断：如果和上一个视图控制器一样，隔绝此次操作。</p>

<pre><code class="objective-c">if ([self.navigationController.topViewController isKindOfClass:[MyViewController class]]) {
    return;
}
</code></pre>

<h2>时间监听类</h2>

<p>用一个静态变量记录上一次点击的时间，每次点击check时间间隔是否达到要求。</p>

<h2>Runtime</h2>

<p>使用Runtime监听点击事件，忽略重复点击。
添加一个eventTimeInterval属性，使其规定时间内只能响应一次点击事件。</p>

<p>参考<a href="http://www.cnblogs.com/wanxudong/p/5984941.html">iOS防止重复点击button</a></p>

<p>.h</p>

<pre><code>#import &lt;UIKit/UIKit.h&gt;

@interface UIButton (WXD)

/**
*  为按钮添加点击间隔 eventTimeInterval秒
*/
@property (nonatomic, assign) NSTimeInterval eventTimeInterval;

@end
</code></pre>

<p>.m</p>

<pre><code class="objective-c">#import "UIButton+WXD.h"
#import &lt;objc/runtime.h&gt;
#define defaultInterval 1  //默认时间间隔

@interface UIButton ()

/**
*  bool YES 忽略点击事件   NO 允许点击事件
*/
@property (nonatomic, assign) BOOL isIgnoreEvent;

@end

@implementation UIButton (WXD)

static const char *UIControl_eventTimeInterval = "UIControl_eventTimeInterval";
static const char *UIControl_enventIsIgnoreEvent = "UIControl_enventIsIgnoreEvent";


// runtime 动态绑定 属性
- (void)setIsIgnoreEvent:(BOOL)isIgnoreEvent
{
    objc_setAssociatedObject(self, UIControl_enventIsIgnoreEvent, @(isIgnoreEvent), OBJC_ASSOCIATION_RETAIN_NONATOMIC);
}
- (BOOL)isIgnoreEvent{
    return [objc_getAssociatedObject(self, UIControl_enventIsIgnoreEvent) boolValue];
}

- (NSTimeInterval)eventTimeInterval
{
  return [objc_getAssociatedObject(self, UIControl_eventTimeInterval) doubleValue];
}

- (void)setEventTimeInterval:(NSTimeInterval)eventTimeInterval
{
 objc_setAssociatedObject(self, UIControl_eventTimeInterval, @(eventTimeInterval), OBJC_ASSOCIATION_RETAIN_NONATOMIC);
}

+ (void)load
{
  // Method Swizzling
 static dispatch_once_t onceToken;
 dispatch_once(&amp;onceToken, ^{
       SEL selA = @selector(sendAction:to:forEvent:);
       SEL selB = @selector(_wxd_sendAction:to:forEvent:);
       Method methodA = class_getInstanceMethod(self,selA);
       Method methodB = class_getInstanceMethod(self, selB);

       BOOL isAdd = class_addMethod(self, selA, method_getImplementation(methodB), method_getTypeEncoding(methodB));

       if (isAdd) {
           class_replaceMethod(self, selB, method_getImplementation(methodA), method_getTypeEncoding(methodA));
       }else{
           //添加失败了 说明本类中有methodB的实现，此时只需要将methodA和methodB的IMP互换一下即可。
          method_exchangeImplementations(methodA, methodB);
      }
 });
}

- (void)_wxd_sendAction:(SEL)action to:(id)target forEvent:(UIEvent *)event
{
  self.eventTimeInterval = self.eventTimeInterval == 0 ? defaultInterval : self.eventTimeInterval;
  if (self.isIgnoreEvent){
      return;
  }else if (self.eventTimeInterval &gt; 0){
      dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(self.eventTimeInterval * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{
       [self setIsIgnoreEvent:NO];
       });
  }

  self.isIgnoreEvent = YES;
  // 这里看上去会陷入递归调用死循环，但在运行期此方法是和sendAction:to:forEvent:互换的，相当于执行sendAction:to:forEvent:方法，所以并不会陷入死循环。
  [self _wxd_sendAction:action to:target forEvent:event];
}  
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Smooth Gradient Polyline]]></title>
    <link href="http://sxgfxm.github.io/blog/2016/10/27/smooth-gradient-polyline/"/>
    <updated>2016-10-27T15:47:23+08:00</updated>
    <id>http://sxgfxm.github.io/blog/2016/10/27/smooth-gradient-polyline</id>
    <content type="html"><![CDATA[<h2>Introduction</h2>

<p>近年来，人们越来越注重运动锻炼，运动相关App层出不穷。其中运动路径追踪是一个重要的功能点。可以很容易的使用<strong>MKPolyline</strong>实现单色路径追踪。更进一步，如果想通过路径的不同颜色反映出运动过程中的速度变化，如<strong>Nike+</strong>类似的效果，需要更多的工作。本文主要讨论如何绘制<strong>平滑渐变</strong>的运动路径。</p>

<!-- more -->


<p><img src="http://ofj92itlz.bkt.clouddn.com/GradientPolyline:nike+.jpeg" alt="" /></p>

<p><img src="http://ofj92itlz.bkt.clouddn.com/GradientPolyline:ditongfilter.jpeg" alt="" /></p>

<p>上图为优化后的渐变色路径，图下方红色曲线为运动过程的速度曲线。</p>

<h2>主要流程</h2>

<ol>
<li>获取运动过程中GPS信息及对应的速度值；</li>
<li>使用<strong>低通滤波</strong>处理速度数据；</li>
<li>通过<strong>MKMapView</strong>转换坐标至对应大小的UIView；</li>
<li>使用<strong>CAGradientLayer</strong>及<strong>CAShaperLayer</strong>分段绘制渐变路径；</li>
</ol>


<h2>获取运动过程中GPS信息及对应的速度值</h2>

<p>可以使用<strong>CoreLocation</strong>获取GPS信息并计算对应的速度值。关于GPS坐标在中国大陆偏移及GPS坐标是否在中国大陆的判断方法，请参考<a href="https://sxgfxm.github.io/blog/2016/10/19/iospan-duan-gpszuo-biao-shi-fou-zai-zhong-guo/">另一篇博文</a>。本文着重探讨路径的绘制，所以模拟产生随机的GPS和速度数据。</p>

<h2>使用<strong>低通滤波</strong>处理速度数据</h2>

<p>因为所绘路径的颜色不同，所以只能分段绘制。</p>

<p>如果各分段为纯色，则绘制出的路径略显生硬，无法体现出过渡效果（如下图）。</p>

<p><img src="http://ofj92itlz.bkt.clouddn.com/GradientPolyline:pure.jpeg" alt="" /></p>

<p>如果根据速度直接绘制成渐变色，因为速度波动的原因，渐变效果并不理想（如下图）。</p>

<p><img src="http://ofj92itlz.bkt.clouddn.com/GradientPolyline:Gradient.jpeg" alt="" /></p>

<p>所以需要预先处理速度数据，使速度数据变得平滑，渐变的效果才好。本人分别使用了<strong>滑动窗口滤波</strong>和<strong>低通滤波</strong>，对比之下，<strong>低通滤波</strong>表现更好。</p>

<p><img src="http://ofj92itlz.bkt.clouddn.com/GradientPolyline:origin.jpeg" alt="" /></p>

<p>上图为原数据效果。</p>

<p><img src="http://ofj92itlz.bkt.clouddn.com/GradientPolyline:smoothwindow.jpeg" alt="" /></p>

<p>上图为滑动窗口平滑效果。</p>

<p><img src="http://ofj92itlz.bkt.clouddn.com/GradientPolyline:ditongfilter.jpeg" alt="" /></p>

<p>上图为低通滤波平滑效果，滤波参数可以根据需要调整。</p>

<h2>通过<strong>MKMapView</strong>转换坐标至对应大小的UIView</h2>

<p>首先需要说明的是，本文的方法将路径绘制在与MKMapView大小一致的UIView上，而非直接以MKOverlay的形式绘制在MKMapView上，所以只能看到路径大致的轮廓而不能像地图一样缩放。如果想要在地图上直接绘制渐变路径，需要自定义<strong>MKOverlayPathRenderer</strong>，如有需要我再放出来。</p>

<p>坐标转换方法，调用MKMapView的<code>convertCoordinate:toPointToView:</code>方法，即可把地图上的GPS坐标，转换为与地图大小相同的CGPoint，为绘制路径做准备。</p>

<h2>使用<strong>CAGradientLayer</strong>及<strong>CAShaperLayer</strong>分段绘制渐变路径</h2>

<h3>在<strong>CAGradientLayer</strong>上绘制对应的渐变颜色；</h3>

<p>1、渐变方向需要根据路径方向计算；</p>

<pre><code class="objective-c">gradientLayer.startPoint =
        CGPointMake(lastPoint.x / gradientView.frame.size.width,
                    lastPoint.y / gradientView.frame.size.height);
gradientLayer.endPoint =
        CGPointMake(newPoint.x / gradientView.frame.size.width,
                    newPoint.y / gradientView.frame.size.height);
</code></pre>

<p>2、渐变颜色为路径两端速度值映射后的颜色，推荐使用HSB颜色值映射；</p>

<pre><code class="objective-c">CGFloat hue = points[i].speed / self.maxSpeed * self.maxHue;
UIColor *newColor =
        [UIColor colorWithHue:hue saturation:1 brightness:1 alpha:1];
gradientLayer.colors =
        @[ (__bridge id)(lastColor.CGColor), (__bridge id)(newColor.CGColor) ];
</code></pre>

<p>3、渐变起止可按需要自行控制；</p>

<pre><code class="objective-c">gradientLayer.locations = @[ @(0.2), @(0.8) ];
</code></pre>

<h3>在<strong>CAShapeLayer</strong>上绘制对应的路径；</h3>

<p>1、路径的起止坐标为转换后的CGPoint；</p>

<p>2、注意设置<code>shapeLayer.lineCap = kCALineCapRound;</code>，否则路径会断；</p>

<p>3、注意<code>shapeLayer.strokeColor</code>不能为透明色，否则无法mask；</p>

<h3>设置<code>gradientLayer.mask = shapeLayer</code>；</h3>

<h2>总结</h2>

<p>绘制平滑渐变路径的关键在于速度数据的处理，大家可以尝试不同的滤波算法改进绘制效果。绘制路径的技巧也在文中列出，如有问题可以和我交流，大家共同探讨学习。</p>

<h2>Github源码</h2>

<p><a href="https://github.com/sxgfxm/SmoothGradientPolyline">SmoothGradientPolyline</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[XGChart_README]]></title>
    <link href="http://sxgfxm.github.io/blog/2016/10/25/xgchart-readme/"/>
    <updated>2016-10-25T19:52:46+08:00</updated>
    <id>http://sxgfxm.github.io/blog/2016/10/25/xgchart-readme</id>
    <content type="html"><![CDATA[<h2>Introduction</h2>

<p><a href="https://github.com/sxgfxm/XGChart">XGChart</a>是一个简洁的iOS 图表库，可以快速集成自定义折线图，曲线图和条形图。</p>

<!-- more -->


<h2>Install</h2>

<p>首先，下载<strong>XGChart</strong>，将<strong>XGChart</strong>文件夹拖入工程。</p>

<p><img src="http://ofj92itlz.bkt.clouddn.com/XGChart:import2.jpeg" alt="import" /></p>

<p>然后，导入<strong>XGChart.h</strong>头文件，配置参数，创建即可。</p>

<pre><code class="objective-c">#import "XGChart.h"
</code></pre>

<pre><code class="objective-c"> //  configuration
  XGChartConfiguration *configuration = [[XGChartConfiguration alloc] init];
  configuration.chartType = XGChartTypeLineChart;
  configuration.paddingTop = 20;
  configuration.paddingLeft = 20;
  configuration.paddingBottom = 20;
  configuration.paddingRight = 20;
  configuration.xGridCount = 3;
  configuration.yGridCount = 4;
  configuration.gridColor = [UIColor grayColor];
  configuration.xAxisLabelColor = [UIColor whiteColor];
  configuration.xAxisLabelFontSize = 12;
  configuration.yAxisLabelColor = [UIColor whiteColor];
  configuration.yAxisLabelFontSize = 12;
  NSMutableArray&lt;XGChartPoint *&gt; *chartPoints = [[NSMutableArray alloc] init];
  for (int i = 1; i &lt; 31; i++) {
    XGChartPoint *point =
        [[XGChartPoint alloc] initWithX:i andY:arc4random_uniform(100)];
    [chartPoints addObject:point];
  }
  configuration.chartPoints = chartPoints;
  configuration.strokeColor = [UIColor redColor];
  configuration.fillColor = [UIColor redColor];
  configuration.lineWidth = 3;
  //  line chart
  XGChart *lineChart = [[XGChart alloc]
      initWithFrame:CGRectMake(0, 64, self.view.bounds.size.width,
                               (self.view.bounds.size.height - 64) / 3)
      configuration:configuration];
  lineChart.backgroundColor = [UIColor blackColor];
  [self.view addSubview:lineChart];
</code></pre>

<h2>Result</h2>

<p><img src="http://ofj92itlz.bkt.clouddn.com/XGChart:result2.png" alt="" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ShareSDK接入]]></title>
    <link href="http://sxgfxm.github.io/blog/2016/10/21/sharesdkjie-ru/"/>
    <updated>2016-10-21T14:12:36+08:00</updated>
    <id>http://sxgfxm.github.io/blog/2016/10/21/sharesdkjie-ru</id>
    <content type="html"><![CDATA[<h2>iOS接入ShareSDK实现第三方分享</h2>

<p>因为<strong>友盟</strong>被阿里收购在Android平台的各种令人不悦的后台操作，改用<strong>ShareSDK</strong>实现第三方分享。以下为简单接入流程。详情可参考官方文档<a href="http://wiki.mob.com/ios%E7%AE%80%E6%B4%81%E7%89%88%E5%BF%AB%E9%80%9F%E9%9B%86%E6%88%90/">http://wiki.mob.com/ios%E7%AE%80%E6%B4%81%E7%89%88%E5%BF%AB%E9%80%9F%E9%9B%86%E6%88%90/</a></p>

<!--more-->


<h2>获取AppKey</h2>

<p>在官网注册，并按要求创建应用，获取AppKey，比如为<strong>182947e7afac0</strong>。</p>

<h2>下载所需版本的ShareSDK</h2>

<p>解压后，将<strong>ShareSDK</strong>导入工程中，记得勾选<strong>Copy items into destination group&rsquo;s folder(if needed)</strong>。</p>

<h2>添加依赖库</h2>

<pre><code>//  ShareSDK
libicucore.dylib
libz.dylib
libstdc++.dylib
JavaScriptCore.framework

//  新浪微博SDK
ImageIO.framework
libsqlite3.dylib

//  QQ空间SDK
libsqlite3.dylib

//  微信SDK
libsqlite3.dylib

//  根据需要添加
</code></pre>

<h2>初始化对应的第三方平台</h2>

<p>在<strong>AppDelegate.m</strong>中，导入所需头文件。</p>

<pre><code class="objective-c">#import &lt;ShareSDK/ShareSDK.h&gt;
#import &lt;ShareSDKConnector/ShareSDKConnector.h&gt;

//腾讯开放平台（对应QQ和QQ空间）SDK头文件
#import &lt;TencentOpenAPI/TencentOAuth.h&gt;
#import &lt;TencentOpenAPI/QQApiInterface.h&gt;

//微信SDK头文件
#import "WXApi.h"

//新浪微博SDK头文件
#import "WeiboSDK.h"
//新浪微博SDK需要在项目Build Settings中的Other Linker Flags添加"-ObjC"
</code></pre>

<p>在<code>application:didFinishLaunchingWithOptions:</code>方法中初始化。</p>

<pre><code class="objective-c">- (BOOL)application:(UIApplication *)application
    didFinishLaunchingWithOptions:(NSDictionary *)launchOptions {

  /**
   *  设置ShareSDK的appKey，如果尚未在ShareSDK官网注册过App，请移步到http://mob.com/login
   * 登录后台进行应用注册
   *  在将生成的AppKey传入到此方法中。
   *  方法中的第二个第三个参数为需要连接社交平台SDK时触发，
   *  在此事件中写入连接代码。第四个参数则为配置本地社交平台时触发，根据返回的平台类型来配置平台信息。
   *  如果您使用的时服务端托管平台信息时，第二、四项参数可以传入nil，第三项参数则根据服务端托管平台来决定要连接的社交SDK。
   */
  [ShareSDK registerApp:@"182947e7afac0"

      activePlatforms:@[
        @(SSDKPlatformTypeSinaWeibo),
        @(SSDKPlatformTypeWechat),
        @(SSDKPlatformTypeQQ),
      ]
      onImport:^(SSDKPlatformType platformType) {
        switch (platformType) {
        case SSDKPlatformTypeWechat:
          [ShareSDKConnector connectWeChat:[WXApi class]];
          break;
        case SSDKPlatformTypeQQ:
          [ShareSDKConnector connectQQ:[QQApiInterface class]
                     tencentOAuthClass:[TencentOAuth class]];
          break;
        case SSDKPlatformTypeSinaWeibo:
          [ShareSDKConnector connectWeibo:[WeiboSDK class]];
          break;
        default:
          break;
        }
      }
      onConfiguration:^(SSDKPlatformType platformType,
                        NSMutableDictionary *appInfo) {

        switch (platformType) {
        case SSDKPlatformTypeSinaWeibo:
          //设置新浪微博应用信息,其中authType设置为使用SSO＋Web形式授权
          [appInfo
              SSDKSetupSinaWeiboByAppKey:@"3144028685"
                               appSecret:@"11abfe456bc8eefbab49fe7bbcd90bf0"
                             redirectUri:@"http://www.sharesdk.cn"
                                authType:SSDKAuthTypeBoth];
          break;
        case SSDKPlatformTypeWechat:
          [appInfo SSDKSetupWeChatByAppId:@"wx4868b35061f87885"
                                appSecret:@"64020361b8ec4c99936c0e3999a9f249"];
          break;
        case SSDKPlatformTypeQQ:
          [appInfo SSDKSetupQQByAppId:@"100371282"
                               appKey:@"aed9b0303e3ed1e27bae87c33761161d"
                             authType:SSDKAuthTypeBoth];
          break;
        default:
          break;
        }
      }];
  return YES;
}
</code></pre>

<p>接入不同的平台均需要注册并获取<strong>AppKey</strong>和<strong>AppSecret</strong>值。</p>

<h2>添加分享实现代码</h2>

<p>在<strong>ViewController.m</strong>中触发分享的方法中，添加分享代码。</p>

<pre><code class="objective-c">- (void)shareAction {
  [self.tf endEditing:YES];
  // 1、创建分享参数
  NSArray *imageArray = @[ [UIImage imageNamed:@"junxi5.jpg"] ];
  if (imageArray) {

    NSMutableDictionary *shareParams = [NSMutableDictionary dictionary];
    [shareParams SSDKSetupShareParamsByText:self.tf.text
                                     images:imageArray
                                        url:nil
                                      title:@"Ticwatch Sport"
                                       type:SSDKContentTypeAuto];
    // 2、分享（可以弹出我们的分享菜单和编辑界面）
    [ShareSDK showShareActionSheet:nil
                             items:nil
                       shareParams:shareParams
               onShareStateChanged:^(
                   SSDKResponseState state, SSDKPlatformType platformType,
                   NSDictionary *userData, SSDKContentEntity *contentEntity,
                   NSError *error, BOOL end) {

                 switch (state) {
                 case SSDKResponseStateSuccess: {
                   NSLog(@"分享成功");
                   break;
                 }
                 case SSDKResponseStateFail: {
                   NSLog(@"分享失败");
                   NSLog(@"%@", error);
                   break;
                 }
                 default:
                   break;
                 }
               }];
  }
}
</code></pre>

<h2>添加URL Schemes</h2>

<p> <img src="http://ofj92itlz.bkt.clouddn.com/ShareSDK:WhiteList.jpeg" alt="urlscheme" /></p>

<h2>适配iOS 9问题</h2>

<h3>退回http协议，并设置域</h3>

<p><img src="http://ofj92itlz.bkt.clouddn.com/ShareSDK:Https.jpeg" alt="http" /></p>

<h3>添加scheme白名单</h3>

<p><img src="http://ofj92itlz.bkt.clouddn.com/ShareSDK:UrlScheme.jpeg" alt="白名单" /></p>

<h2>分享平台title为英文问题</h2>

<p>默认语言为英文，需要在项目中添加中文本地化。</p>

<p><img src="http://ofj92itlz.bkt.clouddn.com/ShareSDK:Localization.jpeg" alt="localization" /></p>

<p>如需修改标题可以修改对应的本地化文件。</p>

<p> <img src="http://ofj92itlz.bkt.clouddn.com/ShareSDK:CustomLocalization.jpeg" alt="customLocalization" /></p>

<h2>Github源码</h2>

<p><a href="https://github.com/sxgfxm/ShareSDKDemo">ShareSDKDemo</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[3D Touch]]></title>
    <link href="http://sxgfxm.github.io/blog/2016/10/20/3d-touch/"/>
    <updated>2016-10-20T15:51:27+08:00</updated>
    <id>http://sxgfxm.github.io/blog/2016/10/20/3d-touch</id>
    <content type="html"><![CDATA[<h2>3D Touch简介</h2>

<p>3D Touch是智能手机领域最先进技术之一，目前只有Apple在iPhone上构建了相对良好的生态，并在最新推出的iOS 10中进一步优化了用户体验，Android系统和手机厂商还未提供较为成熟的支持。 本文主要介绍3D Touch相关技术的基本实现方法，包括：</p>

<p>1、Home Screen Quick Actions，主屏幕快捷访问；</p>

<p>2、Peek and Pop，预览和进入；</p>

<p>3、3D Touch Force，3D touch压力值运用。</p>

<!--more-->


<h2>Home Screen Quick Action</h2>

<h3>显示效果</h3>

<p>在主屏幕按下应用图标，会弹出设定好的快捷访问入口。本文采用纯代码创建，也可以通过设置Info.plist实现。</p>

<h3>代码实现</h3>

<p>首先，在<strong>AppDelegate.m</strong>的<code>application:didFinishLaunchingWithOptions:</code>方法中添加<strong>UIApplicationShortcutItems</strong>。</p>

<pre><code class="objective-c">- (BOOL)application:(UIApplication *)application
    didFinishLaunchingWithOptions:(NSDictionary *)launchOptions {
  // Override point for customization after application launch.
  //  主界面入口
  ViewController *vc = [[ViewController alloc] init];
  self.mainNav = [[UINavigationController alloc] initWithRootViewController:vc];
  self.window.rootViewController = self.mainNav;

  //  创建快捷访问Items
  UIApplicationShortcutIcon *icon1 = [UIApplicationShortcutIcon
      iconWithType:UIApplicationShortcutIconTypeTask];
  UIApplicationShortcutItem *item1 =
      [[UIApplicationShortcutItem alloc] initWithType:@"item1"
                                       localizedTitle:@"item1"
                                    localizedSubtitle:@"1"
                                                 icon:icon1
                                             userInfo:nil];
  UIApplicationShortcutIcon *icon2 = [UIApplicationShortcutIcon
      iconWithType:UIApplicationShortcutIconTypeMail];
  UIApplicationShortcutItem *item2 =
      [[UIApplicationShortcutItem alloc] initWithType:@"item2"
                                       localizedTitle:@"item2"
                                    localizedSubtitle:@"2"
                                                 icon:icon2
                                             userInfo:nil];
  //  添加快捷访问Items
  application.shortcutItems = @[ item1, item2 ];
  return YES;
}
</code></pre>

<p>然后，在<strong>AppDelegate.m</strong>中添加如下方法，用于响应快捷访问事件。</p>

<pre><code class="objective-c">- (void)application:(UIApplication *)application
    performActionForShortcutItem:(UIApplicationShortcutItem *)shortcutItem
               completionHandler:(void (^)(BOOL))completionHandler {
  //  响应Item对应的操作，跳转至对应controller
  if ([shortcutItem.type isEqualToString:@"item1"]) {
    Item1ViewController *vc = [[Item1ViewController alloc] init];
    [self.mainNav pushViewController:vc animated:YES];
  }
  if ([shortcutItem.type isEqualToString:@"item2"]) {
    Item2ViewController *vc = [[Item2ViewController alloc] init];
    [self.mainNav pushViewController:vc animated:YES];
  }
}
</code></pre>

<p>运行效果：</p>

<p> <img src="http://ofj92itlz.bkt.clouddn.com/3DTouch:step1.jpeg" alt="step1" /></p>

<h2>Peek and Pop</h2>

<p>3D Touch按压力度可以分为两级，一级力度触发<strong>peek</strong>，二级力度触发<strong>pop</strong>。</p>

<p><strong>peek</strong>相当于<strong>预览</strong>与按压view相关的<strong>view controller</strong>。<strong>pop</strong>相当于<strong>跳转</strong>至对应的<strong>view controller</strong>。</p>

<h3>为view添加3D Touch响应</h3>

<p>本文以UIImageView为例，实现图片的预览效果。</p>

<pre><code class="objective-c">  //  创建ImageView
  self.imageView = [[UIImageView alloc]
      initWithFrame:CGRectMake(self.view.bounds.size.width / 2 - 50, 300, 100,
                               100)];
  self.imageView.image = [UIImage imageNamed:@"junxi3.jpeg"];
  //  非常重要
  self.imageView.userInteractionEnabled = YES;
  [self.view addSubview:self.imageView];
  //  添加3D Touch 响应
  if (self.traitCollection.forceTouchCapability ==
      UIForceTouchCapabilityAvailable) {
    [self registerForPreviewingWithDelegate:self sourceView:self.imageView];
  } else {
    NSLog(@"您的设备不支持3D Touch");
  }
</code></pre>

<p>通过<strong>UIViewController</strong>的 <code>registerForPreviewingWithDelegate:sourceView:</code>方法添加3D Touch响应。需要遵守<strong>UIViewControllerPreviewingDelegate</strong>协议，并实现分别对应<strong>peek</strong>和<strong>pop</strong>的代理方法。</p>

<p>注意，添加3D Touch响应的view，一定要使<strong>userInteractionEnabled = YES</strong>，否则无法响应。</p>

<h3>peek相关代理方法实现</h3>

<p>实现代理方法<code>previewingContext:viewControllerForLocation:</code>，在该代理方法中创建并返回待预览的<strong>view controller</strong>。</p>

<pre><code class="objective-c">//  peek
- (UIViewController *)previewingContext:
                          (id&lt;UIViewControllerPreviewing&gt;)previewingContext
              viewControllerForLocation:(CGPoint)location {
  //  log信息
  NSLog(@"peek");
  NSLog(@"point %@", NSStringFromCGPoint(location));
  NSLog(@"rect %@", NSStringFromCGRect(previewingContext.sourceRect));
  //  创建待预览view controller
  PreviewViewController *previewVC = [[PreviewViewController alloc] init];
  //  设置大小
  previewVC.preferredContentSize = CGSizeMake(0.0f, 0.0f);
  //  设置内容
  previewVC.image = self.imageView.image;
  //  设置高亮显示区域，其他区域会模糊显示
  previewingContext.sourceRect = self.imageView.frame;
  //  返回待预览view controller
  return previewVC;
}
</code></pre>

<p>其中，previewingContext.sourceRect用于设置高亮区域，location为点击手势在view中的位置，preferredContentSize用于设置预览区域大小，为0时系统会设为最佳显示大小。</p>

<p>运行效果：</p>

<p><img src="http://ofj92itlz.bkt.clouddn.com/3DTouch:step2.jpeg" alt="step2" />      <img src="http://ofj92itlz.bkt.clouddn.com/3DTouch:step3.jpeg" alt="step3" /></p>

<h3>在PreviewViewController中添加预览状态快捷选项</h3>

<p>在<strong>peek</strong>状态下，向上滑动，即可弹出快捷选项。</p>

<pre><code class="objective-c">- (NSArray&lt;id&lt;UIPreviewActionItem&gt;&gt; *)previewActionItems {
  // setup a list of preview actions
  UIPreviewAction *action1 = [UIPreviewAction
      actionWithTitle:@"Aciton1"
                style:UIPreviewActionStyleDefault
              handler:^(UIPreviewAction *_Nonnull action,
                        UIViewController *_Nonnull previewViewController) {
                NSLog(@"Aciton1");
              }];

  UIPreviewAction *action2 = [UIPreviewAction
      actionWithTitle:@"Aciton2"
                style:UIPreviewActionStyleDefault
              handler:^(UIPreviewAction *_Nonnull action,
                        UIViewController *_Nonnull previewViewController) {
                NSLog(@"Aciton2");
              }];

  UIPreviewAction *action3 = [UIPreviewAction
      actionWithTitle:@"Aciton3"
                style:UIPreviewActionStyleDefault
              handler:^(UIPreviewAction *_Nonnull action,
                        UIViewController *_Nonnull previewViewController) {
                NSLog(@"Aciton3");
              }];

  NSArray *actions = @[ action1, action2, action3 ];
  return actions;
}
</code></pre>

<p>运行效果：</p>

<p> <img src="http://ofj92itlz.bkt.clouddn.com/3DTouch:step5.jpeg" alt="step4" /></p>

<h3>pop相关代理方法</h3>

<p>实现代理方法<code>previewingContext:commitViewController:</code>，在该代理方法中跳转。</p>

<pre><code class="objective-c">//  pop
- (void)previewingContext:(id&lt;UIViewControllerPreviewing&gt;)previewingContext
     commitViewController:(UIViewController *)viewControllerToCommit {
  //  log信息
  NSLog(@"pop");
  //  跳转至对应view controller
  [self showViewController:viewControllerToCommit sender:self];
}
</code></pre>

<p>运行效果：</p>

<p> <img src="http://ofj92itlz.bkt.clouddn.com/3DTouch:step4.jpeg" alt="step5" /></p>

<h2>3D Touch Force简单运用</h2>

<p>在<code>touchesMoved:withEvent:</code>方法中，获取touch对象，可以根据force属性值做相应操作。</p>

<pre><code class="objective-c">- (void)touchesMoved:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event {
  NSArray *arrayTouch = [touches allObjects];
  UITouch *touch = (UITouch *)[arrayTouch lastObject];
  NSLog(@"force = %f", touch.force);
}
</code></pre>

<h2>参考资料</h2>

<p><a href="https://developer.apple.com/library/content/documentation/UserExperience/Conceptual/Adopting3DTouchOniPhone/#//apple_ref/doc/uid/TP40016543-CH1-SW1">Adopting 3D Touch on iPhone</a></p>

<p><a href="http://www.tuicool.com/articles/auIJbiN">iOS9新特性 3DTouch 开发教程全解</a></p>

<h3>Github源码</h3>

<p><a href="https://github.com/sxgfxm/3DTouchDemo">3DTouchDemo</a></p>
]]></content>
  </entry>
  
</feed>

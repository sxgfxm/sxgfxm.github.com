<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Ios | Light's Blog]]></title>
  <link href="http://sxgfxm.github.io/blog/categories/ios/atom.xml" rel="self"/>
  <link href="http://sxgfxm.github.io/"/>
  <updated>2018-09-20T14:39:27+08:00</updated>
  <id>http://sxgfxm.github.io/</id>
  <author>
    <name><![CDATA[Light]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[iOS知识小集-180910]]></title>
    <link href="http://sxgfxm.github.io/blog/2018/09/17/ioszhi-shi-xiao-ji-180910/"/>
    <updated>2018-09-17T20:42:43+08:00</updated>
    <id>http://sxgfxm.github.io/blog/2018/09/17/ioszhi-shi-xiao-ji-180910</id>
    <content type="html"><![CDATA[<h2>Siri Kit</h2>

<h3>Siri Kit作用</h3>

<p>通过语音完成第三方应用功能，偏向于工具型操作。</p>

<h3>实现机制</h3>

<p><strong>Domain</strong>：业务领域；<br/>
<strong>Intent</strong>：领域中的任务或指令；<br/>
语音识别 &ndash;> Domain / Intent &ndash;> 下发到已注册的Extension进行处理。<br/>
接近固定形式的表述更容易被识别。</p>

<h3>集成</h3>

<p>需要注意develop target系统版本问题。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS知识小集-180903]]></title>
    <link href="http://sxgfxm.github.io/blog/2018/09/10/ioszhi-shi-xiao-ji-180903/"/>
    <updated>2018-09-10T14:34:51+08:00</updated>
    <id>http://sxgfxm.github.io/blog/2018/09/10/ioszhi-shi-xiao-ji-180903</id>
    <content type="html"><![CDATA[<h2>集成Apple Pay</h2>

<h3>权限配置</h3>

<p>按官方指导配置权限。</p>

<h3>调用过程</h3>

<p>引入<code>&lt;PassKit/PassKit.h&gt;</code>，权限判断，支付卡判断，设置商品参数，创建支付请求，显示支付界面，代理接收结果。</p>

<!-- more -->


<pre><code class="objective-c">- (void)useApplePay{
  //  权限判断
  if ([PKPaymentAuthorizationViewController canMakePayments]){
    //  支付卡判断
    if ([PKPaymentAuthorizationViewController canMakePaymentsUsingNetworks:@[PKPaymentNetworkVisa, PKPaymentNetworkChinaUnionPay, PKPaymentNetworkDiscover]]){
      //  设置商品参数
      NSDecimalNumber *amount = [NSDecimalNumber decimalNumberWithString:@"2.33"]
      PKPaymentSummaryItem *item = [PKPaymentSummaryItem summaryItemWithLabel:@"PJChao" amount:amount];
      //  支付请求
      PKPaymentRequest *request = [[PKPaymentRequest alloc] init];
      // 设置商户ID（merchant IDs）
      request.merchantIdentifier = @"com.mobvoi.ApplePayTest";
      // 设置国家代码(中国大陆)
      request.countryCode = @"CN";
      // 设置支付货币(人民币)
      request.currencyCode = @"CNY";
      // 设置商户的支付标准(3DS支付方式必须支持，其他方式可选)
      request.merchantCapabilities = PKMerchantCapability3DS;
      request.paymentSummaryItems = @[item];
      /**
       *  以上参数都是必须的
       *  以下参数不是必须的
       */
      // 设置收据内容
      request.requiredBillingAddressFields = PKAddressFieldAll;
      // 设置送货内容
      request.requiredShippingAddressFields = PKAddressFieldAll;
      // 设置送货方式
      PKShippingMethod *method = [PKShippingMethod summaryItemWithLabel:@"顺丰" amount:[NSDecimalNumber decimalNumberWithString:@"10.00"]];
      method.identifier = @"顺丰物流";
      method.detail = @"12小时到达";
      request.shippingMethods = @[method];
      //  显示支付页面
      PKPaymentAuthorizationViewController *paymentVC = [[PKPaymentAuthorizationViewController alloc] initWithPaymentRequest:request];
      paymentVC.delegate = self;
      if (paymentVC == nil) return;
      [self presentViewController:paymentVC animated:YES completion:nil];
    } else {
      //  跳转至银行卡设置界面
      [[[PKPassLibrary alloc] init] openPaymentSetup];
    }
  }
}

//  代理方法
#pragma mark - PKPaymentAuthorizationViewControllerDelegate
- (void)paymentAuthorizationViewController:(PKPaymentAuthorizationViewController *)controller
                       didAuthorizePayment:(PKPayment *)payment
                                completion:(void (^)(PKPaymentAuthorizationStatus status))completion
{
    /**
     *  在这里支付信息应发送给服务器/第三方的SDK（银联SDK/易宝支付SDK/易智付SDK等）
     *  再根据服务器返回的支付成功与否进行不同处理
     *  这里直接返回支付成功
     */
    completion(PKPaymentAuthorizationStatusSuccess);
}

- (void)paymentAuthorizationViewControllerDidFinish:(PKPaymentAuthorizationViewController *)controller
{
    // 点击支付/取消按钮隐藏界面
    [controller dismissViewControllerAnimated:YES completion:nil];
}
</code></pre>

<h2>集成Touch ID</h2>

<pre><code class="objective-c">- (void)startLocalAuthentication{
  if (NSFoundationVersionNumber &lt; NSFoundationVersionNumber_iOS_8_0) {
    NSLog(@"系统版本不支持TouchID");
  } else {
    LAContext *context = [[LAContext alloc] init];
    context.localizedFallbackTitle = @"请输入密码";
    NSError *error = nil;
    if ([context canEvaluatePolicy:LAPolicyDeviceOwnerAuthenticationWithBiometrics error:&amp;error]) {
      [context evaluatePolicy:LAPolicyDeviceOwnerAuthenticationWithBiometrics localizedReason:@"通过指纹登录" reply:^(BOOL success, NSError * _Nullable error) {
        if (success) {
          dispatch_async(dispatch_get_main_queue(), ^{
            NSLog(@"验证成功");
          });
        } else {
          NSLog(@"验证失败");
        }
      }];
    } else {
      NSLog(@"当前设备不支持TouchID");
    }
  }
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS知识小集-180827]]></title>
    <link href="http://sxgfxm.github.io/blog/2018/09/03/ioszhi-shi-xiao-ji-180827/"/>
    <updated>2018-09-03T11:36:54+08:00</updated>
    <id>http://sxgfxm.github.io/blog/2018/09/03/ioszhi-shi-xiao-ji-180827</id>
    <content type="html"><![CDATA[<h2>lldb</h2>

<h3>什么是lldb</h3>

<p>LLDB是个开源的内置于XCode的具有REPL(read-eval-print-loop)特征的Debugger，其可以安装C++或者Python插件。</p>

<!-- more -->


<h3>expression</h3>

<p>执行一个表达式，并将结果输出。</p>

<h4>expression</h4>

<p><code>expression -- self.view.backgroundColor = [UIColor redColor]</code>
<code>expression -- (void)[CATransaction flush]</code></p>

<h4>print、p、call</h4>

<p>expression的别名，常用与输出某个变量。</p>

<h4>po</h4>

<p>等价于<code>expression -O -- variable</code>，输出对象本身的信息，而非对象地址。</p>

<h3>thread</h3>

<p>与线程相关操作，可以查看调用栈信息，修改返回值。</p>

<h4>thread backtrace、bt</h4>

<p>打印当前线程的调用栈信息，可以设置打印帧数，从哪个帧开始打印，是否额外显示回溯。</p>

<h4>thread return</h4>

<p>修改某个函数的返回值。</p>

<h4>c、n、s、finish</h4>

<p>continue、next、step in、step out。</p>

<h3>breakpoint</h3>

<p>与断点相关操作，可以设置单个断点、批量设置断点、为断点增加命令，删除断点及断点命令。</p>

<h4>breakpoint set</h4>

<p>设置断点，可以指定<code>-n</code>方法名，<code>-f</code>文件名，<code>-l</code>行数，<code>-o</code>单次断点。</p>

<h4>breakpoint list</h4>

<p>查看断点。</p>

<h4>breakpoint disable/enable</h4>

<p>设置断点可用、不可用。</p>

<h4>breakpoint delete</h4>

<p>删除断点。</p>

<h4>breakpoint command add</h4>

<p>设置断点命令，可以指定<code>-o</code>单行命令，或多行命令。</p>

<h4>breakpoint command list</h4>

<p>查看断点命令。</p>

<h4>breakpoint command delete</h4>

<p>删除断点命令。</p>

<h3>watchpoint</h3>

<p>为地址设置断点。</p>

<h4>watchpoint set</h4>

<p>添加观察点，只可接受变量。</p>

<h4>watchpoint list</h4>

<p>查看观察点。</p>

<h4>breakpoint disable/enable</h4>

<p>设置观察点可用、不可用。</p>

<h4>watchpoint delete</h4>

<p>删除观察点。</p>

<h4>watchpoint command add</h4>

<p>设置观察点命令。</p>

<h4>watchpoint command list</h4>

<p>查看观察点命令。</p>

<h4>watchpoint command delete</h4>

<p>删除观察点命令。</p>

<h3>target</h3>

<p>查找地址对应代码位置。</p>

<h4>target modules lookup、image lookup</h4>

<p>查找地址对应代码位置。</p>

<h4>target stop-hook</h4>

<p>停止时执行代码。</p>

<h3>extension</h3>

<p><code>~/.lldbinit</code>中设置扩展。</p>

<h3>help</h3>

<p>查看命令帮助，如<code>help</code>，<code>apropos</code>。</p>

<h3>shortcut</h3>

<p>快捷键。<br/>
暂停/继续   cmd + ctrl + Y<br/>
断点失效/生效 cmd + Y<br/>
控制台显示/隐藏    cmd + shift + Y<br/>
光标切换到控制台    cmd + shift + C<br/>
清空控制台   cmd + K<br/>
step over   F6<br/>
step into   F7<br/>
step out    F8</p>

<h3>script</h3>

<p>执行Python脚本</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS知识小集-180820]]></title>
    <link href="http://sxgfxm.github.io/blog/2018/08/30/ioszhi-shi-xiao-ji-180820/"/>
    <updated>2018-08-30T10:24:16+08:00</updated>
    <id>http://sxgfxm.github.io/blog/2018/08/30/ioszhi-shi-xiao-ji-180820</id>
    <content type="html"><![CDATA[<h2>获取textview光标所在位置</h2>

<pre><code class="objective-c">- (NSUInteger)currentLocation:(UITextView*)textView{
  NSRange range = textView.selectionRange;
  if (range.location == NSNotFound) {
    return textView.text.length;
  }
  return range.location;
}
</code></pre>

<!-- more -->


<h2>超出父视图的子视图响应手势事件</h2>

<pre><code class="objective-c">- (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event {
    UIView *view = [super hitTest:point withEvent:event];
    if (view == nil) {
        for (UIView *subView in self.subviews) {
            CGPoint tp = [subView convertPoint:point fromView:self];
            if (CGRectContainsPoint(subView.bounds, tp)) {
                view = subView;
            }
        }
    }
    return view;
}

- (BOOL)pointInside:(CGPoint)point withEvent:(UIEvent *)event{
    //if内的条件应该为，触摸点属于子视图范围
    if (.....){
     return YES;
    }
    return NO;
}
</code></pre>

<h2>CALayer阴影</h2>

<p>默认<code>shadowOpacity = 0</code>，需要手动设置才能显示出来阴影。</p>

<h2>Macbook Pro触摸板突然失效</h2>

<p>键盘检测出现问题，盒盖过一会儿再打开即可。</p>

<h2>ARKit</h2>

<h3>什么是AR</h3>

<p>VR，Virtual Reality，虚拟现实，纯虚拟数字画面；<br/>
AR，Augmented Reality，现实增强，裸眼现实 + 虚拟数字画面；<br/>
MR，Mediated Reality，介导现实，数字化现实 + 虚拟数字画面；</p>

<h3>什么是ARKit</h3>

<p>ARKit 是一个移动端 AR 平台，用于在 iOS 上开发增强现实 APP；<br/>
ARKit 提供了接口简单的高级 API，有一系列强大的功能，从 iOS11 开始支持；</p>

<h3>ARKit有哪些功能</h3>

<h4>追踪</h4>

<p>世界追踪；</p>

<h4>场景理解</h4>

<p>平面识别，命中测试；</p>

<h4>渲染</h4>

<p>整合任意渲染程序；</p>

<h3>如何使用ARKit</h3>

<h4>ARSession</h4>

<p>1、管理增强现实所有处理流程的类：可带参数配置，且可以开始处理流程或暂停处理流程或切换处理流程；<br/>
2、重置追踪；<br/>
3、获取处理结果ARFrame，通过代理或者直接获取currentFrame；</p>

<h4>ARSessionConfiguration</h4>

<h4>ARFrame</h4>

<p>1、相机图像作为渲染场景背景；<br/>
2、提供设备追踪信息，如设备角度、位置、追踪状态；<br/>
3、提供场景理解，如特征点、空间物理位置及光线估算；</p>

<h4>ARAnchor</h4>

<p>空间中先对真实世界的位置和角度。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS知识小集-180813]]></title>
    <link href="http://sxgfxm.github.io/blog/2018/08/20/ioszhi-shi-xiao-ji-180813/"/>
    <updated>2018-08-20T11:43:27+08:00</updated>
    <id>http://sxgfxm.github.io/blog/2018/08/20/ioszhi-shi-xiao-ji-180813</id>
    <content type="html"><![CDATA[<h2>动画结束后使layer保持动画后的状态</h2>

<p>需要同时设置<code>animation.removedOnCompletion = NO</code>和<code>animation.fillMode = kCAFillModeForwards</code>。</p>

<!-- more -->


<h2>UILabel增加模糊文字阴影</h2>

<p><code>UILabel</code>的<code>shadowOffset</code>和<code>shadowColor</code>可以设置无模糊效果的阴影，如果需要设置模糊效果文字阴影，需要使用<code>NSAttributedString</code>增加<code>NSShadowAttributeName</code>阴影对应的参数。下面是UILabel设置阴影的一个Category方法：  <br/>
<code>objective-c
//  UILabel+Util.m
- (void)setText:(NSString *)text lineSpacing:(CGFloat)lineSpacing shadowColor:(UIColor *)shadowColor{
  if (!text) {
    self.text = text;
    return;
  }
  NSRange range = NSMakeRange(0, text.length);
  NSMutableAttributedString *attributedString = [[NSMutableAttributedString alloc] initWithString:text];
  //  font
  [attributedString addAttribute:NSFontAttributeName value:self.font range:range];
  //  color
  [attributedString addAttribute:NSForegroundColorAttributeName value:self.textColor range:range];
  //  shadow
  if (shadowColor) {
    NSShadow *shadow = [NSShadow new];
    shadow.shadowBlurRadius = 4;
    shadow.shadowOffset = CGSizeMake(0, 2);
    shadow.shadowColor = shadowColor;
    [attributedString addAttribute:NSShadowAttributeName value:shadow range:range];
  }
  //  style
  NSMutableParagraphStyle *paragraphStyle = [[NSMutableParagraphStyle alloc] init];
  [paragraphStyle setLineBreakMode:self.lineBreakMode];
  [paragraphStyle setAlignment:self.textAlignment];
  if (lineSpacing &gt; 0) {
    [paragraphStyle setLineSpacing:lineSpacing];
  }
  [attributedString addAttribute:NSParagraphStyleAttributeName
                           value:paragraphStyle
                           range:range];
  //  attributed string
  self.attributedText = attributedString;
}
</code></p>

<h2>UILabel逐行显示动画</h2>

<p>增加一个Category方法使<code>UILabel</code>文字逐行显示，需要思想是为<code>UILabel</code>增加一个渐变的maskLayer，并用动画修改渐变的位置。  <br/>
<code>objective-c
//  UILabel+Util.m
- (void)startLineAnimationWithDuration:(CGFloat)duration{
  //  layout
  [self layoutIfNeeded];
  //  gradient layer
  CAGradientLayer *gradientLayer = [CAGradientLayer layer];
  gradientLayer.frame = self.bounds;
  gradientLayer.locations = @[@0, @0, @0, @1];
  gradientLayer.colors = @[(__bridge id)[UIColor whiteColor].CGColor,
                           (__bridge id)[UIColor whiteColor].CGColor,
                           (__bridge id)[UIColor clearColor].CGColor,
                           (__bridge id)[UIColor clearColor].CGColor,
                           ];
  gradientLayer.startPoint = CGPointMake(0, 0);
  gradientLayer.endPoint = CGPointMake(0, 1);
  //  set mask
  self.layer.mask = gradientLayer;
  //  animate locations
  CABasicAnimation *animation = [CABasicAnimation animationWithKeyPath:@"locations"];
  animation.fromValue = @[@0, @(-0.2), @0, @1];
  animation.toValue = @[@0, @1, @1.2, @1];
  animation.duration = duration;
  animation.timingFunction = [CAMediaTimingFunction functionWithName:@"easeInEaseOut"];
  animation.removedOnCompletion = NO;
  animation.fillMode = kCAFillModeForwards;
  //  add animation
  [gradientLayer addAnimation:animation forKey:@"animation"];
}
</code></p>
]]></content>
  </entry>
  
</feed>

<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Ios | Light's Blog]]></title>
  <link href="http://sxgfxm.github.io/blog/categories/ios/atom.xml" rel="self"/>
  <link href="http://sxgfxm.github.io/"/>
  <updated>2017-03-27T10:01:29+08:00</updated>
  <id>http://sxgfxm.github.io/</id>
  <author>
    <name><![CDATA[Light]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[iOS知识小集-170320]]></title>
    <link href="http://sxgfxm.github.io/blog/2017/03/27/ioszhi-shi-xiao-ji-170320/"/>
    <updated>2017-03-27T09:58:51+08:00</updated>
    <id>http://sxgfxm.github.io/blog/2017/03/27/ioszhi-shi-xiao-ji-170320</id>
    <content type="html"><![CDATA[<h2>iOS系统分享</h2>

<p>需增加版本判断：<code>UIActivityTypeOpenInIBooks</code>iOS 9.0之后才有。</p>

<h2>iOS导出音乐</h2>

<p>如何导出mp3：先按mov格式导出，再转为mp3。<br/>
如何包含metadata信息：m4a格式自动包含metadata信息，mp3无。<br/>
路径去除特殊字符。</p>

<!-- more -->


<h2>GCDWebserver后台运行</h2>

<p>设置option</p>

<pre><code>- (BOOL)startServer {
  for (int i = 0; i &lt; 10; i++) {
    //  随机端口号
    NSInteger port = arc4random_uniform(64510) + 1025;
    NSDictionary *options = @{
      GCDWebServerOption_ConnectedStateCoalescingInterval : @(20),
      GCDWebServerOption_Port : @(port)
    };
    NSError *error = nil;
    if ([self.webServer startWithOptions:options error:&amp;error]) {
      DDLogDebug(@"Start local server: %@", self.webServer.serverURL);
      return YES;
    }
  }
  return NO;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS知识小集-170313]]></title>
    <link href="http://sxgfxm.github.io/blog/2017/03/20/ioszhi-shi-xiao-ji-170313/"/>
    <updated>2017-03-20T16:50:46+08:00</updated>
    <id>http://sxgfxm.github.io/blog/2017/03/20/ioszhi-shi-xiao-ji-170313</id>
    <content type="html"><![CDATA[<h2>Masonry</h2>

<p>需要先添加到父视图，再设置约束。<br/>
block中无需使用weakself。<br/>
添加约束：makeConstrains。<br/>
更新约束：updateConstrains，与之相关的布局自动调整。<br/>
重设约束：remakeConstrains，删除之前的约束重新添加。</p>

<pre><code>[self.view updateConstraints:^(MASConstraintMaker *make){
  //  updateConstraints
}];
[self.view updateConstraints];
[self.view setNeedsLayout];
[UIView animateWithDuration:3 animations:^{
  [self.view layoutIfNeeded];
}];
</code></pre>

<!-- more -->


<h2>Autolayout</h2>

<p><code>setNeedsLayout</code>：使当前布局失效，并在下一个更新循环中触发布局更新，遍历view的结构。<br/>
<code>layoutIfNeeded</code>：强制立即更新布局，可以实现动画效果。<br/>
scrollview自动布局：添加tmpview，在tmpview上添加view，最后约束tmpview和contentsize。</p>

<h2>退出viewcontroller事件监听</h2>

<h2>IQActionSheetPickerView</h2>

<pre><code>IQActionSheetPickerView *picker = [IQActionSheetPickerView actionSheetWithTitle:@"Age" delegate:self];
NSArray *dataSource = @[@"10",@"20",@"30",@"40",@"50",@"60"];
[picker setTitlesForComponents:@[dataSource]];
[picker setSelectedTitles:@[@"20"]];
[picker show];
</code></pre>

<p>代理回调</p>

<pre><code>- (void)actionSheetPickerView:(IQActionSheetPickerView *)pickerView didSelectTitles:(NSArray *)titles {
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS知识小集-170306]]></title>
    <link href="http://sxgfxm.github.io/blog/2017/03/10/ioszhi-shi-xiao-ji-170306/"/>
    <updated>2017-03-10T17:00:41+08:00</updated>
    <id>http://sxgfxm.github.io/blog/2017/03/10/ioszhi-shi-xiao-ji-170306</id>
    <content type="html"><![CDATA[<h2>异步回调</h2>

<ol>
<li>明确知道操作执行完成；</li>
<li>操作时间未知；</li>
</ol>


<!-- more -->


<h2>Block</h2>

<ol>
<li>对block中的内容强引用；</li>
<li>循环引用，类A的强property类B的强property block强引用self；</li>
<li>单例不用管循环引用；</li>
</ol>


<h2>内存划分</h2>

<ol>
<li>全局区；</li>
<li>静态区；</li>
<li>堆区；</li>
<li>栈区；</li>
</ol>


<h2>单例</h2>

<ol>
<li>如何创建单例？</li>
<li>何时创建单例？</li>
<li>单例的特性？</li>
</ol>


<h2>NSOperation</h2>

<pre><code>-(void)start;
-(void)main;
-(void)cancel;
-(void)addDependency:(NSOperation*)op;
-(void)removeDependency:(NSOperation*)op;
@property BOOL executing;
@property BOOL cancelled;
@property BOOL finished;
@property copy void (^completionBlock)(void);
</code></pre>

<p>使用方法：<br/>
1、继承NSOperation，通过init方法初始化，重写main方法执行任务；<br/>
2、可以通过completionBlock设置执行完成回调；<br/>
3、可以方便的判断任务执行状态，取消任务等；<br/>
4、可以添加和删除依赖关系，依赖其他operation的执行；<br/>
5、可以通过NSCondition阻塞，加锁，生产者-消费者；</p>

<h2>NSOperationQueue</h2>

<pre><code>@property NSInteger maxCoucurrentOperationCount;
@property NSInteger operationCount;
-(void)addOperation:(NSOperation*)op;
-(void)cancelAllOperations;
-(void)waitUntilAllOperationsAreFinished;
</code></pre>

<p>使用方法：<br/>
1、初始化NSOperationQueue，设置同时可并行任务数量；<br/>
2、创建任务，并将其加入队列中，任务自动开始执行；<br/>
3、可以通过operationCount判断还有多少任务未执行；</p>

<h2>HealthKit</h2>

<p>功能：存放健康数据，自动合并；<br/>
读：读某一类别健康数据；<br/>
写：写某一类别健康数据；<br/>
改：改自己写的健康数据。<br/>
锁屏时无法读数据，保护用户数据安全。</p>

<h2>UIPasteboard</h2>

<p>将信息写到剪切板中。</p>

<pre><code>UIPasteboard *pasteboard = [UIPasteboard generalPasteboard];
[pasteboard setString:string];
</code></pre>

<h2>发送本地通知</h2>

<pre><code>// 创建一个本地推送
UILocalNotification *notification = [UILocalNotification new];
if (notification != nil) {
  // 推送声音
  notification.soundName = UILocalNotificationDefaultSoundName;
  // 推送内容
  notification.alertBody = NSLocalizedString(@"stopWatch.timing", @"已将打点计时信息复制到剪切板");
  // 显示在icon上的红色圈中的数子
  notification.applicationIconBadgeNumber++;
  // 设置userinfo 方便在之后需要撤销的时候使用
  NSDictionary *info = [NSDictionary dictionaryWithObject:kStopWatchKey forKey:kNotificationKey];
  notification.userInfo = info;
  // 添加推送到UIApplication
  UIApplication *app = [UIApplication sharedApplication];
  [app scheduleLocalNotification:notification];
}
</code></pre>

<h2>string label</h2>

<pre><code>NSStringDrawingUsesLineFragmentOrigin | NSStringDrawingUsesFontLeading
ceil()
</code></pre>

<h2>相册和相机</h2>

<p>取消选择照片和选择没有照片是不同的回调。<br/>
相片可以编辑，相机不可以编辑。</p>

<h2>类方法、类变量、单例</h2>

<h2>埋点</h2>

<p>点击量；<br/>
人次；<br/>
存留；<br/>
停留时间；</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS知识小集-170227]]></title>
    <link href="http://sxgfxm.github.io/blog/2017/03/06/ioszhi-shi-xiao-ji-170227/"/>
    <updated>2017-03-06T16:15:46+08:00</updated>
    <id>http://sxgfxm.github.io/blog/2017/03/06/ioszhi-shi-xiao-ji-170227</id>
    <content type="html"><![CDATA[<h2>OC中的锁</h2>

<pre><code>@implementation TestObj

-(void)method1{
  NSLog(@"Method1");
}
-(void)method2{
  NSLog(@"Method2");
}

@end
</code></pre>

<!--more-->


<h3>NSLock</h3>

<pre><code>NSLock *lock = [[NSLock alloc] init];
//线程1
dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
    [lock lock];
    [obj method1];
    sleep(10);
    [lock unlock];
});
//线程2
dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
    sleep(1);//以保证让线程2的代码后执行
    [lock lock];
    [obj method2];
    [lock unlock];
});
</code></pre>

<h3>synchronized关键字。</h3>

<pre><code>//主线程中
TestObj *obj = [[TestObj alloc] init];
//线程1
dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
    @synchronized(obj){
        [obj method1];
        sleep(10);
    }
});
//线程2
dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
    sleep(1);
    @synchronized(obj){
        [obj method2];
    }
});
</code></pre>

<h3>phread_mutex_t。</h3>

<pre><code>//主线程中
TestObj *obj = [[TestObj alloc] init];
__block pthread_mutex_t mutex;
pthread_mutex_init(&amp;mutex, NULL);
//线程1
dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
    pthread_mutex_lock(&amp;mutex);
    [obj method1];
    sleep(5);
    pthread_mutex_unlock(&amp;mutex);
});
//线程2
dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
    sleep(1);
    pthread_mutex_lock(&amp;mutex);
    [obj method2];
    pthread_mutex_unlock(&amp;mutex);
});
</code></pre>

<h3>GCD。</h3>

<pre><code>//主线程中
TestObj *obj = [[TestObj alloc] init];
dispatch_semaphore_t semaphore = dispatch_semaphore_create(1);
//线程1
dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
    dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);
    [obj method1];
    sleep(10);
    dispatch_semaphore_signal(semaphore);
});
//线程2
dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
    sleep(1);
    dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);
    [obj method2];
    dispatch_semaphore_signal(semaphore);
});
</code></pre>

<h2>生成圆形透明背景图片</h2>

<pre><code>+ (UIImage *)circularScaleAndCropImage:(UIImage *)image {
  // Create the bitmap graphics context
  UIGraphicsBeginImageContextWithOptions(CGSizeMake(image.size.width, image.size.height), NO, 0.0);
  CGContextRef context = UIGraphicsGetCurrentContext();

  // Get the width and heights
  CGFloat imageWidth = image.size.width;
  CGFloat imageHeight = image.size.height;

  // Calculate the centre of the circle
  CGFloat imageCentreX = imageWidth / 2;
  CGFloat imageCentreY = imageHeight / 2;

  // Create and CLIP to a CIRCULAR Path
  CGFloat radius = imageWidth / 2;
  CGContextBeginPath(context);
  CGContextAddArc(context, imageCentreX, imageCentreY, radius, 0, 2 * M_PI, 0);
  CGContextClosePath(context);
  CGContextClip(context);

  // Draw the IMAGE
  CGRect myRect = CGRectMake(0, 0, imageWidth, imageHeight);
  [image drawInRect:myRect];

  UIImage *newImage = UIGraphicsGetImageFromCurrentImageContext();
  UIGraphicsEndImageContext();

  return newImage;
}
</code></pre>

<h2>RxJava</h2>

<p>响应式函数编程<br/>
订阅的思想<br/>
多层异步回调逻辑更清晰</p>

<h2>Socket</h2>

<p><strong>Packet-based communication</strong><br/>
<strong>Stream-based clients </strong></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS知识小集-170220]]></title>
    <link href="http://sxgfxm.github.io/blog/2017/03/06/ioszhi-shi-xiao-ji-170220/"/>
    <updated>2017-03-06T16:06:34+08:00</updated>
    <id>http://sxgfxm.github.io/blog/2017/03/06/ioszhi-shi-xiao-ji-170220</id>
    <content type="html"><![CDATA[<h2>App生命周期</h2>

<p><strong>main.m</strong>：app程序入口，将控制权交给UIKit framework。<br/>
<strong>UIApplication</strong>：管理事件循环和高级行为，传递通知给代理。<br/>
<strong>App Delegate</strong>：处理应用初始化，状态转换，等高级行为。每个应用都要有。<br/>
<strong>Data Model</strong>：存储应用数据。<br/>
<strong>View Controller</strong>：管理应用展示内容。<br/>
<strong>View</strong>：展示内容。<br/>
<strong>Main Run Loop</strong>：Main run loop由UIApplication在主线程中开启，保证用户操作串行执行。
用户操作 -> 操作系统 -> 端口 -> 事件队列 -> Main run loop -> App object -> Core object
-> 操作系统 -> 屏幕反馈。<br/>
<strong>执行状态</strong>：<br/>
- 关闭状态。<br/>
- 未激活状态：在前台运行，但未接收到事件。<br/>
- 激活状态：在前台运行，接收到事件。<br/>
- 后台状态：在后台，且正在执行程序，通常会接着进入挂起状态。<br/>
- 挂起状态：在后台，且没有执行程序。当内存不足时会清理挂起应用。</p>

<!--more-->


<h2>后台执行</h2>

<p><strong>限时操作</strong>：调用<code>beginBackgroundTaskWithName:expirationHandler:</code>或<code>beginBackgroundTaskWithExpirationHandler:</code>开启后台执行，在执行完成后必须调用<code>endBackgroundTask:</code>表示结束后台执行，否则程序会被终止。可以通过<code>application.backgroundTimeRemaining</code>查看剩余后台执行时间，一般为180秒。</p>

<pre><code>- (void)applicationDidEnterBackground:(UIApplication *)application
{
    bgTask = [application beginBackgroundTaskWithName:@"MyTask" expirationHandler:^{
        // Clean up any unfinished task business by marking where you
        // stopped or ending the task outright.
        [application endBackgroundTask:bgTask];
        bgTask = UIBackgroundTaskInvalid;
    }];

    // Start the long-running task and return immediately.
    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{

        // Do the work associated with the task, preferably in chunks.

        NSLog(@"begin %.f", application.backgroundTimeRemaining);
        [NSThread sleepForTimeInterval:10];
        NSLog(@"end %.f", application.backgroundTimeRemaining);

        [application endBackgroundTask:bgTask];
        bgTask = UIBackgroundTaskInvalid;
    });
}
</code></pre>

<p><strong>下载操作</strong>：必须使用<strong>NSURLSession</strong>开启下载操作，需要通过<strong>NSURLSessionConfiguration</strong>进行设置。</p>

<pre><code>- (void)startDownloadTask {
  //  Configuration
  NSURLSessionConfiguration *config = [NSURLSessionConfiguration
      backgroundSessionConfigurationWithIdentifier:@"DownloadTask"];
  //  下载完成时唤醒应用
  config.sessionSendsLaunchEvents = YES;
  //  在前台时开启下载任务时有效
  config.discretionary = YES;
  //  NSURLSession
  NSURLSession *session = [NSURLSession sessionWithConfiguration:config];
  //  开启下载任务
  NSURLSessionTask *task =
      [session dataTaskWithURL:[NSURL URLWithString:@"www.baidu.com"]
             completionHandler:^(NSData *_Nullable data,
                                 NSURLResponse *_Nullable response,
                                 NSError *_Nullable error){

             }];
  //  当挂起时恢复任务
  [task resume];
}
</code></pre>

<p><strong>耗时操作</strong>：只有特殊的耗时操作可以在后台被执行，且必须申请权限。如后台音乐播放、录音、定位信息更新、蓝牙连接、远程通知、语音服务等。</p>

<h2>ViewController生命周期</h2>

<h2>权限操作</h2>

<p>iOS 10开始，获取<strong>隐私</strong>敏感数据需要在<strong>plist.info</strong>文件中配置，否则app会crash。<br/>
配置方法：添加对应权限的key和value，value不许为空。<br/>
常用权限：</p>

<ul>
<li>Network：无需添加key</li>
<li>Location：Privacy - Location Always Usage Description</li>
<li>Photo：Privacy - Photo Library Usage Description</li>
<li>Camera：Privacy - Camera Usage Description</li>
<li>Microphone：Privacy - Microphone Usage Description</li>
<li>Contact：Privacy - Contacts Usage Description</li>
<li>Media：Privacy - Media Library Usage Description</li>
</ul>


<p>手动请求权限：当用户拒绝授权某权限时，需要手动再次请求。<br/>
跳转至权限设置界面：</p>

<pre><code>[[UIApplication sharedApplication]
                openURL:[NSURL URLWithString:UIApplicationOpenSettingsURLString]
                options:@{}
      completionHandler:nil];
</code></pre>

<p><a href="https://github.com/sxgfxm/AuthorizationDemo">Demo地址</a></p>

<h2>文件操作</h2>

<ul>
<li>NSString I/O</li>
<li>NSArray I/O</li>
<li>NSDictionary I/O</li>
<li>NSData I/O</li>
<li>NSObject I/O</li>
<li>NSFileManager</li>
<li>NSFileHandle</li>
</ul>


<p><a href="https://github.com/sxgfxm/FileOperationDemo">Demo地址</a></p>

<h2>weakself</h2>

<p>作用：<strong>防止循环引用</strong>。<br/>
声明：<code>__weak typeof(self) weakself = self;</code>。<br/>
使用：
1. 是不是所有的block中都需要使用weakself？<br/>
   Masonry自动约束中无需使用weakself。
2. 详细解释循环引用及防止方法？</p>

<h2>单元测试</h2>

<blockquote><p>If your code isn’t easy to test, it’s not going to be easy to maintain or debug.</p></blockquote>

<p>验证某个类的某种行为在某种上下文中能得到预期结果。<br/>
保证每个测试用例所针对的仅仅是一个基本单元，而不是一个有很多复杂依赖的综合行为。<br/>
依赖于抽象而不是具体实现细节。<br/>
不应关注于<strong>测试</strong>，而应关注<strong>行为</strong>。测试对象的行为方式。<br/>
降低未来的变化所带来的成本。<br/>
<strong>功能检测</strong><br/>
<strong>依赖提取</strong><br/>
<strong>依赖注入</strong><br/>
<strong>行为方式</strong><br/>
1. 单元测试测什么？<br/>
   方法？行为？<br/>
2. 如何处理依赖关系？<br/>
   Mock？Stub？<br/>
3. 单元测试的优缺点？<br/>
   优点：验证模块的功能正确，行为正确，模块化编程，尽早发现问题，检验修改，重构；<br/>
   缺点：增加代码量，写好测试不容易，不能保证不出错，考虑后期维护，尽量减少源代码耦合。<br/>
4. 测试库？<br/>
   <a href="https://github.com/jonreid/OCMockito">OCMockito</a><br/>
5. 断言？<br/>
   同步断言？异步断言（block，代理）？</p>

<h2>A/B Test</h2>

<h2>同步策略</h2>

<h2>JavaScriptCore</h2>

<p><strong>JSContext</strong>：是运行JavaScript代码的环境。<br/>
<strong>JSValue</strong>：JSContext的运行结果封装在JSValue中。<br/>
OC -> JavaScript：<strong>SubscriptValue</strong>、<strong>CallFunction</strong>，<strong>HandleException</strong>。<br/>
JavaScript -> OC：<strong>Block</strong>或<strong>JSExport</strong>。</p>
]]></content>
  </entry>
  
</feed>

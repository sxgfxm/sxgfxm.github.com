<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Ios | Light's Blog]]></title>
  <link href="http://sxgfxm.github.io/blog/categories/ios/atom.xml" rel="self"/>
  <link href="http://sxgfxm.github.io/"/>
  <updated>2017-07-24T09:37:54+08:00</updated>
  <id>http://sxgfxm.github.io/</id>
  <author>
    <name><![CDATA[Light]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[iOS知识小集-170717]]></title>
    <link href="http://sxgfxm.github.io/blog/2017/07/24/ioszhi-shi-xiao-ji-170717/"/>
    <updated>2017-07-24T09:36:53+08:00</updated>
    <id>http://sxgfxm.github.io/blog/2017/07/24/ioszhi-shi-xiao-ji-170717</id>
    <content type="html"><![CDATA[<h2>Set UITableViewHeaderFooterView backgroundColor transparent</h2>

<pre><code>self.backgroundView = [[UIImageView alloc] initWithImage:[UIImage new]];
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS知识小集-170710]]></title>
    <link href="http://sxgfxm.github.io/blog/2017/07/15/ioszhi-shi-xiao-ji-170710/"/>
    <updated>2017-07-15T15:08:46+08:00</updated>
    <id>http://sxgfxm.github.io/blog/2017/07/15/ioszhi-shi-xiao-ji-170710</id>
    <content type="html"><![CDATA[<h2><a href="https://github.com/airbnb/lottie-ios">Lottie</a></h2>

<p>Lottie is a mobile library for Android and iOS that parses Adobe After Effects animations exported as json with bodymovin and renders the vector animations natively on mobile and through React Native!<br/>
Common Animations</p>

<pre><code>LOTAnimationView *animation = [LOTAnimationView animationNamed:@"Lottie"];
[self.view addSubview:animation];
[animation playWithCompletion:^(BOOL animationFinished) {
  // Do Something
}];
</code></pre>

<!-- more -->


<p>UIViewController Transition</p>

<pre><code>- (id&lt;UIViewControllerAnimatedTransitioning&gt;)animationControllerForPresentedController:(UIViewController *)presented
                                                                  presentingController:(UIViewController *)presenting
                                                                      sourceController:(UIViewController *)source {
  LOTAnimationTransitionController *animationController = [[LOTAnimationTransitionController alloc] initWithAnimationNamed:@"vcTransition1"
                                                                                                          fromLayerNamed:@"outLayer"
                                                                                                            toLayerNamed:@"inLayer"];
  return animationController;
}

- (id&lt;UIViewControllerAnimatedTransitioning&gt;)animationControllerForDismissedController:(UIViewController *)dismissed {
  LOTAnimationTransitionController *animationController = [[LOTAnimationTransitionController alloc] initWithAnimationNamed:@"vcTransition2"
                                                                                                          fromLayerNamed:@"outLayer"
                                                                                                            toLayerNamed:@"inLayer"];
  return animationController;
}
</code></pre>

<h2>导航栏设为透明</h2>

<pre><code>[self.navigationController.navigationBar setBackgroundImage:[UIImage new] forBarMetrics:UIBarMetricsDefault];
[self.navigationController.navigationBar setShadowImage:[UIImage new]];
</code></pre>

<h2>导航栏还原</h2>

<pre><code>[self.navigationController.navigationBar setBackgroundImage:nil forBarMetrics:UIBarMetricsDefault];
[self.navigationController.navigationBar setShadowImage:nil];
</code></pre>

<h2>Change UITextField Placeholder Color</h2>

<pre><code>  NSString *string = @"请输入Wi-Fi名称";
  NSMutableAttributedString *attributedString = [[NSMutableAttributedString alloc] initWithString:string];
  [attributedString addAttribute:NSForegroundColorAttributeName value:[UIColor whiteColor] range:NSMakeRange(0, string.length)];
  self.wifiNameTF.attributedPlaceholder = attributedString;
</code></pre>

<h2>KVO NSKeyValueObservingOptions</h2>

<p>NSKeyValueObservingOptionNew：获取新值<br/>
NSKeyValueObservingOptionOld：获取旧值<br/>
NSKeyValueObservingOptionInitial：获取初始值<br/>
NSKeyValueObservingOptionPrior：获取新旧值</p>

<h2>UITextField nil While Editing</h2>

<pre><code>- (BOOL)textField:(UITextField*)textField shouldChangeCharactersInRange:(NSRange)range replacementString:(NSString*)string
{
    if (range.location == 0 &amp;&amp; string.length == 0)
    {
        //textField is empty
    }
    return YES;
}
</code></pre>

<h2>UIKeyboardAppearance</h2>

<pre><code>textField.keyboardAppearance = UIKeyboardAppearanceDark;
</code></pre>

<h2>UIView Transition Animation</h2>

<pre><code>[UIView transitionFromView:view1
                   toView:view2
                 duration:2
                  options:animationTransitionType
               completion:^(BOOL finished){
                            [view1 removeFromSuperview];
                          }];
[self.view addSubview:view2];
</code></pre>

<h2>UIView Fade In Fade Out</h2>

<pre><code>[view setAlpha:0.f];
[UIView animateWithDuration:2.f delay:0.f options:UIViewAnimationOptionCurveEaseIn animations:^{
    //  fade in
    [view setAlpha:1.f];
} completion:^(BOOL finished) {
    [UIView animateWithDuration:2.f delay:0.f options:UIViewAnimationOptionCurveEaseInOut animations:^{
        //  fade out
        [view setAlpha:0.f];
    } completion:nil];
}];
</code></pre>

<h2>Reachability</h2>

<p>ReachableViaWiFi</p>

<pre><code>self.reachability = [Reachability reachabilityForInternetConnection];
[self.reachability startNotifier];
[self.reachability stopNotifier];
</code></pre>

<p>Wi-Fi Name</p>

<pre><code>+ (NSString *)currentWifiName {
  NSArray *ifs = (__bridge_transfer NSArray *)CNCopySupportedInterfaces();
  NSString *ifnam = [ifs firstObject];
  if (!ifnam) {
    return nil;
  }
  NSDictionary *info = (__bridge_transfer NSDictionary *)CNCopyCurrentNetworkInfo((__bridge CFStringRef)ifnam);
  return info[@"SSID"];
}
</code></pre>

<h2>NetworkExtension</h2>

<p>Configure VPN tunnels. Customize and extend core networking features.</p>

<h3>Personal VPN</h3>

<p><code>NEVPNManager</code>: is used to create and manage VPN configurations and to control the resulting VPN tunnel connections.<br/>
Non-Personal VPN configurations take precedence over Personal VPN configurations.<br/>
Enable the &ldquo;Personal VPN&rdquo; capability for your app in Xcode.</p>

<h2>UIViewController</h2>

<h2>UINavigationController</h2>

<h2>UITabBarController</h2>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS知识小集-170703]]></title>
    <link href="http://sxgfxm.github.io/blog/2017/07/10/ioszhi-shi-xiao-ji-170703/"/>
    <updated>2017-07-10T11:09:16+08:00</updated>
    <id>http://sxgfxm.github.io/blog/2017/07/10/ioszhi-shi-xiao-ji-170703</id>
    <content type="html"><![CDATA[<h2>CAKeyFrameAnimation</h2>

<pre><code>- (CAKeyframeAnimation *)circleShake {
  if (!_circleShake) {
    CGFloat baseX = self.circleMask.position.x;
    _circleShake = [CAKeyframeAnimation animationWithKeyPath:@"position.x"];
    _circleShake.keyTimes = @[
      @0,
      @(0.1 / 0.8),
      @(0.2 / 0.8),
      @(0.3 / 0.8),
      @(0.5 / 0.8),
      @(0.76 / 0.8)
    ];
    _circleShake.values = @[
      @(baseX),
      @(baseX - 11),
      @(baseX + 11),
      @(baseX - 11),
      @(baseX + 11),
      @(baseX)
    ];
    _circleShake.duration = 0.8;
    _circleShake.removedOnCompletion = YES;
    _circleShake.fillMode = kCAFillModeForwards;
  }
  return _circleShake;
}
</code></pre>

<!-- more -->


<h2>Identify CAAnimation within the aniamtionDidStop delegate</h2>

<p>The animation is <strong>copied</strong> before being added to the layer, so any subsequent modifications to <code>anim</code> will have no affect unless it is added to another layer.<br/>
Use <code>animationForKey:</code> to identify.<br/>
Create one animation and add to multiple layers.</p>

<h2>Apply changes when animation finished</h2>

<pre><code>animation.removedOnCompletion = NO;
animation.fillMode = kCAFillModeForwards;
</code></pre>

<h2>Resume changes when animation finished</h2>

<pre><code>animation.removedOnCompletion = NO;
animation.fillMode = kCAFillModeBackwards;
</code></pre>

<h2>Use CAAnimationGroup to run animations cocurrently</h2>

<pre><code>- (CAAnimationGroup *)circleBig {
  if (!_circleBig) {
    _circleBig = [CAAnimationGroup animation];
    CABasicAnimation *circleBig =
        [CABasicAnimation animationWithKeyPath:@"path"];
    circleBig.fromValue = (__bridge id)self.circleMask.path;
    circleBig.toValue =
        (__bridge id)[UIBezierPath bezierPathWithArcCenter:self.centerPoint
                                                    radius:12.5
                                                startAngle:0
                                                  endAngle:M_PI * 2
                                                 clockwise:YES]
            .CGPath;
    circleBig.duration = self.spreadDuration;
    circleBig.removedOnCompletion = NO;
    circleBig.fillMode = kCAFillModeForwards;
    circleBig.timingFunction = [CAMediaTimingFunction
        functionWithName:kCAMediaTimingFunctionEaseInEaseOut];
    CABasicAnimation *changeWidth =
        [CABasicAnimation animationWithKeyPath:@"lineWidth"];
    changeWidth.fromValue = @(self.circleMask.lineWidth);
    changeWidth.toValue = @(5);
    changeWidth.duration = self.spreadDuration;
    changeWidth.removedOnCompletion = NO;
    changeWidth.fillMode = kCAFillModeForwards;
    _circleBig.animations = @[ circleBig, changeWidth ];
  }
  return _circleBig;
}
</code></pre>

<h2>TabBar背景设为透明色</h2>

<pre><code>[[UITabBar appearance] setShadowImage:[WWImageUtil imageWithColor:[UIColor clearColor]]];
[[UITabBar appearance] setBackgroundImage:[WWImageUtil imageWithColor:[UIColor clearColor]]];
[UITabBar appearance].translucent = YES;
</code></pre>

<h2>TabBar去除黑线</h2>

<pre><code>[[UITabBar appearance] setClipsToBounds:YES];
</code></pre>

<h2>self.title</h2>

<p><code>self.title</code>：同时设置导航栏和tabBar的title；<br/>
<code>self.navigationItem.title</code>：设置导航栏title；<br/>
<code>self.tabBarItem.title</code>：设置tabBartitle。</p>

<h2>InHouse 和 Debug配置不同</h2>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS知识小集-170626]]></title>
    <link href="http://sxgfxm.github.io/blog/2017/07/03/ioszhi-shi-xiao-ji-170626/"/>
    <updated>2017-07-03T09:09:47+08:00</updated>
    <id>http://sxgfxm.github.io/blog/2017/07/03/ioszhi-shi-xiao-ji-170626</id>
    <content type="html"><![CDATA[<h2>隐藏tabBar</h2>

<p><code>self.tabBarController.tabBar.hidden=YES;</code></p>

<h2>UIView animate height from bottom to top</h2>

<p>Increase the height while decreasing the origin.y by the same amount.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS知识小集-170619]]></title>
    <link href="http://sxgfxm.github.io/blog/2017/06/26/ioszhi-shi-xiao-ji-170619/"/>
    <updated>2017-06-26T11:57:15+08:00</updated>
    <id>http://sxgfxm.github.io/blog/2017/06/26/ioszhi-shi-xiao-ji-170619</id>
    <content type="html"><![CDATA[<h2>Enable file sharing</h2>

<p>Application Supports iTunes file sharing = YES</p>

<h2>Image Slicing</h2>

<p>使用Xcode Image Slicing图片需为标准的PNG图片。</p>

<h2>TabBar</h2>

<p>高度49</p>

<!-- more -->


<h2>UIPageViewController</h2>

<p>子controller并不会被缩放，而是从上到下布局，可能被截断。</p>

<pre><code>-(void)setupPageController{
  self.pageController =
      [[UIPageViewController alloc] initWithTransitionStyle:UIPageViewControllerTransitionStyleScroll
                                      navigationOrientation:UIPageViewControllerNavigationOrientationVertical
                                                    options:options];
  self.pageController.view.frame = CGRectMake(0, 64, kScreen_Width, kScreen_Height - 64 - 49);
  self.pageController.dataSource = self;
  self.pages = @[ self.mainVC, self.bottomVC ];
  [self.pageController setViewControllers:@[ self.pages.firstObject ]
                                direction:UIPageViewControllerNavigationDirectionForward
                                 animated:YES
                               completion:nil];
  [self addChildViewController:self.pageController];
  [self.view addSubview:self.pageController.view];
}

#pragma mark - UIPageViewControllerDataSource
- (UIViewController *)pageViewController:(UIPageViewController *)pageViewController
      viewControllerBeforeViewController:(UIViewController *)viewController {
  if ([viewController isKindOfClass:[ViewController1 class]]) {
    return nil;
  }
  if ([viewController isKindOfClass:[ViewController2 class]]) {
    return self.pages[0];
  }
  return nil;
}

- (UIViewController *)pageViewController:(UIPageViewController *)pageViewController
       viewControllerAfterViewController:(UIViewController *)viewController {
  if ([viewController isKindOfClass:[ViewController1 class]]) {
    return self.pages[1];
  }
  if ([viewController isKindOfClass:[ViewController2 class]]) {
    return nil;
  }
  return nil;
}
</code></pre>
]]></content>
  </entry>
  
</feed>

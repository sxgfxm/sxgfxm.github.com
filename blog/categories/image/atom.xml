<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Image, | Light's Blog]]></title>
  <link href="http://sxgfxm.github.io/blog/categories/image/atom.xml" rel="self"/>
  <link href="http://sxgfxm.github.io/"/>
  <updated>2017-03-06T16:19:44+08:00</updated>
  <id>http://sxgfxm.github.io/</id>
  <author>
    <name><![CDATA[Light]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[iOS知识小集-170227]]></title>
    <link href="http://sxgfxm.github.io/blog/2017/03/06/ioszhi-shi-xiao-ji-170227/"/>
    <updated>2017-03-06T16:15:46+08:00</updated>
    <id>http://sxgfxm.github.io/blog/2017/03/06/ioszhi-shi-xiao-ji-170227</id>
    <content type="html"><![CDATA[<h2>OC中的锁</h2>

<pre><code>@implementation TestObj

-(void)method1{
  NSLog(@"Method1");
}
-(void)method2{
  NSLog(@"Method2");
}

@end
</code></pre>

<!--more-->


<h3>NSLock</h3>

<pre><code>NSLock *lock = [[NSLock alloc] init];
//线程1
dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
    [lock lock];
    [obj method1];
    sleep(10);
    [lock unlock];
});
//线程2
dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
    sleep(1);//以保证让线程2的代码后执行
    [lock lock];
    [obj method2];
    [lock unlock];
});
</code></pre>

<h3>synchronized关键字。</h3>

<pre><code>//主线程中
TestObj *obj = [[TestObj alloc] init];
//线程1
dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
    @synchronized(obj){
        [obj method1];
        sleep(10);
    }
});
//线程2
dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
    sleep(1);
    @synchronized(obj){
        [obj method2];
    }
});
</code></pre>

<h3>phread_mutex_t。</h3>

<pre><code>//主线程中
TestObj *obj = [[TestObj alloc] init];
__block pthread_mutex_t mutex;
pthread_mutex_init(&amp;mutex, NULL);
//线程1
dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
    pthread_mutex_lock(&amp;mutex);
    [obj method1];
    sleep(5);
    pthread_mutex_unlock(&amp;mutex);
});
//线程2
dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
    sleep(1);
    pthread_mutex_lock(&amp;mutex);
    [obj method2];
    pthread_mutex_unlock(&amp;mutex);
});
</code></pre>

<h3>GCD。</h3>

<pre><code>//主线程中
TestObj *obj = [[TestObj alloc] init];
dispatch_semaphore_t semaphore = dispatch_semaphore_create(1);
//线程1
dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
    dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);
    [obj method1];
    sleep(10);
    dispatch_semaphore_signal(semaphore);
});
//线程2
dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
    sleep(1);
    dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);
    [obj method2];
    dispatch_semaphore_signal(semaphore);
});
</code></pre>

<h2>生成圆形透明背景图片</h2>

<pre><code>+ (UIImage *)circularScaleAndCropImage:(UIImage *)image {
  // Create the bitmap graphics context
  UIGraphicsBeginImageContextWithOptions(CGSizeMake(image.size.width, image.size.height), NO, 0.0);
  CGContextRef context = UIGraphicsGetCurrentContext();

  // Get the width and heights
  CGFloat imageWidth = image.size.width;
  CGFloat imageHeight = image.size.height;

  // Calculate the centre of the circle
  CGFloat imageCentreX = imageWidth / 2;
  CGFloat imageCentreY = imageHeight / 2;

  // Create and CLIP to a CIRCULAR Path
  CGFloat radius = imageWidth / 2;
  CGContextBeginPath(context);
  CGContextAddArc(context, imageCentreX, imageCentreY, radius, 0, 2 * M_PI, 0);
  CGContextClosePath(context);
  CGContextClip(context);

  // Draw the IMAGE
  CGRect myRect = CGRectMake(0, 0, imageWidth, imageHeight);
  [image drawInRect:myRect];

  UIImage *newImage = UIGraphicsGetImageFromCurrentImageContext();
  UIGraphicsEndImageContext();

  return newImage;
}
</code></pre>

<h2>RxJava</h2>

<p>响应式函数编程<br/>
订阅的思想<br/>
多层异步回调逻辑更清晰</p>

<h2>Socket</h2>

<p><strong>Packet-based communication</strong><br/>
<strong>Stream-based clients </strong></p>
]]></content>
  </entry>
  
</feed>

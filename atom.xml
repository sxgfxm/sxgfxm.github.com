<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Light's Blog]]></title>
  <link href="http://sxgfxm.github.io/atom.xml" rel="self"/>
  <link href="http://sxgfxm.github.io/"/>
  <updated>2017-05-17T16:54:59+08:00</updated>
  <id>http://sxgfxm.github.io/</id>
  <author>
    <name><![CDATA[Light]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[iOS知识小集-170508]]></title>
    <link href="http://sxgfxm.github.io/blog/2017/05/17/ioszhi-shi-xiao-ji-170508/"/>
    <updated>2017-05-17T16:52:43+08:00</updated>
    <id>http://sxgfxm.github.io/blog/2017/05/17/ioszhi-shi-xiao-ji-170508</id>
    <content type="html"><![CDATA[<h2>Carthage</h2>

<p>安装：<code>brew install carthage</code><br/>
添加：<code>Cartfile</code><br/>
运行：<code>carthage update</code><br/>
添加：<code>Carthage/Build/.framework</code></p>

<!-- more -->


<h2>防止重复push/present类型相同的controller</h2>

<ol>
<li>找到最上层view controller；</li>
<li>判断最上层view controller与待展示view controller是否类型相同；</li>
<li>如果类型不同，才进行操作。
获取最底层view controller：<code>[UIApplication sharedApplication].delegate.window.rootViewController</code>。<br/>
获取最上层view controller：</li>
</ol>


<pre><code>+ (UIViewController *)topViewController {
  return [self
      topViewControllerWithRootViewController:[UIApplication sharedApplication].delegate.window.rootViewController];
}

+ (UIViewController *)topViewControllerWithRootViewController:(UIViewController *)rootViewController {
  NSLog(@"root to top vc:%@", NSStringFromClass([rootViewController class]));
  if ([rootViewController isKindOfClass:[MMDrawerController class]]) {
    MMDrawerController *mmdVc = (MMDrawerController *)rootViewController;
    return [self topViewControllerWithRootViewController:mmdVc.centerViewController];
  } else if ([rootViewController isKindOfClass:[UITabBarController class]]) {
    UITabBarController *tabBarController = (UITabBarController *)rootViewController;
    return [self topViewControllerWithRootViewController:tabBarController.selectedViewController];
  } else if ([rootViewController isKindOfClass:[UINavigationController class]]) {
    UINavigationController *navigationController = (UINavigationController *)rootViewController;
    return [self topViewControllerWithRootViewController:navigationController.visibleViewController];
  } else if (rootViewController.presentedViewController) {
    UIViewController *presentedViewController = rootViewController.presentedViewController;
    return [self topViewControllerWithRootViewController:presentedViewController];
  } else {
    return rootViewController;
  }
}
</code></pre>

<h2>Create Groups vs Create Folder References</h2>

<p>Group：不创建文件夹，不能同名； <br/>
Folder：创建文件夹，可以重名；</p>

<h2>拉伸Image</h2>

<p>代码：<code>- (UIImage *)resizableImageWithCapInsets:(UIEdgeInsets)capInsets resizingMode:(UIImageResizingMode)resizingMode NS_AVAILABLE_IOS(6_0);</code><br/>
设置：Assets -> Attributes Inspector -> Slicing</p>

<h2>隐藏文件</h2>

<p>显示隐藏文件：<code>defaults write com.apple.finder AppleShowAllFiles -bool true</code><br/>
隐藏隐藏文件：<code>defaults write com.apple.finder AppleShowAllFiles -bool false</code>
重启finder：<code>killall Finder</code></p>

<h2>NavigationBar &amp; ScrollView</h2>

<p>自动：<code>contentOffset.y == -64</code><br/>
手动：<code>self.edgesForExtendedLayout = UIRectEdgeNone;</code>，y轴0点下移64。</p>

<h2>Objective-C static vs external</h2>

<p>static: In C and Objective-C, a static variable or function at global scope means that that symbol has internal linkage.<br/>
external: If you want to have a single global variable, you can&rsquo;t have it in class scope like in C++. One option is to create a global variable with external linkage: declare the variable with the extern keyword in a header file, and then in one source file, define it at global scope without the extern keyword.</p>

<p class='post-footer'>
  原始地址：
  <a href='http://sxgfxm.github.io/blog/2017/05/17/ioszhi-shi-xiao-ji-170508/'>http://sxgfxm.github.io/blog/2017/05/17/ioszhi-shi-xiao-ji-170508/</a><br/>
  written by <a href='http://sxgfxm.github.io'>Light</a>
  &nbsp;posted at <a href='http://sxgfxm.github.io'>http://sxgfxm.github.io</a>
  </p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS知识小集-170501]]></title>
    <link href="http://sxgfxm.github.io/blog/2017/05/17/ioszhi-shi-xiao-ji-170501/"/>
    <updated>2017-05-17T16:42:40+08:00</updated>
    <id>http://sxgfxm.github.io/blog/2017/05/17/ioszhi-shi-xiao-ji-170501</id>
    <content type="html"><![CDATA[<h1>ComponentKit Tutorial - CollectionView</h1>

<h2>Install</h2>

<p>通过 <strong>Carthage</strong> 安装，在 <strong>Cartfile</strong> 中添加<code>github "facebook/ComponentKit" ~&gt; 0.20</code>，然后运行<code>carthage update</code>，编译完成后，在 <strong>Embedded Binaries</strong> 添加<code>Carthage/Build/iOS/ComponentKit.framework</code>。所有需要使用ComponentKit的源文件需要修改后缀为 <strong>.mm</strong>。</p>

<h2>Philosophy</h2>

<p>Doing so this reverses the traditional approach for a <code>UICollectionViewDataSource</code>. Usually the controller layer will <strong>tell</strong> the <code>UICollectionView</code> to update and then the <code>UICollectionView</code> <strong>ask</strong> the datasource for the data. Here the model is  more Reactive, from an external prospective, the datasource is <strong>told</strong> what changes to apply and then <strong>tell</strong> the collection view to apply the corresponding changes.</p>

<!-- more -->


<h2>步骤</h2>

<h3>CKComponentProvider Protocol</h3>

<p>ViewController需要遵守<code>CKComponentProvider</code>协议，实现<code>+componentForModel: context:</code>方法，将model转换为component。<br/>
在该方法中，通过不同类型的model返回不同类型的component。</p>

<pre><code>+ (CKComponent *)componentForModel:(id&lt;NSObject&gt;)model
                           context:(id&lt;NSObject&gt;)context {
  if ([model isKindOfClass:[NewsModel class]]) {
    return [NewsComponent newWithNewsModel:model context:context];
  }
  return nil;
}
</code></pre>

<h3>FlowLayout</h3>

<pre><code>UICollectionViewFlowLayout *flowLayout = [[UICollectionViewFlowLayout alloc] init];
[flowLayout setScrollDirection:UICollectionViewScrollDirectionVertical];
[flowLayout setMinimumInteritemSpacing:0];
[flowLayout setMinimumLineSpacing:0];
</code></pre>

<h3>CollectionView</h3>

<pre><code>self.collectionView = [[UICollectionView alloc] initWithFrame:self.view.bounds collectionViewLayout:flowLayout];
self.collectionView.delegate = self;
self.collectionView.backgroundColor = [UIColor blackColor];
[self.view addSubview:self.collectionView];
</code></pre>

<h3>Item size range</h3>

<p>Item size range。通过设置<code>CKComponentSizeRangeFlexibleHeight</code>使item的高度自适应。</p>

<pre><code>const CKSizeRange sizeRange = [[CKComponentFlexibleSizeRangeProvider
      providerWithFlexibility:CKComponentSizeRangeFlexibleHeight]
     sizeRangeForBoundingSize:self.collectionView.bounds.size];
</code></pre>

<h3>Context</h3>

<p>Context可以是任何不可变对象，创建component时的不可变上下文信息，比如设备类型，图片下载器。<br/>
<code>MyContext *context = [MyContext new];</code><br/>
预先在主线程加载图片。</p>

<h3>Configuration</h3>

<p>DataSource的configuration，需要 <strong>ComponentProvider</strong>，<strong>sizeRange</strong>，<strong>context</strong> 三个参数。</p>

<pre><code>CKTransactionalComponentDataSourceConfiguration *configuration =
      [[CKTransactionalComponentDataSourceConfiguration alloc]
          initWithComponentProvider:[self class]
                            context:context
                          sizeRange:sizeRange];
</code></pre>

<h3>DataSource</h3>

<p>需要 <strong>collectionView</strong>，<strong>supplementaryViewDataSource</strong>，<strong>configuration</strong> 三个参数。</p>

<pre><code>self.dataSource = [[CKCollectionViewTransactionalDataSource alloc]
           initWithCollectionView:self.collectionView
      supplementaryViewDataSource:nil
                    configuration:configuration];
</code></pre>

<h3>Initial Changeset</h3>

<p>需要初始化DataSource，即向DataSource中添加Section。</p>

<pre><code>CKTransactionalComponentDataSourceChangeset *initialChangeset =
  [[[CKTransactionalComponentDataSourceChangesetBuilder
      transactionalComponentDataSourceChangeset]
      withInsertedSections:[NSIndexSet indexSetWithIndex:0]] build];
[self.dataSource applyChangeset:initialChangeset
                           mode:CKUpdateModeAsynchronous
                       userInfo:nil];
</code></pre>

<h3>insert/update items</h3>

<p>向DataSource中插入Items才能显示。</p>

<pre><code>NSMutableDictionary&lt;NSIndexPath *, NewsModel *&gt; *items = [NSMutableDictionary new];
for (NSInteger i = 0; i &lt; 50; i++) {
  NewsModel *newsModel = [[NewsModel alloc] init];
  newsModel.title = [NSString stringWithFormat:@"News Title: Title %ld", i];
  newsModel.category = @"科技";
  newsModel.updateTime = [NSDate date];
  newsModel.source = @"网易新闻";
  [items setObject:newsModel
            forKey:[NSIndexPath indexPathForRow:i inSection:0]];
}
CKTransactionalComponentDataSourceChangeset *changeset =
  [[[CKTransactionalComponentDataSourceChangesetBuilder
      transactionalComponentDataSourceChangeset]
      withInsertedItems:items] build];
[self.dataSource applyChangeset:changeset
                           mode:CKUpdateModeAsynchronous
                       userInfo:nil];
</code></pre>

<h3>UICollectionView delegate</h3>

<pre><code>- (CGSize)collectionView:(UICollectionView *)collectionView
                  layout:(UICollectionViewLayout *)collectionViewLayout
  sizeForItemAtIndexPath:(NSIndexPath *)indexPath {
  return [self.dataSource sizeForItemAtIndexPath:indexPath];
}

- (void)collectionView:(UICollectionView *)collectionView
       willDisplayCell:(UICollectionViewCell *)cell
    forItemAtIndexPath:(NSIndexPath *)indexPath {
  [self.dataSource announceWillDisplayCell:cell];
}

- (void)collectionView:(UICollectionView *)collectionView
  didEndDisplayingCell:(UICollectionViewCell *)cell
    forItemAtIndexPath:(NSIndexPath *)indexPath {
  [self.dataSource announceDidEndDisplayingCell:cell];
}
</code></pre>

<p class='post-footer'>
  原始地址：
  <a href='http://sxgfxm.github.io/blog/2017/05/17/ioszhi-shi-xiao-ji-170501/'>http://sxgfxm.github.io/blog/2017/05/17/ioszhi-shi-xiao-ji-170501/</a><br/>
  written by <a href='http://sxgfxm.github.io'>Light</a>
  &nbsp;posted at <a href='http://sxgfxm.github.io'>http://sxgfxm.github.io</a>
  </p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS知识小集-170424]]></title>
    <link href="http://sxgfxm.github.io/blog/2017/05/17/ioszhi-shi-xiao-ji-170424/"/>
    <updated>2017-05-17T16:38:39+08:00</updated>
    <id>http://sxgfxm.github.io/blog/2017/05/17/ioszhi-shi-xiao-ji-170424</id>
    <content type="html"><![CDATA[<h1>ComponentKit Tutorial - Layout</h1>

<h2>Flexbox Layout</h2>

<p><strong>flex container</strong>：容器。<br/>
main axis：main start， main end。<br/>
cross axis：cross start， cross end。<br/>
<strong>flex item</strong>：成员。<br/>
main size。<br/>
cross size。</p>

<!-- more -->


<h2>Container Properties</h2>

<p>flex-direction：决定主轴方向。</p>

<pre><code>typedef NS_ENUM(NSUInteger, CKStackLayoutDirection) {
  //  垂直方向
  CKStackLayoutDirectionVertical,
  //  水平方向
  CKStackLayoutDirectionHorizontal,
};
</code></pre>

<p>flex-wrap：决定如何换行。<br/>
flex-flow：flex-direction和flex-wrap的简写形式。<br/>
<strong>justify-content</strong>：决定items在主轴上的对齐方式。</p>

<pre><code>/** If no children are flexible, how should this component justify its children in the available space? */
typedef NS_ENUM(NSUInteger, CKStackLayoutJustifyContent) {
  /**
   On overflow, children overflow out of this component's bounds on the right/bottom side.
   On underflow, children are left/top-aligned within this component's bounds.
   */
  //  左对齐
  CKStackLayoutJustifyContentStart,
  /**
   On overflow, children are centered and overflow on both sides.
   On underflow, children are centered within this component's bounds in the stacking direction.
   */
  //  居中
  CKStackLayoutJustifyContentCenter,
  /**
   On overflow, children overflow out of this component's bounds on the left/top side.
   On underflow, children are right/bottom-aligned within this component's bounds.
   */
  //  右对齐
  CKStackLayoutJustifyContentEnd,
};
</code></pre>

<p><strong>align-items</strong>：决定items在交叉轴上的对齐方式。</p>

<pre><code>typedef NS_ENUM(NSUInteger, CKStackLayoutAlignItems) {
  /** Align children to start of cross axis */
  //  交叉轴起点对齐
  CKStackLayoutAlignItemsStart,
  /** Align children with end of cross axis */
  CKStackLayoutAlignItemsEnd,
  //  交叉轴终点对齐
  /** Center children on cross axis */
  //  交叉轴居中对齐
  CKStackLayoutAlignItemsCenter,
  /** Expand children to fill cross axis */
  //  交叉轴方向拉伸
  CKStackLayoutAlignItemsStretch,
};
</code></pre>

<h2>Item Properties</h2>

<p>order：决定item排列顺序，数值越小，排位越靠前。<br/>
<strong>flex-grow</strong>：决定item主轴方向的放大比例，默认为0，即如果存在剩余空间，也不放大。<br/>
如果所有项目的flex-grow属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的flex-grow属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。<br/>
<strong>flex-shrink</strong>：决定item主轴方向的缩小比例，默认为1，即如果空间不足，该item将缩小。<br/>
如果所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小。如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小。<br/>
<strong>flex-basis</strong>：决定了在分配多余空间之前，item的main size大小，根据该值计算主轴是否有多余空间。<br/>
flex：flex-grow, flex-shrink 和 flex-basis的简写。<br/>
<strong>align-self</strong>：决定item单独的对齐方式，可以覆盖 <strong>align-items</strong> 属性。<br/>
默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。</p>

<pre><code>/**
 Each child may override their parent stack's cross axis alignment.
 @see CKStackLayoutAlignItems
 */
typedef NS_ENUM(NSUInteger, CKStackLayoutAlignSelf) {
  /** Inherit alignment value from containing stack. */
  CKStackLayoutAlignSelfAuto,
  CKStackLayoutAlignSelfStart,
  CKStackLayoutAlignSelfEnd,
  CKStackLayoutAlignSelfCenter,
  CKStackLayoutAlignSelfStretch,
};
</code></pre>

<h2>CKStackLayoutComponent</h2>

<p>A simple layout component that stacks a list of children vertically or horizontally.<br/>
动态创建children：</p>

<pre><code>static std::vector&lt;CKStackLayoutComponentChild&gt; createChildren(NSArray* list){
  std::vector&lt;CKStackLayoutComponentChild&gt; children;
  for (VPANewsModel*newsModel in list) {
    children.push_back({[VPANewsComponent newWithNewsModel:newsModel]});
  }
  return children;
}
</code></pre>

<h2>CKBackgroundLayoutComponent</h2>

<p>Lays out a single child component, then lays out a background component behind it stretched to its size.</p>

<pre><code>+ (instancetype)newWithComponent:(CKComponent *)component
                      background:(CKComponent *)background;
</code></pre>

<h2>CKStaticLayoutComponent</h2>

<p>A component that positions children at fixed positions.<br/>
Computes a size that is the union of all childrens' frames.</p>

<h2>CKCenterLayoutComponent</h2>

<p>Lays out a single child component and position it so that it is centered into the layout bounds.</p>

<pre><code>+ (instancetype)newWithCenteringOptions:(CKCenterLayoutComponentCenteringOptions)centeringOptions
                          sizingOptions:(CKCenterLayoutComponentSizingOptions)sizingOptions
                                  child:(CKComponent *)child
                                   size:(const CKComponentSize &amp;)size;
</code></pre>

<h2>CKRatioLayoutComponent</h2>

<p>For when the content should respect a certain inherent ratio but can be scaled (think photos or videos).
The ratio passed is the ratio of height / width you expect.</p>

<p class='post-footer'>
  原始地址：
  <a href='http://sxgfxm.github.io/blog/2017/05/17/ioszhi-shi-xiao-ji-170424/'>http://sxgfxm.github.io/blog/2017/05/17/ioszhi-shi-xiao-ji-170424/</a><br/>
  written by <a href='http://sxgfxm.github.io'>Light</a>
  &nbsp;posted at <a href='http://sxgfxm.github.io'>http://sxgfxm.github.io</a>
  </p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS知识小集-170417]]></title>
    <link href="http://sxgfxm.github.io/blog/2017/05/17/ioszhi-shi-xiao-ji-170417/"/>
    <updated>2017-05-17T16:33:08+08:00</updated>
    <id>http://sxgfxm.github.io/blog/2017/05/17/ioszhi-shi-xiao-ji-170417</id>
    <content type="html"><![CDATA[<h1>ComponentKit Tutorial - Component</h1>

<h2>CKComponent</h2>

<p>A component is an immutable object that specifies how to configure a view, loosely inspired by React.</p>

<pre><code>+ (instancetype)newWithView:(const CKComponentViewConfiguration &amp;)view
                       size:(const CKComponentSize &amp;)size;
</code></pre>

<p>Example:</p>

<pre><code>CKComponent *component = [CKComponent
    newWithView:{
        [UIView class],
        {
            {@selector(setBackgroundColor:),[UIColor redColor]},
            {@selector(setUserInteractionEnabled:), @YES},
            {CKComponentTapGestureAttribute(@selector(didTap))},
            {CKComponentViewAttribute::LayerAttribute(@selector(setCornerRadius:)), @10.0}
        }
    }
    size:{50,50}];

- (void)didTap{
  [self updateState:^(NSNumber *oldState){
    return [oldState boolValue] ? @NO : @YES;
  } mode:CKUpdateModeSynchronous];
}
</code></pre>

<!-- more -->


<h2>CKLabelComponent</h2>

<p>多行文字通过size.width控制。</p>

<pre><code>CKLabelComponent *titleComponent = [CKLabelComponent newWithLabelAttributes:{
    .string = newsModel.title,
    .color = [UIColor whiteColor],
    .alignment = NSTextAlignmentLeft,
    .font = [UIFont systemFontOfSize:20]
  }
  viewAttributes:{
    { @selector(setBackgroundColor:), [UIColor clearColor] }
  }
  size:{}];
</code></pre>

<h2>CKButtonComponent</h2>

<pre><code> CKButtonComponent *buttonComponent = [CKButtonComponent
    newWithTitles:{
      {UIControlStateNormal,@"button"}
    }
    titleColors:{
      {UIControlStateNormal,[UIColor whiteColor]}
    }
    images:{}
    backgroundImages:{}
    titleFont:[UIFont systemFontOfSize:17]
    selected:NO
    enabled:YES
    action:{@selector(tapAction)}
    size:{}
    attributes:{}
    accessibilityConfiguration:{}];
</code></pre>

<h2>CKImageComponent</h2>

<pre><code>CKImageComponent *image = [CKImageComponent newWithImage:
    [UIImage imageNamed:newsModel.imageURL]
    attributes:{
        { @selector(setBackgroundColor:), [UIColor whiteColor] },
        {CKComponentViewAttribute::LayerAttribute(@selector(setCornerRadius:)), @10.0}
    }
    size:{60, 60}];
</code></pre>

<h2>CKInsetComponent</h2>

<p>A component that wraps another component, applying insets around it.</p>

<pre><code>+ (instancetype)newWithView:(const CKComponentViewConfiguration &amp;)view
                     insets:(UIEdgeInsets)insets
                  component:(CKComponent *)component;

+ (instancetype)newWithInsets:(UIEdgeInsets)insets component:(CKComponent *)child;
</code></pre>

<p>Example:</p>

<pre><code>CKInsetComponent *insetComponent = [CKInsetComponent
    newWithInsets:{.top = 10,.left = 20,.right = 10,.bottom = 20}
    component:[CKComponent
        newWithView:{}
        size:{}]
    ];
</code></pre>

<h2>CKOverlayLayoutComponent</h2>

<p>This component lays out a single component and then overlays a component on top of it streched to its size.</p>

<pre><code>+ (instancetype)newWithComponent:(CKComponent *)component
                         overlay:(CKComponent *)overlay;
</code></pre>

<h2>State</h2>

<p>Simply ask three questions about each piece of data:<br/>
1. Is it passed in from a parent via props? If so, it probably isn&rsquo;t state.<br/>
2. Does it remain unchanged over time? If so, it probably isn&rsquo;t state.<br/>
3. Can you compute it based on any other state or props in your component? If so, it isn&rsquo;t state.</p>

<p>For each piece of state in your application:<br/>
1. Identify every component that renders something based on that state.<br/>
2. Find a common owner component (a single component above all the components that need the state in the hierarchy).<br/>
3. Either the common owner or another component higher up in the hierarchy should own the state.<br/>
4. If you can&rsquo;t find a component where it makes sense to own the state, create a new component simply for holding the state and add it somewhere in the hierarchy above the common owner component.</p>

<h2>Scope</h2>

<ol>
<li>Components that have state must have a scope.</li>
<li>Components that have a controller must have a scope.</li>
<li>Components that have child components with state or controllers may need a scope, even if they don’t have state or controllers.</li>
</ol>


<h2>ComponentController</h2>

<p>与component写在同一个文件里，系统自动创建。<br/>
用来处理代理、事件响应等，有持续的生命周期。<br/>
scope必须唯一，与controller一一对应。</p>

<p class='post-footer'>
  原始地址：
  <a href='http://sxgfxm.github.io/blog/2017/05/17/ioszhi-shi-xiao-ji-170417/'>http://sxgfxm.github.io/blog/2017/05/17/ioszhi-shi-xiao-ji-170417/</a><br/>
  written by <a href='http://sxgfxm.github.io'>Light</a>
  &nbsp;posted at <a href='http://sxgfxm.github.io'>http://sxgfxm.github.io</a>
  </p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS知识小集-170410]]></title>
    <link href="http://sxgfxm.github.io/blog/2017/05/17/ioszhi-shi-xiao-ji-170410/"/>
    <updated>2017-05-17T16:25:45+08:00</updated>
    <id>http://sxgfxm.github.io/blog/2017/05/17/ioszhi-shi-xiao-ji-170410</id>
    <content type="html"><![CDATA[<h1>ComponentKit Tutorial - Introduction</h1>

<h2>Philosophy</h2>

<p>Components are immutable objects that specify how to configure views.<br/>
<strong>Declarative</strong> : You declare the subcomponents of your component.<br/>
<strong>Functional</strong> : Data flows in one direction.<br/>
<strong>Composable</strong> : Reusing it is a one-liner.</p>

<!-- more -->


<h2>Flex box</h2>

<p><strong>main axis</strong>: The main axis of a flex container is the primary axis along which flex items are laid out. It extends in the main dimension.<br/>
<strong>main-start,main-end</strong>: The flex items are placed within the container starting on the main-start side and going toward the main-end side.<br/>
<strong>main size</strong>: The flex item’s main size property is either the width or height property, whichever is in the main dimension.<br/>
<strong>cross axis</strong>: The axis perpendicular to the main axis is called the cross axis. It extends in the cross dimension.<br/>
<strong>cross-start,cross-end</strong>: Flex lines are filled with items and placed into the container starting on the cross-start side of the flex container and going toward the cross-end side.<br/>
<strong>cross size</strong>: The cross size property is whichever of width or height that is in the cross dimension.</p>

<h2>Uses</h2>

<p><strong>Strengths</strong>:<br/>
Simple and Declarative: Just like React itself. Why React? sums up these benefits.<br/>
Scroll Performance: All layout is performed on a background thread, ensuring the main thread isn’t tied up measuring text.<br/>
View Recycling: By requiring all view configurations to be expressed declaratively, ComponentKit makes error-free view recycling automatic.<br/>
Composability: By encouraging heavy use of composition, it’s possible to build UIs as complex as News Feed without any single component exceeding 300 lines of code.<br/>
<strong>Considerations</strong>:<br/>
Interfaces that aren’t lists or tables aren’t ideally suited to ComponentKit since it is optimized to work well with a UICollectionView.<br/>
ComponentKit is fully native and compiled. React Native offers an alternative based on JavaScriptCore and React, including features like instant reload with no recompilation.<br/>
Dynamic gesture-driven UIs are currently hard to implement in ComponentKit; consider using AsyncDisplayKit.<br/>
ComponentKit is built on Objective-C++. There is no easy way to interoperate with Swift since Swift cannot bridge to C++.</p>

<h2>Component API</h2>

<pre><code>@interface CKComponent : NSObject

/** Returns a new component. */
+ (instancetype)newWithView:(const CKComponentViewConfiguration &amp;)view
                       size:(const CKComponentSize &amp;)size;

@end
</code></pre>

<p>Notes:<br/>
A component is totally immutable. For example, there is no <code>addSubcomponent:</code> method.<br/>
A component can be created on any thread. This helps keep all sizing and construction operations off the main thread.<br/>
The Objective-C idiom <code>+newWith...</code> is used for instantiation instead of the more typical <code>+alloc/-initWith...</code> This is mainly for brevity. Getting rid of noise is important to keep components code readable.</p>

<h2>Composite Components</h2>

<p>Avoid subclassing <code>CKComponent directly</code>. Instead, subclass <code>CKCompositeComponent</code>.<br/>
A “composite component” simply wraps another component, hiding its implementation details from the outside world.</p>

<pre><code>@implementation ShareButtonComponent

+ (instancetype)newWithArticle:(ArticleModel *)article
{
  return [super newWithComponent:
          [CKButtonComponent
           newWithTitles:...
           titleColors:...]];
}

- (void)shareTapped
{
  // Share the article
}

@end
</code></pre>

<h2>Views</h2>

<pre><code>struct CKComponentViewConfiguration {
  CKComponentViewClass viewClass;
  std::unordered_map&lt;CKComponentViewAttribute, id&gt; attributes;
};
</code></pre>

<p>The first field is a view class. Ignore <code>CKComponentViewClass</code> for now — in most cases you just pass a class like <code>[UIImageView class]</code> or <code>[UIButton class]</code>.<br/>
The second field holds a map of attributes to values: font, color, background image, and so forth. Again, ignore <code>CKComponentViewAttribute</code> for now; you can usually use a <code>SEL</code> as the attribute.</p>

<pre><code>[CKComponent
 newWithView:{
   [UIImageView class],
   {
     {@selector(setImage:), image},
     {@selector(setContentMode:), @(UIViewContentModeCenter)} // Wrapping into an NSNumber
   }
 }
 size:{image.size.width, image.size.height}];
</code></pre>

<p>In such situations, just pass {} for the view configuration and no view is created.</p>

<h2>Layout</h2>

<p><code>CKComponent</code> instances do not have any size or position information. Instead, ComponentKit calls the <code>layoutThatFits:</code> method with a given size constraint and the component must return a structure describing both its size, and the position and sizes of its children.</p>

<pre><code>struct CKComponentLayout {
  CKComponent *component;
  CGSize size;
  std::vector&lt;CKComponentLayoutChild&gt; children;
};

struct CKComponentLayoutChild {
  CGPoint position;
  CKComponentLayout layout;
};
</code></pre>

<p><strong>Layout Components</strong>:<br/>
<code>CKStackLayoutComponent</code>: It allows you to stack components vertically or horizontally and specify how they should be flexed and aligned to fit in the available space.<br/>
<code>CKInsetComponent</code>: Applies an inset margin around a component.<br/>
<code>CKBackgroundLayoutComponent</code>: Lays out a component, stretching another component behind it as a backdrop.<br/>
<code>CKOverlayLayoutComponent</code>: Lays out a component, stretching another component on top of it as an overlay.<br/>
<code>CKCenterLayoutComponent</code>: Centers a component in the available space.<br/>
<code>CKRatioLayoutComponent</code>: Lays out a component at a fixed aspect ratio.<br/>
<code>CKStaticLayoutComponent</code>: Allows positioning children at fixed offsets.<br/>
If the components above aren’t powerful enough, you can implement <code>computeLayoutThatFits:</code> manually.</p>

<h2>Responder Chain</h2>

<p>The ComponentKit responder chain is separate from UIView’s responder chain, so you must manually bridge over to the component responder chain if desired.<br/>
The easiest way to handle taps on UIControl views is to use <code>CKComponentActionAttribute</code>.</p>

<pre><code>@implementation SomeComponent

+ (instancetype)new
{
  return [self newWithView:{
    [UIButton class],
    {CKComponentActionAttribute(@selector(didTapButton))}
  }];
}

- (void)didTapButton
{
  // Aha! The button has been tapped.
}

@end
</code></pre>

<h2>Component Actions</h2>

<h2>State</h2>

<p><code>State</code>: Internal to the component, this holds implementation details that the parent should not have to know about.</p>

<pre><code>#import "CKComponentSubclass.h" // import to expose updateState:
@implementation MessageComponent

+ (id)initialState
{
  return @NO;
}

+ (instancetype)newWithMessage:(NSAttributedString *)message
{
  CKComponentScope scope(self);
  NSNumber *state = scope.state();
  return [super newWithComponent:
          [CKTextComponent
           newWithAttributes:{
             .attributedString = message,
             .maximumNumberOfLines = [state boolValue] ? 0 : 5,
           }
           viewAttributes:{}
           accessibilityContext:{}]];
}

- (void)didTapContinueReading
{
  [self updateState:^(id oldState){ return @YES; } mode:CKUpdateModeAsynchronous];
}

@end
</code></pre>

<h2>Scopes</h2>

<p><code>Scopes</code> give components a persistent, unique identity. They’re needed in three cases:<br/>
Components that have <code>state</code> must have a scope.<br/>
Components that have a <code>controller</code> must have a scope.<br/>
Components that have child components with state or controllers may need a scope, even if they don’t have state or controllers.<br/>
Use the <code>CKComponentScope</code> type to define a component scope at the top of a component’s <code>+new</code> method.</p>

<pre><code>+ (instancetype)newWithModel:(Model *)model
{
  CKComponentScope scope(self, model.uniqueID);
  ...
  return [super newWithComponent:...];
}
</code></pre>

<p>If your component doesn’t have a model object with a unique identifier, you can omit that parameter as long as there won’t be multiple siblings of the same type.</p>

<pre><code>CKComponentScope scope(self);
</code></pre>

<h2>Component Controllers</h2>

<p>Every time something changes, an entirely new component is created and the old one is thrown away.<br/>
This means components are short-lived, and their lifecycle is not under your control.<br/>
But sometimes, you do need <strong>an object with a longer lifecycle</strong>. Component controllers fill that role:<br/>
Components can’t be delegates because they are short-lived, but component controllers can be delegates.<br/>
Network downloads take time to complete; the component may have been recreated by the time the download completes. The controller can handle the callback.<br/>
You may need an object to own some other object that should have a long lifetime.<br/>
Controllers are instantiated automatically by ComponentKit. Don’t try to create them manually.<br/>
There is a only a one-way communication channel between the component and its component controller - you can only pass data off of a component to a component controller.<br/>
A component has no reference its corresponding component controller. This is by design.<br/>
To pass data from a component to its controller, expose a <code>@property</code> on the component in a class extension.<br/>
The controller can initialize itself with the properties in <code>initWithComponent:</code>.</p>

<h2>Lifecycle Methods</h2>

<p>Whenever possible, avoid using lifecycle methods. Think of them as an emergency escape hatch for integrating with stateful code.<br/>
Mounting -> Remounting -> Unmounting -> Updating</p>

<h2>Animation</h2>

<p>animationsOnInitialMount: Override this method to specify how to animate the initial appearance of a component.<br/>
animationsFromPreviousComponent: Override this method to specify how to animate between two versions of a component.<br/>
boundsAnimationFromPreviousComponent: Override this method to specify how the top-level bounds of a component should animate inside a <code>UICollectionView</code>.<br/>
If you implement either method, your component must have a <code>scope</code>.</p>

<p class='post-footer'>
  原始地址：
  <a href='http://sxgfxm.github.io/blog/2017/05/17/ioszhi-shi-xiao-ji-170410/'>http://sxgfxm.github.io/blog/2017/05/17/ioszhi-shi-xiao-ji-170410/</a><br/>
  written by <a href='http://sxgfxm.github.io'>Light</a>
  &nbsp;posted at <a href='http://sxgfxm.github.io'>http://sxgfxm.github.io</a>
  </p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS知识小集-170403]]></title>
    <link href="http://sxgfxm.github.io/blog/2017/05/17/ioszhi-shi-xiao-ji-170403/"/>
    <updated>2017-05-17T16:16:33+08:00</updated>
    <id>http://sxgfxm.github.io/blog/2017/05/17/ioszhi-shi-xiao-ji-170403</id>
    <content type="html"><![CDATA[<h2>Heap and Stack</h2>

<p>Value types are created on the stack, Reference types are created on the heap.<br/>
Stack is attached to a thread, and Heap is attached to the application.<br/>
Stack is faster than Heap.</p>

<!-- more -->


<h2>dealloc 是否需要调用[super dealloc]</h2>

<p>ARC中不能调用<code>[super dealloc]</code>。</p>

<p>MRC中，必须最后调用<code>[super dealloc]</code>。</p>

<h2>set a breakpoint in malloc_error_break to debug</h2>

<p>The error message indicates a pointer to a block of freed memory doesn&rsquo;t actually point to free memory.
The most likely cause is that the memory is a freed object instance, but your code as an unretained reference to it and has tried to use it like a &ldquo;live&rdquo; instance.<br/>
Click on the breakpoints navigator (looks like a sign post) on the top of the left bar on XCode.<br/>
On the bottom left hand corner there is a plus sign. Click on it.<br/>
Add Symbolic Breakpoint and set malloc_error_break as the symbol.<br/>
Click the next breakpoint button.</p>

<h2>EXC_BAD_ACCESS</h2>

<p>Whenever you encounter EXC_BAD_ACCESS, it means that you are sending a message to an object that has already been released.<br/>
In summary, when you run into EXC_BAD_ACCESS, it means that you try to send a message to a block of memory that can&rsquo;t execute that message.<br/>
Put differently, deallocated objects are kept alive for debugging purposes. If you send a message to a zombie object, your application will still crash as a result of EXC_BAD_ACCESS.<br/>
Click the active scheme in the top left and choose Edit Scheme.<br/>
Select Run on the left and open the Diagnostics tab at the top. To enable zombie objects, tick the checkbox labeled Enable Zombie Objects.</p>

<h2>dyld: Library not loaded</h2>

<p>In the target&rsquo;s General tab, there is an Embedded Binaries field. When you add the framework there the crash is resolved.</p>

<p>Reference is here on Apple Developer Forums.</p>

<h2>PlantUML</h2>

<p><a href="http://plantuml.com/">PlantUML</a>是一个开源项目，支持快速绘制时序图、用例图、类图等常用软件开发示意图。<br/>
优点：通过代码实现图形绘制，逻辑清晰，扩展维护，效率高。<br/>
集成方法：<br/>
1. 下载安装<a href="https://atom.io/">Atom</a>。
2. Atom -> Preferences -> Packages -> plantuml-viewer。
3. 学习语法，编写代码，自动生成对应图形。</p>

<p class='post-footer'>
  原始地址：
  <a href='http://sxgfxm.github.io/blog/2017/05/17/ioszhi-shi-xiao-ji-170403/'>http://sxgfxm.github.io/blog/2017/05/17/ioszhi-shi-xiao-ji-170403/</a><br/>
  written by <a href='http://sxgfxm.github.io'>Light</a>
  &nbsp;posted at <a href='http://sxgfxm.github.io'>http://sxgfxm.github.io</a>
  </p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS知识小集-170327]]></title>
    <link href="http://sxgfxm.github.io/blog/2017/04/05/ioszhi-shi-xiao-ji-170403/"/>
    <updated>2017-04-05T09:07:16+08:00</updated>
    <id>http://sxgfxm.github.io/blog/2017/04/05/ioszhi-shi-xiao-ji-170403</id>
    <content type="html"><![CDATA[<h2>转换</h2>

<p>NSURL -> NSString：<code>NSString *path = [url path];</code><br/>
NSString -> NSURL：<code>NSURL *url = [NSURL fileURLWithPath:path];</code> <br/>
UIImage -> NSData：<code>NSData *data = UIImagePNGRepresentation(image);</code><br/>
NSData -> UIImage：<code>UIImage *image = [UIImage imageWithData:data];</code></p>

<!-- more -->


<h2>向歌曲中写入metadata信息</h2>

<p>导入第三方库<a href="https://github.com/larsbs/id3v2lib">id3v2lib</a>。</p>

<pre><code>  //  文件路径
  const char *cPath = [[url path] cStringUsingEncoding:NSUTF8StringEncoding];
  //  创建tag
  ID3v2_tag *tag = load_tag(cPath);
  if (tag == NULL) {
    tag = new_tag();
  }
  //  设置tag
  char *title = (char *)[item.title cStringUsingEncoding:NSUTF8StringEncoding];
  tag_set_title(title, 0, tag);
  char *artist = (char *)[item.artist cStringUsingEncoding:NSUTF8StringEncoding];
  tag_set_artist(artist, 0, tag);
  UIImage *image = [item.artwork imageWithSize:CGSizeMake(400, 400)];
  NSData *data = UIImagePNGRepresentation(image);
  NSString *coverPath = [[NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES) firstObject]
      stringByAppendingPathComponent:[NSString stringWithFormat:@"%@.png", item.title]];
  [[NSFileManager defaultManager] removeItemAtPath:coverPath error:nil];
  [[NSFileManager defaultManager] createFileAtPath:coverPath contents:data attributes:nil];
  tag_set_album_cover([coverPath cStringUsingEncoding:NSUTF8StringEncoding], tag);
  [[NSFileManager defaultManager] removeItemAtPath:coverPath error:nil];
  //  写入tag
  set_tag(cPath, tag);
</code></pre>

<h2>MPMediaItem</h2>

<p>isCloudItem：是否为云端文件；<br/>
hasProtectedAsset：是否含有被保护文件；<br/>
以上两个原因可能导致assertURL为nil。</p>

<h2>NSOperation内存泄露</h2>

<p>operation.completionBlock会引起循环引用。<br/>
在block中创建对象注意生命周期。</p>

<h2>GCDWebServer监听传输状态</h2>

<p>继承<code>GCDWebServerConnection</code>，重写<code>- (void)didWriteBytes:(const void *)bytes length:(NSUInteger)length</code>方法，以通知的形式传递值。</p>

<h2>c string in OC</h2>

<p><code>char *cString = (char *)[string cStringUsingEncoding:NSUTF8StringEncoding]</code>，
无需手动释放，当receiver被释放或者内存不足时，会自动释放cString。</p>

<h2>WiFi ap隔离</h2>

<h2>观察者模式</h2>

<h2>工厂模式</h2>

<p class='post-footer'>
  原始地址：
  <a href='http://sxgfxm.github.io/blog/2017/04/05/ioszhi-shi-xiao-ji-170403/'>http://sxgfxm.github.io/blog/2017/04/05/ioszhi-shi-xiao-ji-170403/</a><br/>
  written by <a href='http://sxgfxm.github.io'>Light</a>
  &nbsp;posted at <a href='http://sxgfxm.github.io'>http://sxgfxm.github.io</a>
  </p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS知识小集-170320]]></title>
    <link href="http://sxgfxm.github.io/blog/2017/03/27/ioszhi-shi-xiao-ji-170320/"/>
    <updated>2017-03-27T09:58:51+08:00</updated>
    <id>http://sxgfxm.github.io/blog/2017/03/27/ioszhi-shi-xiao-ji-170320</id>
    <content type="html"><![CDATA[<h2>iOS系统分享</h2>

<p>需增加版本判断：<code>UIActivityTypeOpenInIBooks</code>iOS 9.0之后才有。</p>

<h2>iOS导出音乐</h2>

<p>如何导出mp3：先按mov格式导出，再转为mp3。<br/>
如何包含metadata信息：m4a格式自动包含metadata信息，mp3无。<br/>
路径去除特殊字符。</p>

<!-- more -->


<h2>GCDWebserver后台运行</h2>

<p>设置option</p>

<pre><code>- (BOOL)startServer {
  for (int i = 0; i &lt; 10; i++) {
    //  随机端口号
    NSInteger port = arc4random_uniform(64510) + 1025;
    NSDictionary *options = @{
      GCDWebServerOption_ConnectedStateCoalescingInterval : @(20),
      GCDWebServerOption_Port : @(port)
    };
    NSError *error = nil;
    if ([self.webServer startWithOptions:options error:&amp;error]) {
      DDLogDebug(@"Start local server: %@", self.webServer.serverURL);
      return YES;
    }
  }
  return NO;
}
</code></pre>

<p class='post-footer'>
  原始地址：
  <a href='http://sxgfxm.github.io/blog/2017/03/27/ioszhi-shi-xiao-ji-170320/'>http://sxgfxm.github.io/blog/2017/03/27/ioszhi-shi-xiao-ji-170320/</a><br/>
  written by <a href='http://sxgfxm.github.io'>Light</a>
  &nbsp;posted at <a href='http://sxgfxm.github.io'>http://sxgfxm.github.io</a>
  </p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS知识小集-170313]]></title>
    <link href="http://sxgfxm.github.io/blog/2017/03/20/ioszhi-shi-xiao-ji-170313/"/>
    <updated>2017-03-20T16:50:46+08:00</updated>
    <id>http://sxgfxm.github.io/blog/2017/03/20/ioszhi-shi-xiao-ji-170313</id>
    <content type="html"><![CDATA[<h2>Masonry</h2>

<p>需要先添加到父视图，再设置约束。<br/>
block中无需使用weakself。<br/>
添加约束：makeConstrains。<br/>
更新约束：updateConstrains，与之相关的布局自动调整。<br/>
重设约束：remakeConstrains，删除之前的约束重新添加。</p>

<pre><code>[self.view updateConstraints:^(MASConstraintMaker *make){
  //  updateConstraints
}];
[self.view updateConstraints];
[self.view setNeedsLayout];
[UIView animateWithDuration:3 animations:^{
  [self.view layoutIfNeeded];
}];
</code></pre>

<!-- more -->


<h2>Autolayout</h2>

<p><code>setNeedsLayout</code>：使当前布局失效，并在下一个更新循环中触发布局更新，遍历view的结构。<br/>
<code>layoutIfNeeded</code>：强制立即更新布局，可以实现动画效果。<br/>
scrollview自动布局：添加tmpview，在tmpview上添加view，最后约束tmpview和contentsize。</p>

<h2>退出viewcontroller事件监听</h2>

<h2>IQActionSheetPickerView</h2>

<pre><code>IQActionSheetPickerView *picker = [IQActionSheetPickerView actionSheetWithTitle:@"Age" delegate:self];
NSArray *dataSource = @[@"10",@"20",@"30",@"40",@"50",@"60"];
[picker setTitlesForComponents:@[dataSource]];
[picker setSelectedTitles:@[@"20"]];
[picker show];
</code></pre>

<p>代理回调</p>

<pre><code>- (void)actionSheetPickerView:(IQActionSheetPickerView *)pickerView didSelectTitles:(NSArray *)titles {
}
</code></pre>

<p class='post-footer'>
  原始地址：
  <a href='http://sxgfxm.github.io/blog/2017/03/20/ioszhi-shi-xiao-ji-170313/'>http://sxgfxm.github.io/blog/2017/03/20/ioszhi-shi-xiao-ji-170313/</a><br/>
  written by <a href='http://sxgfxm.github.io'>Light</a>
  &nbsp;posted at <a href='http://sxgfxm.github.io'>http://sxgfxm.github.io</a>
  </p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS知识小集-170306]]></title>
    <link href="http://sxgfxm.github.io/blog/2017/03/10/ioszhi-shi-xiao-ji-170306/"/>
    <updated>2017-03-10T17:00:41+08:00</updated>
    <id>http://sxgfxm.github.io/blog/2017/03/10/ioszhi-shi-xiao-ji-170306</id>
    <content type="html"><![CDATA[<h2>异步回调</h2>

<ol>
<li>明确知道操作执行完成；</li>
<li>操作时间未知；</li>
</ol>


<!-- more -->


<h2>Block</h2>

<ol>
<li>对block中的内容强引用；</li>
<li>循环引用，类A的强property类B的强property block强引用self；</li>
<li>单例不用管循环引用；</li>
</ol>


<h2>内存划分</h2>

<ol>
<li>全局区；</li>
<li>静态区；</li>
<li>堆区；</li>
<li>栈区；</li>
</ol>


<h2>单例</h2>

<ol>
<li>如何创建单例？</li>
<li>何时创建单例？</li>
<li>单例的特性？</li>
</ol>


<h2>NSOperation</h2>

<pre><code>-(void)start;
-(void)main;
-(void)cancel;
-(void)addDependency:(NSOperation*)op;
-(void)removeDependency:(NSOperation*)op;
@property BOOL executing;
@property BOOL cancelled;
@property BOOL finished;
@property copy void (^completionBlock)(void);
</code></pre>

<p>使用方法：<br/>
1、继承NSOperation，通过init方法初始化，重写main方法执行任务；<br/>
2、可以通过completionBlock设置执行完成回调；<br/>
3、可以方便的判断任务执行状态，取消任务等；<br/>
4、可以添加和删除依赖关系，依赖其他operation的执行；<br/>
5、可以通过NSCondition阻塞，加锁，生产者-消费者；</p>

<h2>NSOperationQueue</h2>

<pre><code>@property NSInteger maxCoucurrentOperationCount;
@property NSInteger operationCount;
-(void)addOperation:(NSOperation*)op;
-(void)cancelAllOperations;
-(void)waitUntilAllOperationsAreFinished;
</code></pre>

<p>使用方法：<br/>
1、初始化NSOperationQueue，设置同时可并行任务数量；<br/>
2、创建任务，并将其加入队列中，任务自动开始执行；<br/>
3、可以通过operationCount判断还有多少任务未执行；</p>

<h2>HealthKit</h2>

<p>功能：存放健康数据，自动合并；<br/>
读：读某一类别健康数据；<br/>
写：写某一类别健康数据；<br/>
改：改自己写的健康数据。<br/>
锁屏时无法读数据，保护用户数据安全。</p>

<h2>UIPasteboard</h2>

<p>将信息写到剪切板中。</p>

<pre><code>UIPasteboard *pasteboard = [UIPasteboard generalPasteboard];
[pasteboard setString:string];
</code></pre>

<h2>发送本地通知</h2>

<pre><code>// 创建一个本地推送
UILocalNotification *notification = [UILocalNotification new];
if (notification != nil) {
  // 推送声音
  notification.soundName = UILocalNotificationDefaultSoundName;
  // 推送内容
  notification.alertBody = NSLocalizedString(@"stopWatch.timing", @"已将打点计时信息复制到剪切板");
  // 显示在icon上的红色圈中的数子
  notification.applicationIconBadgeNumber++;
  // 设置userinfo 方便在之后需要撤销的时候使用
  NSDictionary *info = [NSDictionary dictionaryWithObject:kStopWatchKey forKey:kNotificationKey];
  notification.userInfo = info;
  // 添加推送到UIApplication
  UIApplication *app = [UIApplication sharedApplication];
  [app scheduleLocalNotification:notification];
}
</code></pre>

<h2>string label</h2>

<pre><code>NSStringDrawingUsesLineFragmentOrigin | NSStringDrawingUsesFontLeading
ceil()
</code></pre>

<h2>相册和相机</h2>

<p>取消选择照片和选择没有照片是不同的回调。<br/>
相片可以编辑，相机不可以编辑。</p>

<h2>类方法、类变量、单例</h2>

<h2>埋点</h2>

<p>点击量；<br/>
人次；<br/>
存留；<br/>
停留时间；</p>

<p class='post-footer'>
  原始地址：
  <a href='http://sxgfxm.github.io/blog/2017/03/10/ioszhi-shi-xiao-ji-170306/'>http://sxgfxm.github.io/blog/2017/03/10/ioszhi-shi-xiao-ji-170306/</a><br/>
  written by <a href='http://sxgfxm.github.io'>Light</a>
  &nbsp;posted at <a href='http://sxgfxm.github.io'>http://sxgfxm.github.io</a>
  </p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS知识小集-170227]]></title>
    <link href="http://sxgfxm.github.io/blog/2017/03/06/ioszhi-shi-xiao-ji-170227/"/>
    <updated>2017-03-06T16:15:46+08:00</updated>
    <id>http://sxgfxm.github.io/blog/2017/03/06/ioszhi-shi-xiao-ji-170227</id>
    <content type="html"><![CDATA[<h2>OC中的锁</h2>

<pre><code>@implementation TestObj

-(void)method1{
  NSLog(@"Method1");
}
-(void)method2{
  NSLog(@"Method2");
}

@end
</code></pre>

<!--more-->


<h3>NSLock</h3>

<pre><code>NSLock *lock = [[NSLock alloc] init];
//线程1
dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
    [lock lock];
    [obj method1];
    sleep(10);
    [lock unlock];
});
//线程2
dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
    sleep(1);//以保证让线程2的代码后执行
    [lock lock];
    [obj method2];
    [lock unlock];
});
</code></pre>

<h3>synchronized关键字。</h3>

<pre><code>//主线程中
TestObj *obj = [[TestObj alloc] init];
//线程1
dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
    @synchronized(obj){
        [obj method1];
        sleep(10);
    }
});
//线程2
dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
    sleep(1);
    @synchronized(obj){
        [obj method2];
    }
});
</code></pre>

<h3>phread_mutex_t。</h3>

<pre><code>//主线程中
TestObj *obj = [[TestObj alloc] init];
__block pthread_mutex_t mutex;
pthread_mutex_init(&amp;mutex, NULL);
//线程1
dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
    pthread_mutex_lock(&amp;mutex);
    [obj method1];
    sleep(5);
    pthread_mutex_unlock(&amp;mutex);
});
//线程2
dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
    sleep(1);
    pthread_mutex_lock(&amp;mutex);
    [obj method2];
    pthread_mutex_unlock(&amp;mutex);
});
</code></pre>

<h3>GCD。</h3>

<pre><code>//主线程中
TestObj *obj = [[TestObj alloc] init];
dispatch_semaphore_t semaphore = dispatch_semaphore_create(1);
//线程1
dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
    dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);
    [obj method1];
    sleep(10);
    dispatch_semaphore_signal(semaphore);
});
//线程2
dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
    sleep(1);
    dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);
    [obj method2];
    dispatch_semaphore_signal(semaphore);
});
</code></pre>

<h2>生成圆形透明背景图片</h2>

<pre><code>+ (UIImage *)circularScaleAndCropImage:(UIImage *)image {
  // Create the bitmap graphics context
  UIGraphicsBeginImageContextWithOptions(CGSizeMake(image.size.width, image.size.height), NO, 0.0);
  CGContextRef context = UIGraphicsGetCurrentContext();

  // Get the width and heights
  CGFloat imageWidth = image.size.width;
  CGFloat imageHeight = image.size.height;

  // Calculate the centre of the circle
  CGFloat imageCentreX = imageWidth / 2;
  CGFloat imageCentreY = imageHeight / 2;

  // Create and CLIP to a CIRCULAR Path
  CGFloat radius = imageWidth / 2;
  CGContextBeginPath(context);
  CGContextAddArc(context, imageCentreX, imageCentreY, radius, 0, 2 * M_PI, 0);
  CGContextClosePath(context);
  CGContextClip(context);

  // Draw the IMAGE
  CGRect myRect = CGRectMake(0, 0, imageWidth, imageHeight);
  [image drawInRect:myRect];

  UIImage *newImage = UIGraphicsGetImageFromCurrentImageContext();
  UIGraphicsEndImageContext();

  return newImage;
}
</code></pre>

<h2>RxJava</h2>

<p>响应式函数编程<br/>
订阅的思想<br/>
多层异步回调逻辑更清晰</p>

<h2>Socket</h2>

<p><strong>Packet-based communication</strong><br/>
<strong>Stream-based clients </strong></p>

<p class='post-footer'>
  原始地址：
  <a href='http://sxgfxm.github.io/blog/2017/03/06/ioszhi-shi-xiao-ji-170227/'>http://sxgfxm.github.io/blog/2017/03/06/ioszhi-shi-xiao-ji-170227/</a><br/>
  written by <a href='http://sxgfxm.github.io'>Light</a>
  &nbsp;posted at <a href='http://sxgfxm.github.io'>http://sxgfxm.github.io</a>
  </p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS知识小集-170220]]></title>
    <link href="http://sxgfxm.github.io/blog/2017/03/06/ioszhi-shi-xiao-ji-170220/"/>
    <updated>2017-03-06T16:06:34+08:00</updated>
    <id>http://sxgfxm.github.io/blog/2017/03/06/ioszhi-shi-xiao-ji-170220</id>
    <content type="html"><![CDATA[<h2>App生命周期</h2>

<p><strong>main.m</strong>：app程序入口，将控制权交给UIKit framework。<br/>
<strong>UIApplication</strong>：管理事件循环和高级行为，传递通知给代理。<br/>
<strong>App Delegate</strong>：处理应用初始化，状态转换，等高级行为。每个应用都要有。<br/>
<strong>Data Model</strong>：存储应用数据。<br/>
<strong>View Controller</strong>：管理应用展示内容。<br/>
<strong>View</strong>：展示内容。<br/>
<strong>Main Run Loop</strong>：Main run loop由UIApplication在主线程中开启，保证用户操作串行执行。
用户操作 -> 操作系统 -> 端口 -> 事件队列 -> Main run loop -> App object -> Core object
-> 操作系统 -> 屏幕反馈。<br/>
<strong>执行状态</strong>：<br/>
- 关闭状态。<br/>
- 未激活状态：在前台运行，但未接收到事件。<br/>
- 激活状态：在前台运行，接收到事件。<br/>
- 后台状态：在后台，且正在执行程序，通常会接着进入挂起状态。<br/>
- 挂起状态：在后台，且没有执行程序。当内存不足时会清理挂起应用。</p>

<!--more-->


<h2>后台执行</h2>

<p><strong>限时操作</strong>：调用<code>beginBackgroundTaskWithName:expirationHandler:</code>或<code>beginBackgroundTaskWithExpirationHandler:</code>开启后台执行，在执行完成后必须调用<code>endBackgroundTask:</code>表示结束后台执行，否则程序会被终止。可以通过<code>application.backgroundTimeRemaining</code>查看剩余后台执行时间，一般为180秒。</p>

<pre><code>- (void)applicationDidEnterBackground:(UIApplication *)application
{
    bgTask = [application beginBackgroundTaskWithName:@"MyTask" expirationHandler:^{
        // Clean up any unfinished task business by marking where you
        // stopped or ending the task outright.
        [application endBackgroundTask:bgTask];
        bgTask = UIBackgroundTaskInvalid;
    }];

    // Start the long-running task and return immediately.
    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{

        // Do the work associated with the task, preferably in chunks.

        NSLog(@"begin %.f", application.backgroundTimeRemaining);
        [NSThread sleepForTimeInterval:10];
        NSLog(@"end %.f", application.backgroundTimeRemaining);

        [application endBackgroundTask:bgTask];
        bgTask = UIBackgroundTaskInvalid;
    });
}
</code></pre>

<p><strong>下载操作</strong>：必须使用<strong>NSURLSession</strong>开启下载操作，需要通过<strong>NSURLSessionConfiguration</strong>进行设置。</p>

<pre><code>- (void)startDownloadTask {
  //  Configuration
  NSURLSessionConfiguration *config = [NSURLSessionConfiguration
      backgroundSessionConfigurationWithIdentifier:@"DownloadTask"];
  //  下载完成时唤醒应用
  config.sessionSendsLaunchEvents = YES;
  //  在前台时开启下载任务时有效
  config.discretionary = YES;
  //  NSURLSession
  NSURLSession *session = [NSURLSession sessionWithConfiguration:config];
  //  开启下载任务
  NSURLSessionTask *task =
      [session dataTaskWithURL:[NSURL URLWithString:@"www.baidu.com"]
             completionHandler:^(NSData *_Nullable data,
                                 NSURLResponse *_Nullable response,
                                 NSError *_Nullable error){

             }];
  //  当挂起时恢复任务
  [task resume];
}
</code></pre>

<p><strong>耗时操作</strong>：只有特殊的耗时操作可以在后台被执行，且必须申请权限。如后台音乐播放、录音、定位信息更新、蓝牙连接、远程通知、语音服务等。</p>

<h2>ViewController生命周期</h2>

<h2>权限操作</h2>

<p>iOS 10开始，获取<strong>隐私</strong>敏感数据需要在<strong>plist.info</strong>文件中配置，否则app会crash。<br/>
配置方法：添加对应权限的key和value，value不许为空。<br/>
常用权限：</p>

<ul>
<li>Network：无需添加key</li>
<li>Location：Privacy - Location Always Usage Description</li>
<li>Photo：Privacy - Photo Library Usage Description</li>
<li>Camera：Privacy - Camera Usage Description</li>
<li>Microphone：Privacy - Microphone Usage Description</li>
<li>Contact：Privacy - Contacts Usage Description</li>
<li>Media：Privacy - Media Library Usage Description</li>
</ul>


<p>手动请求权限：当用户拒绝授权某权限时，需要手动再次请求。<br/>
跳转至权限设置界面：</p>

<pre><code>[[UIApplication sharedApplication]
                openURL:[NSURL URLWithString:UIApplicationOpenSettingsURLString]
                options:@{}
      completionHandler:nil];
</code></pre>

<p><a href="https://github.com/sxgfxm/AuthorizationDemo">Demo地址</a></p>

<h2>文件操作</h2>

<ul>
<li>NSString I/O</li>
<li>NSArray I/O</li>
<li>NSDictionary I/O</li>
<li>NSData I/O</li>
<li>NSObject I/O</li>
<li>NSFileManager</li>
<li>NSFileHandle</li>
</ul>


<p><a href="https://github.com/sxgfxm/FileOperationDemo">Demo地址</a></p>

<h2>weakself</h2>

<p>作用：<strong>防止循环引用</strong>。<br/>
声明：<code>__weak typeof(self) weakself = self;</code>。<br/>
使用：
1. 是不是所有的block中都需要使用weakself？<br/>
   Masonry自动约束中无需使用weakself。
2. 详细解释循环引用及防止方法？</p>

<h2>单元测试</h2>

<blockquote><p>If your code isn’t easy to test, it’s not going to be easy to maintain or debug.</p></blockquote>

<p>验证某个类的某种行为在某种上下文中能得到预期结果。<br/>
保证每个测试用例所针对的仅仅是一个基本单元，而不是一个有很多复杂依赖的综合行为。<br/>
依赖于抽象而不是具体实现细节。<br/>
不应关注于<strong>测试</strong>，而应关注<strong>行为</strong>。测试对象的行为方式。<br/>
降低未来的变化所带来的成本。<br/>
<strong>功能检测</strong><br/>
<strong>依赖提取</strong><br/>
<strong>依赖注入</strong><br/>
<strong>行为方式</strong><br/>
1. 单元测试测什么？<br/>
   方法？行为？<br/>
2. 如何处理依赖关系？<br/>
   Mock？Stub？<br/>
3. 单元测试的优缺点？<br/>
   优点：验证模块的功能正确，行为正确，模块化编程，尽早发现问题，检验修改，重构；<br/>
   缺点：增加代码量，写好测试不容易，不能保证不出错，考虑后期维护，尽量减少源代码耦合。<br/>
4. 测试库？<br/>
   <a href="https://github.com/jonreid/OCMockito">OCMockito</a><br/>
5. 断言？<br/>
   同步断言？异步断言（block，代理）？</p>

<h2>A/B Test</h2>

<h2>同步策略</h2>

<h2>JavaScriptCore</h2>

<p><strong>JSContext</strong>：是运行JavaScript代码的环境。<br/>
<strong>JSValue</strong>：JSContext的运行结果封装在JSValue中。<br/>
OC -> JavaScript：<strong>SubscriptValue</strong>、<strong>CallFunction</strong>，<strong>HandleException</strong>。<br/>
JavaScript -> OC：<strong>Block</strong>或<strong>JSExport</strong>。</p>

<p class='post-footer'>
  原始地址：
  <a href='http://sxgfxm.github.io/blog/2017/03/06/ioszhi-shi-xiao-ji-170220/'>http://sxgfxm.github.io/blog/2017/03/06/ioszhi-shi-xiao-ji-170220/</a><br/>
  written by <a href='http://sxgfxm.github.io'>Light</a>
  &nbsp;posted at <a href='http://sxgfxm.github.io'>http://sxgfxm.github.io</a>
  </p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS System Authorization]]></title>
    <link href="http://sxgfxm.github.io/blog/2017/02/25/ios-system-authorization/"/>
    <updated>2017-02-25T14:17:43+08:00</updated>
    <id>http://sxgfxm.github.io/blog/2017/02/25/ios-system-authorization</id>
    <content type="html"><![CDATA[<p>iOS 10开始，获取<strong>隐私</strong>敏感数据需要在<strong>plist.info</strong>文件中配置，否则app会crash。<br/>
配置方法：添加对应权限的key和value，value不许为空。<br/>
常用权限：</p>

<ul>
<li>Network：无需添加key</li>
<li>Location：Privacy - Location Always Usage Description</li>
<li>Photo：Privacy - Photo Library Usage Description</li>
<li>Camera：Privacy - Camera Usage Description</li>
<li>Microphone：Privacy - Microphone Usage Description</li>
<li>Contact：Privacy - Contacts Usage Description</li>
<li>Media：Privacy - Media Library Usage Description</li>
</ul>


<p>手动请求权限：当用户拒绝授权某权限时，需要手动再次请求。<br/>
跳转至权限设置界面：</p>

<pre><code>[[UIApplication sharedApplication]
                openURL:[NSURL URLWithString:UIApplicationOpenSettingsURLString]
                options:@{}
      completionHandler:nil];
</code></pre>

<p><a href="https://github.com/sxgfxm/AuthorizationDemo">Demo地址</a></p>

<p class='post-footer'>
  原始地址：
  <a href='http://sxgfxm.github.io/blog/2017/02/25/ios-system-authorization/'>http://sxgfxm.github.io/blog/2017/02/25/ios-system-authorization/</a><br/>
  written by <a href='http://sxgfxm.github.io'>Light</a>
  &nbsp;posted at <a href='http://sxgfxm.github.io'>http://sxgfxm.github.io</a>
  </p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS Core Animation Advanced Techniques]]></title>
    <link href="http://sxgfxm.github.io/blog/2017/02/20/ios-core-animation-advanced-techniques/"/>
    <updated>2017-02-20T22:10:40+08:00</updated>
    <id>http://sxgfxm.github.io/blog/2017/02/20/ios-core-animation-advanced-techniques</id>
    <content type="html"><![CDATA[<h1>Introduction</h1>

<p>本文主要为<strong>iOS Core Animation Advanced Techniques</strong>的笔记。</p>

<!--more-->


<h2>CALayer和UIView</h2>

<p>1.CALayer和UIView有什么关系？<br/>
UIView是对CALayer的封装，可以处理touch事件。<br/>
UIView是通过CALayer显示的。<br/>
UIView会自动重绘，CALayer需要手动重绘。<br/>
UIView是二维的，CALayer是三维的。<br/>
UIView支持autoLayout，CALayer不支持autoLayout。<br/>
2、CALayer的特性是什么？<br/>
可以绘制阴影、圆角、彩色边框；<br/>
可以处理3D变换；<br/>
可以处理非矩形边界；<br/>
可以处理透明遮罩；<br/>
可以处理多级非线性动画。<br/>
3、什么情况下会使用CALayer？<br/>
开发跨平台应用；<br/>
与特殊图层打交道；<br/>
提高性能。<br/>
4、为什么不把CALayer和UIView合二为一，而是有两套并列的层次结构？<br/>
把绘图和事件处理分离，是为了减少重复的代码。<br/>
在Mac OS上已经有CALayer，但在iPhone和Mac的交互是有本质不同的，所以UIView来处理。</p>

<h3>Contents</h3>

<p>1、如何让UIView等比清晰显示图片的右上角？<br/>
<code>layer.contents = (__bridge id)image.CGImage;</code><br/>
<code>layer.contentsGravity = kCAGravityResizeAspect;</code><br/>
<code>layer.contentsScale = [UIScreen mainScreen].scale;</code><br/>
<code>layer.contentsRect = CGRectMake(0.5,0,0.5,0.5);</code><br/>
2、-drawRect:方法的作用是什么？空的-drawRect:方法有何影响？<br/>
UIView自定义绘图。<br/>
如果自己实现-drawRect:方法，会为view创建一个backing image。<br/>
3、如何绘制带阴影的有裁剪效果的UIView？<br/>
设置layer阴影；<br/>
通过layer代理绘图；</p>

<h3>Geometry</h3>

<p>1、center, position的区别？<br/>
center对应view；position对应layer。<br/>
两者都表示anchorPoint在父视图中的位置。<br/>
因为UIView并没有暴露anchorPoint属性，所以被称作center。<br/>
2、anchorPoint理解？<br/>
控制点。<br/>
3、frame的理解？<br/>
是否可以改变view的frame而不改变layer的frame。<br/>
frame是由bounds，position和transform计算而来的。<br/>
4、坐标转换？</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (CGPoint)convertPoint:(CGPoint)point fromLayer:(CALayer *)layer;
</span><span class='line'>- (CGPoint)convertPoint:(CGPoint)point toLayer:(CALayer *)layer;
</span><span class='line'>- (CGRect)convertRect:(CGRect)rect fromLayer:(CALayer *)layer;
</span><span class='line'>- (CGRect)convertRect:(CGRect)rect toLayer:(CALayer *)layer;</span></code></pre></td></tr></table></div></figure>


<p>5、坐标翻转</p>

<p><code>layer.geometryFlipped = YES;</code></p>

<p>6、如何在不修改layer层次结构的情况下，使下层的layer在顶层显示？<br/>
zPosition，用来改变layer的显示层次；<br/>
zAnchorPoint?<br/>
7、如何用CALayer实现touch handling？<br/>
-containsPoint:<br/>
-hitTest: 严格按照layer tree的层次结构判断，与zPosition无关。<br/>
8、如何实现CALayer的自动布局？<br/>
<code>- (void)layoutSublayersOfLayer:(CALayer *)layer;</code>，<br/>
当bounds改变或调用<code>-setNeedsLayout</code>时触发。</p>

<h3>Visual Effects</h3>

<p>1、如何实现圆角？曲率不同的圆角？</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>layer.cornerRadius = 5.0f;
</span><span class='line'>layer.maskToBounds = YES;</span></code></pre></td></tr></table></div></figure>


<p>2、如何实现彩色边框？</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>layer.borderWidth = 1;
</span><span class='line'>layer.borderColor = [UIColor redColor].CGColor;</span></code></pre></td></tr></table></div></figure>


<p>border只与bounds相关。<br/>
3、如何添加阴影？</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>layer.shadowOpacity = 1;
</span><span class='line'>layer.shadowColor = [UIColor redColor].CGColor;
</span><span class='line'>layer.shadowOffset = CGSizeMake(0,1);
</span><span class='line'>layer.shadowRadius = 5;</span></code></pre></td></tr></table></div></figure>


<p>shadow与形状有关。<br/>
如何添加maskToBounds = YES时的阴影？<br/>
两层。<br/>
如何绘制不规则阴影？<br/>
<code>layer.shadowPath = path;</code>
4、不规则裁剪，动态裁剪<br/>
<code>layer.mask = maskLayer;</code>
5、scaling filter<br/>
kCAFilterNearest，适用于无对角线，对比明显的图片，保留像素，像素图；<br/>
kCAFilterLinear，适用于复杂图片，保留轮廓；<br/>
6、group opacity<br/>
opacity作用于层次结构，0.5+0.5 = 0.75<br/>
UIViewGroupOpacity = YES，Info.plist，降低性能。<br/>
<code>layer.shouldRasterize = YES</code>，在渲染前合成一张图片，防止alpha值影响。<br/>
<code>layer.rasterizationScale = [UIScreen mainScreen].scale;</code></p>

<h3>Transform</h3>

<p>1、Affine Transforms，仿射变换<br/>
CGAffineTransform，用来表示二维旋转，缩放和变换。对一个2D点做2D变换。<br/>
它是一个3行2列的矩阵。<br/>
做运算时需要扩展。<br/>
变换前平行的线，变换后依然平行。<br/>
2、创建仿射变换</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>CGAffineTransformMakeRotation(CGFloat angle);
</span><span class='line'>CGAffineTransformMakeScale(CGFloat sx, CGFloat sy);
</span><span class='line'>CGAffineTransformMakeTranslation(CGFloat tx, CGFloat ty);</span></code></pre></td></tr></table></div></figure>


<p>角度弧度转换</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#define RADIANS_TO_DEGREES(x) ((x)/M_PI*180.0)
</span><span class='line'>#define DEGREES_TO_RADIANS(x) ((x)/180.0*M_PI)</span></code></pre></td></tr></table></div></figure>


<p>3、连续变换</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>CGAffineTransformRotate(CGAffineTransform t, CGFloat angle);
</span><span class='line'>CGAffineTransformScale(CGAffineTransform t, CGFloat sx, CGFloat sy);
</span><span class='line'>CGAffineTransformTranslate(CGAffineTransform t, CGFloat tx, CGFloat ty);
</span><span class='line'>或
</span><span class='line'>CGAffineTransformConcat(CGAffineTransform t1, CGAffineTransform t2);</span></code></pre></td></tr></table></div></figure>


<p>单位矩阵，CGAffineTransformIdentity。<br/>
变换顺序不同，结果不同。因为矩阵运算不符合交换律。<br/>
4、shear变换</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>CGAffineTransform CGAffineTransformMakeShear(CGFloat x, CGFloat y) {
</span><span class='line'>  CGAffineTransform transform = CGAffineTransformIdentity; transform.c = -x;
</span><span class='line'>  transform.b = y;
</span><span class='line'>  return transform;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>5、3D Transform，3D变换<br/>
CATransform3D，是一个4行4列的矩阵。对一个3D点做3D变换。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>CATransform3DMakeRotation(CGFloat angle, CGFloat x, CGFloat y, CGFloat z);
</span><span class='line'>CATransform3DMakeScale(CGFloat sx, CGFloat sy, CGFloat sz);
</span><span class='line'>CATransform3DMakeTranslation(Gloat tx, CGFloat ty, CGFloat tz);</span></code></pre></td></tr></table></div></figure>


<p>6、Perspective Projection，透视<br/>
矩阵中m34的值用来设置透视，值越小透视约明显，值越大透视越不明显。<br/>
7、The Vanishing Point，消失点<br/>
定义消失点为anchorPoint。<br/>
8、sublayer共享透视视角<br/>
设置sublayerTransform<br/>
9、Backfaces，<br/>
layer是两面都有的。可以设置取消。</p>

<h2>Specialized Layers</h2>

<h3>CAShapeLayer</h3>

<p>CAShapeLayer比Core Graphics效率更高，硬件加速；<br/>
CAShapeLayer节省内存空间，不会创建backing image；<br/>
CAShapeLayer不会受bounds限制，Core Graphics不行；<br/>
CAShapeLayer不会变换后不会像素化。<br/>
基本使用方法：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>CAShapeLayer *shapeLayer = [CAShapeLayer layer];
</span><span class='line'>shapeLayer.strokeColor = [UIColor redColor].CGColor;
</span><span class='line'>shapeLayer.fillColor = [UIColor clearColor].CGColor;
</span><span class='line'>shapeLayer.lineWidth = 5;
</span><span class='line'>shapeLayer.lineJoin = kCALineJoinRound;
</span><span class='line'>shapeLayer.lineCap = kCALineCapRound;
</span><span class='line'>shapeLayer.path = path.CGPath;</span></code></pre></td></tr></table></div></figure>


<h3>CATextLayer</h3>

<p>UILabel，通过layer代理方法使用CG绘制string。<br/>
CATextLayer，用于显示文字，特效，效率比UILabel高。<br/>
基本使用方法：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>//set text attributes
</span><span class='line'>textLayer.foregroundColor = [UIColor blackColor].CGColor;
</span><span class='line'>textLayer.alignmentMode = kCAAlignmentJustified;
</span><span class='line'>textLayer.wrapped = YES;
</span><span class='line'>
</span><span class='line'>//choose a font
</span><span class='line'>UIFont *font = [UIFont systemFontOfSize:15];
</span><span class='line'>
</span><span class='line'>//set layer font
</span><span class='line'>CFStringRef fontName = (__bridge CFStringRef)font.fontName;
</span><span class='line'>CGFontRef fontRef = CGFontCreateWithFontName(fontName);
</span><span class='line'>textLayer.font = fontRef;
</span><span class='line'>textLayer.fontSize = font.pointSize;
</span><span class='line'>CGFontRelease(fontRef);
</span><span class='line'>
</span><span class='line'>//text
</span><span class='line'>textLayer.string = @"Text";
</span><span class='line'>
</span><span class='line'>//scale
</span><span class='line'>textLayer.contentsScale = [UIScreen mainScreen].scale;</span></code></pre></td></tr></table></div></figure>


<p>富文本：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>//create attributed string
</span><span class='line'>NSMutableAttributedString *string = nil;
</span><span class='line'>string = [[NSMutableAttributedString alloc] initWithString:text];
</span><span class='line'>
</span><span class='line'>//convert UIFont to a CTFont
</span><span class='line'>CFStringRef fontName = (__bridge CFStringRef)font.fontName; CGFloat fontSize = font.pointSize;
</span><span class='line'>CTFontRef fontRef = CTFontCreateWithName(fontName, fontSize, NULL);
</span><span class='line'>
</span><span class='line'>//set text attributes
</span><span class='line'>NSDictionary *attribs = @{
</span><span class='line'>  (__bridge id)kCTForegroundColorAttributeName:(__bridge id)[UIColor blackColor].CGColor,
</span><span class='line'>  (__bridge id)kCTFontAttributeName: (__bridge id)fontRef
</span><span class='line'>};
</span><span class='line'>[string setAttributes:attribs range:NSMakeRange(0, [text length])];
</span><span class='line'>attribs = @{
</span><span class='line'>  (__bridge id)kCTForegroundColorAttributeName: (__bridge id)[UIColor redColor].CGColor,
</span><span class='line'>  (__bridge id)kCTUnderlineStyleAttributeName: @(kCTUnderlineStyleSingle),
</span><span class='line'>  (__bridge id)kCTFontAttributeName: (__bridge id)fontRef
</span><span class='line'>};
</span><span class='line'>[string setAttributes:attribs range:NSMakeRange(6, 5)];
</span><span class='line'>
</span><span class='line'>//release the CTFont we created earlier
</span><span class='line'>CFRelease(fontRef);
</span><span class='line'>
</span><span class='line'>//set layer text
</span><span class='line'>textLayer.string = string;</span></code></pre></td></tr></table></div></figure>


<p>修改view的根layer。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>+ (Class)layerClass {
</span><span class='line'>  //this makes our label create a CATextLayer
</span><span class='line'>  //instead of a regular CALayer for its backing layer
</span><span class='line'>  return [CATextLayer class];
</span><span class='line'>}
</span><span class='line'>- (CATextLayer *)textLayer {
</span><span class='line'>  return (CATextLayer *)self.layer;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h3>CATransformLayer</h3>

<p>保存变换后的layer</p>

<h3>CAGradientLayer</h3>

<p>用于绘制渐变层。<br/>
线性渐变。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>//create gradient layer and add it to our container view
</span><span class='line'>CAGradientLayer *gradientLayer = [CAGradientLayer layer];
</span><span class='line'>gradientLayer.frame = self.containerView.bounds;
</span><span class='line'>[self.containerView.layer addSublayer:gradientLayer];
</span><span class='line'>
</span><span class='line'>//set gradient colors
</span><span class='line'>gradientLayer.colors = @[
</span><span class='line'>  (__bridge id)[UIColor redColor].CGColor,
</span><span class='line'>  (__bridge id)[UIColor blueColor].CGColor,
</span><span class='line'>  (__bridge id)[UIColor greenColor].CGColor
</span><span class='line'>];
</span><span class='line'>
</span><span class='line'>//set locations
</span><span class='line'>gradientLayer.locations = @[@0.0, @0.25, @0.5];
</span><span class='line'>
</span><span class='line'>//set gradient start and end points
</span><span class='line'>gradientLayer.startPoint = CGPointMake(0, 0);
</span><span class='line'>gradientLayer.endPoint = CGPointMake(1, 1);</span></code></pre></td></tr></table></div></figure>


<p>放射性渐变。</p>

<h3>CAReplicatorLayer</h3>

<p>用于高效绘制相似的layer。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>//create a replicator layer and add it to our view
</span><span class='line'>CAReplicatorLayer *replicator = [CAReplicatorLayer layer];
</span><span class='line'>replicator.frame = self.containerView.bounds;
</span><span class='line'>[self.containerView.layer addSublayer:replicator];
</span><span class='line'>
</span><span class='line'>//configure the replicator
</span><span class='line'>replicator.instanceCount = 10;
</span><span class='line'>
</span><span class='line'>//apply a transform for each instance
</span><span class='line'>CATransform3D transform = CATransform3DIdentity;
</span><span class='line'>transform = CATransform3DTranslate(transform, 0, 200, 0);
</span><span class='line'>transform = CATransform3DRotate(transform, M_PI / 5.0, 0, 0, 1);
</span><span class='line'>transform = CATransform3DTranslate(transform, 0, -200, 0);
</span><span class='line'>replicator.instanceTransform = transform;
</span><span class='line'>
</span><span class='line'>//apply a color shift for each instance
</span><span class='line'>replicator.instanceBlueOffset = -0.1;
</span><span class='line'>replicator.instanceGreenOffset = -0.1;
</span><span class='line'>
</span><span class='line'>//create a sublayer and place it inside the replicator
</span><span class='line'>CALayer *layer = [CALayer layer];
</span><span class='line'>layer.frame = CGRectMake(100.0f, 100.0f, 100.0f, 100.0f);
</span><span class='line'>layer.backgroundColor = [UIColor whiteColor].CGColor;
</span><span class='line'>[replicator addSublayer:layer];</span></code></pre></td></tr></table></div></figure>


<p>绘制镜面</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>+ (Class)layerClass {
</span><span class='line'>  return [CAReplicatorLayer class];
</span><span class='line'>}
</span><span class='line'>- (void)setUp {
</span><span class='line'>  //configure replicator
</span><span class='line'>  CAReplicatorLayer *layer = (CAReplicatorLayer *)self.layer;
</span><span class='line'>  layer.instanceCount = 2;
</span><span class='line'>
</span><span class='line'>  //move reflection instance below original and flip vertically
</span><span class='line'>  CATransform3D transform = CATransform3DIdentity;
</span><span class='line'>  CGFloat verticalOffset = self.bounds.size.height + 2;
</span><span class='line'>  transform = CATransform3DTranslate(transform, 0, verticalOffset, 0);
</span><span class='line'>  transform = CATransform3DScale(transform, 1, -1, 0);
</span><span class='line'>  layer.instanceTransform = transform;
</span><span class='line'>
</span><span class='line'>  //reduce alpha of reflection layer
</span><span class='line'>  layer.instanceAlphaOffset = -0.6;
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>- (id)initWithFrame:(CGRect)frame {
</span><span class='line'>  //this is called when view is created in code
</span><span class='line'>  if ((self = [super initWithFrame:frame])) {
</span><span class='line'>    [self setUp];
</span><span class='line'>  }
</span><span class='line'>  return self;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h3>CAScrollLayer</h3>

<p>用于绘制可以滑动的layer。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>+ (Class)layerClass {
</span><span class='line'>  return [CAScrollLayer class];
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>- (void)setUp {
</span><span class='line'>  //enable clipping
</span><span class='line'>  self.layer.masksToBounds = YES;
</span><span class='line'>
</span><span class='line'>  //attach pan gesture recognizer
</span><span class='line'>  UIPanGestureRecognizer *recognizer = nil;
</span><span class='line'>  recognizer = [[UIPanGestureRecognizer alloc] initWithTarget:self action:@selector(pan:)];
</span><span class='line'>  [self addGestureRecognizer:recognizer];
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>- (id)initWithFrame:(CGRect)frame {
</span><span class='line'>  //this is called when view is created in code
</span><span class='line'>  if ((self = [super initWithFrame:frame])) {
</span><span class='line'>    [self setUp];
</span><span class='line'>  }
</span><span class='line'>  return self;
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>- (void)pan:(UIPanGestureRecognizer *)recognizer {
</span><span class='line'>  //get the offset by subtracting the pan gesture
</span><span class='line'>  //translation from the current bounds origin
</span><span class='line'>  CGPoint offset = self.bounds.origin;
</span><span class='line'>  offset.x -= [recognizer translationInView:self].x;
</span><span class='line'>  offset.y -= [recognizer translationInView:self].y;
</span><span class='line'>
</span><span class='line'>  //scroll the layer
</span><span class='line'>  [(CAScrollLayer *)self.layer scrollToPoint:offset];
</span><span class='line'>
</span><span class='line'>  //reset the pan gesture translation
</span><span class='line'>  [recognizer setTranslation:CGPointZero inView:self];
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h3>CATiledLayer</h3>

<p>用于加载尺寸巨大的图片。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>//add the tiled layer
</span><span class='line'>CATiledLayer *tileLayer = [CATiledLayer layer];
</span><span class='line'>tileLayer.frame = CGRectMake(0, 0, 2048, 2048);
</span><span class='line'>tileLayer.delegate = self; [self.scrollView.layer addSublayer:tileLayer];
</span><span class='line'>
</span><span class='line'>//configure the scroll view
</span><span class='line'>self.scrollView.contentSize = tileLayer.frame.size;
</span><span class='line'>
</span><span class='line'>//draw layer
</span><span class='line'>[tileLayer setNeedsDisplay];
</span><span class='line'>
</span><span class='line'>- (void)drawLayer:(CATiledLayer *)layer inContext:(CGContextRef)ctx {
</span><span class='line'>  //determine tile coordinate
</span><span class='line'>  CGRect bounds = CGContextGetClipBoundingBox(ctx);
</span><span class='line'>  NSInteger x = floor(bounds.origin.x / layer.tileSize.width);
</span><span class='line'>  NSInteger y = floor(bounds.origin.y / layer.tileSize.height);
</span><span class='line'>
</span><span class='line'>  //load tile image
</span><span class='line'>  NSString *imageName = [NSString stringWithFormat: @"Snowman_%02i_%02i, x, y];
</span><span class='line'>  NSString *imagePath = [[NSBundle mainBundle] pathForResource:imageName ofType:@"jpg"];
</span><span class='line'>  UIImage *tileImage = [UIImage imageWithContentsOfFile:imagePath];
</span><span class='line'>
</span><span class='line'>  //draw tile
</span><span class='line'>  UIGraphicsPushContext(ctx);
</span><span class='line'>  [tileImage drawInRect:bounds];
</span><span class='line'>  UIGraphicsPopContext();
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h3>CAEmitterLayer</h3>

<p>粒子特效。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>//create particle emitter layer
</span><span class='line'>CAEmitterLayer *emitter = [CAEmitterLayer layer];
</span><span class='line'>emitter.frame = self.containerView.bounds;
</span><span class='line'>[self.containerView.layer addSublayer:emitter];
</span><span class='line'>
</span><span class='line'>//configure emitter
</span><span class='line'>emitter.renderMode = kCAEmitterLayerAdditive;
</span><span class='line'>emitter.emitterPosition = CGPointMake(emitter.frame.size.width / 2.0,emitter.frame.size.height / 2.0);
</span><span class='line'>
</span><span class='line'>//create a particle template
</span><span class='line'>CAEmitterCell *cell = [[CAEmitterCell alloc] init];
</span><span class='line'>cell.contents = (__bridge id)[UIImage imageNamed:@"Spark.png"].CGImage;
</span><span class='line'>cell.birthRate = 150;
</span><span class='line'>cell.lifetime = 5.0;
</span><span class='line'>cell.color = [UIColor colorWithRed:1 green:0.5 blue:0.1 alpha:1.0].CGColor;
</span><span class='line'>cell.alphaSpeed = -0.4;
</span><span class='line'>cell.velocity = 50;
</span><span class='line'>cell.velocityRange = 50;
</span><span class='line'>cell.emissionRange = M_PI * 2.0;
</span><span class='line'>
</span><span class='line'>//add particle template to emitter
</span><span class='line'>emitter.emitterCells = @[cell];</span></code></pre></td></tr></table></div></figure>


<h3>AVPlayerLayer</h3>

<p>播放视频。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>//get video URL
</span><span class='line'>NSURL *URL = [[NSBundle mainBundle] URLForResource:@"Ship" withExtension:@"mp4"];
</span><span class='line'>
</span><span class='line'>//create player and player layer
</span><span class='line'>AVPlayer *player = [AVPlayer playerWithURL:URL];
</span><span class='line'>AVPlayerLayer *playerLayer = [AVPlayerLayer playerLayerWithPlayer:player];
</span><span class='line'>
</span><span class='line'>//set player layer frame and attach it to our view
</span><span class='line'>playerLayer.frame = self.containerView.bounds;
</span><span class='line'>[self.containerView.layer addSublayer:playerLayer];
</span><span class='line'>
</span><span class='line'>//play the video
</span><span class='line'>[player play];</span></code></pre></td></tr></table></div></figure>


<h2>Implicit Animations</h2>

<p>隐式动画。改变支持动画的属性，自动生成动画。<br/>
duration -> transaction，默认为0.25秒<br/>
type -> layer action<br/>
transaction只能begin和commit。<br/>
每次runloop会执行一次transaction。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>//begin a new transaction
</span><span class='line'>[CATransaction begin];
</span><span class='line'>
</span><span class='line'>//set the animation duration to 1 second
</span><span class='line'>[CATransaction setAnimationDuration:1.0];
</span><span class='line'>
</span><span class='line'>//add the spin animation on completion
</span><span class='line'>[CATransaction setCompletionBlock:^{
</span><span class='line'>  //rotate the layer 90 degrees
</span><span class='line'>  CGAffineTransform transform = self.colorLayer.affineTransform;
</span><span class='line'>  transform = CGAffineTransformRotate(transform, M_PI_2);
</span><span class='line'>  self.colorLayer.affineTransform = transform;
</span><span class='line'>}];
</span><span class='line'>
</span><span class='line'>//randomize the layer background color
</span><span class='line'>CGFloat red = arc4random() / (CGFloat)INT_MAX;
</span><span class='line'>CGFloat green = arc4random() / (CGFloat)INT_MAX;
</span><span class='line'>CGFloat blue = arc4random() / (CGFloat)INT_MAX;
</span><span class='line'>self.colorLayer.backgroundColor = [UIColor colorWithRed:red green:green blue:blue alpha:1.0].CGColor;
</span><span class='line'>
</span><span class='line'>//commit the transaction
</span><span class='line'>[CATransaction commit];
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>隐式动画流程：<br/>
-actionForLayer:forKey<br/>
actions dictionary<br/>
style dictionary<br/>
-defaultActionForKey:</p>

<p>UIView默认不开启隐式动画。<br/>
CATransition</p>

<p>修改layer属性会立即生效，但是并不会立刻显示。</p>

<p>presentation layer，记录当前layer在哪儿，同步动画和处理点击事件。<br/>
model layer，记录当前layer要去哪儿</p>

<h2>Explicit Aniamtions</h2>

<p>显式动画。</p>

<h3>Property Animations</h3>

<p>只与一个属性相关的动画。</p>

<p>CABasicAnimation : CAPropertyAnimation : CAAnimation<br/>
fromeValue<br/>
toValue<br/>
byValue</p>

<p>Animations只作用于presentation，而不作用于model。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (void)applyBasicAnimation:(CABasicAnimation *)animation toLayer:(CALayer *)layer{
</span><span class='line'>  //set the from value (using presentation layer if available)  
</span><span class='line'>  animation.fromValue = [layer.presentationLayer ?: layer valueForKeyPath:animation.keyPath];
</span><span class='line'>
</span><span class='line'>  //update the property in advance
</span><span class='line'>  //note: this approach will only work if toValue != nil
</span><span class='line'>  [CATransaction begin];
</span><span class='line'>  [CATransaction setDisableActions:YES];
</span><span class='line'>  [layer setValue:animation.toValue forKeyPath:animation.keyPath];
</span><span class='line'>  [CATransaction commit];
</span><span class='line'>
</span><span class='line'>  //apply animation to layer
</span><span class='line'>  [layer addAnimation:animation forKey:nil];
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>CAKeyframeAnimation : CAPropertyAnimation : CAAnimation<br/>
values<br/>
path<br/>
rotationMode = kCAAnimationRotateAuto</p>

<p>CAAnimationGroup<br/>
animations<br/>
duration</p>

<p>Transitions<br/>
CATransition : CAAnimation<br/>
type<br/>
subtype</p>

<p>视图控制器切换时使用，效果更平滑；</p>

<h3>Cancel animations</h3>

<p><code>-removeAnimationForKey: </code></p>

<h2>Layer time</h2>

<h2>Tuning for speed</h2>

<p>合理分配绘图任务至CPU和GPU。</p>

<h3>The Stages of an Animation</h3>

<p>Layout：setup layers<br/>
Display：draw backing image，call -drawRect:<br/>
Prepare：prepare send animation data to render server<br/>
Commit：package up and send over IPC<br/>
render server form render tree:<br/>
  calculate intermediate values<br/>
  render to screen<br/>
只有最后一步通过GPU处理。<br/>
开发者只能控制前两步，layout和display。</p>

<p>影响GPU绘图效率的因素：<br/>
1、过多的layer；<br/>
2、过多的半透明layer；<br/>
3、离屏绘制，如圆角、遮罩、阴影、光栅化；<br/>
4、过大的图片。</p>

<p>影响CPU绘图效率的因素：<br/>
1、复杂的layout计算；<br/>
2、view的懒加载，从数据库获取数据，从nib中加载view，加载图片；<br/>
3、Core Graphics 绘图；<br/>
4、图片解压缩；</p>

<p>IO限制因素：<br/>
IO操作耗时严重；</p>

<p>通过测量发现实际的瓶颈点：<br/>
1、在真机上测试，使用release版本，在低性能机器上测试；<br/>
2、保持稳定的帧率；<br/>
3、instrument：</p>

<pre><code>Time Profiler：查看CPU时间开销；
    Separate by Thread：按线程将方法分组；
    Hide System Libraries：隐藏系统库；
    Show Obj-C Only：只显示OC方法调用；
Core Animation：查看Core Animation性能；
    Color Blended Layers：标记出混合的图层，从绿到红表示严重程度，最好没有；
    Color Hits Green and Misses Red：标记出重复缓存的图层；
    Color Copied Images：标记出backing image，最好没有；
    Color Immediately：随时反馈；
    Color Misaligned Images：标记非正确缩放的图片；
    Color Offscreen-Rendered Yellow：标记出需要离屏绘制的layer，通过栅格化优化；
    Color OpenGL Fast Path Blue：标记出OpenGL绘图；
    Flash Updated Regions：标记出重绘的layer，最好没有；
OpenGL ES Driver：查看GPU性能；
    Tiler Utilization
    Renderer Utilization
组合使用效果更佳。
</code></pre>

<p>优化方法：<br/>
cache offscreen render layer：</p>

<pre><code>layer.shouldRasterize = YES;
layer.rasterizationScale = [UIScreen mainScreen].scale;
</code></pre>

<h2>Efficient Drawing</h2>

<h3>Software Drawing</h3>

<p>速度慢并且需要大量内存空间。<br/>
少写drawRect方法。</p>

<h3>Vector Graphics</h3>

<p>多边形；<br/>
对角线和曲线；<br/>
文字；<br/>
渐变。<br/>
使用CAShapeLayer</p>

<h3>Dirty Rectangles</h3>

<p>需要重绘的区域<br/>
调用-setNeedsDisplayInRect:方法指定重绘区域。</p>

<h3>Asynchronous Drawing</h3>

<p>在子线程绘图，将结果直接作为layer的contents。<br/>
CATiledLayer。<br/>
drawsAsynchronously属性。</p>

<h2>Image IO</h2>

<pre><code>//  通过tag防止重复创建
UIImageView *imageView = (UIImageView *)[cell viewWithTag:imageTag];
if (!imageView){
  imageView = [UIImageView alloc] init];
  [cell.contentView addSubview:imageView];
}
</code></pre>

<h3>Loading and Latency</h3>

<p>button的响应时间要保持在0.2秒以下。</p>

<h3>Threaded Loading</h3>

<p>gcd</p>

<pre><code>//  标记cell
cell.tag = indexPath.row;
imageView.image = nil;
//  异步加载图片
dispatch_aysnc(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_LOW),0),^{
  //  加载图片
  NSInteger index = indexPath.row;
  NSString *imagePath = self.imagePaths[index];
  UIImageView *image = [UIImage imageWithContentsOfFile:imagePath];

  //  在主线程显示图片
  dispatch_async(dispatch_get_main_queue(),^{
    if (index == cell.tag){
      imageView.image = image;
    }
  });
});
</code></pre>

<h3>Deferred Decompression</h3>

<p>PNG图片大，但解压快；<br/>
JPEG图片小，但解压慢。<br/>
图片通常在需要绘制前才开始解压。<br/>
[UIImage imageWithName:imageName] 该方法载入图片后即开始解压。<br/>
layer的contents或UIImageView的image。<br/>
ImageIO.framework</p>

<pre><code>NSInteger index = indexPath.row;
NSURL *imageURL = [NSURL fileURLWithPath:self.imagePaths[index]];
NSDictionary *options = @{(__bridge id)kCGImageSourceShouldCache:@YES};
CGImageSourceRef source = CGImageSourceCreateWithURL((__bridge CFURLRef)imageURL,NULL);
CGImageRef imageRef = CGImageSourceCreateImageAtIndex(source,0,(__bridge CFDictionaryRef)options);
UIImage *image = [UIImage imageWithCGImage:imageRef];
CGImageRelease(imageRef);
CFRelease(source);
</code></pre>

<p>NSCache</p>

<h2>Layer Performance</h2>

<p class='post-footer'>
  原始地址：
  <a href='http://sxgfxm.github.io/blog/2017/02/20/ios-core-animation-advanced-techniques/'>http://sxgfxm.github.io/blog/2017/02/20/ios-core-animation-advanced-techniques/</a><br/>
  written by <a href='http://sxgfxm.github.io'>Light</a>
  &nbsp;posted at <a href='http://sxgfxm.github.io'>http://sxgfxm.github.io</a>
  </p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Export Music From Itunes to Local App's Sandbox on iPhone]]></title>
    <link href="http://sxgfxm.github.io/blog/2017/02/10/export-music-from-itunes-to-local-apps-sandbox-on-iphone/"/>
    <updated>2017-02-10T15:31:20+08:00</updated>
    <id>http://sxgfxm.github.io/blog/2017/02/10/export-music-from-itunes-to-local-apps-sandbox-on-iphone</id>
    <content type="html"><![CDATA[<h2>Introduction</h2>

<p>本文主要介绍app如何获取iTunes中音乐列表，并把iTunes中音乐文件导出至app的沙盒目录下。</p>

<!--more-->


<h2>import</h2>

<p>导入所需的头文件。</p>

<pre><code class="c">#import &lt;AVFoundation/AVAssetExportSession.h&gt;
#import &lt;MediaPlayer/MediaPlayer.h&gt;
</code></pre>

<h2>注册通知</h2>

<p>注册<strong>MPMediaLibraryDidChangeNotification</strong>通知，当iTunes音乐库文件发生变化时，做出响应。</p>

<pre><code class="c">[[NSNotificationCenter defaultCenter]
    addObserver:self
    selector:@selector(mediaLibraryDidChange:)
    name:MPMediaLibraryDidChangeNotification
    object:nil];
</code></pre>

<h2>开启通知</h2>

<p>开启<strong>MPMediaLibrary</strong>通知。</p>

<pre><code class="c">[[MPMediaLibrary defaultMediaLibrary] beginGeneratingLibraryChangeNotifications];
</code></pre>

<h2>关闭通知</h2>

<p>关闭<strong>MPMediaLibrary</strong>通知。</p>

<pre><code class="c">[[MPMediaLibrary defaultMediaLibrary] endGeneratingLibraryChangeNotifications];
</code></pre>

<h2>MPMediaQuery</h2>

<p>通过<strong>MPMediaQuery</strong>获取iTunes中音乐列表，可以自定义列表类型，调用<code>-collection</code>方法，返回对应列表的数组。数组中元素为<strong>MPMediaItemCollection</strong>类型。</p>

<pre><code class="c">//  create
MPMediaQuery *mediaQuery = [MPMediaQuery playlistQuery];
//  groupType
mediaQuery.groupingType = MPMediaGroupingAlbumArtist;
//  query
NSArray&lt;MPMediaItemCollection *&gt; *mediaCollections = [mediaQuery collections];
</code></pre>

<h2>MPMediaItem</h2>

<p>通过<strong>MPMediaItemCollection</strong>获取对应的<strong>MPMediaItem</strong>，对应多媒体文件。通过<strong>MPMediaItem</strong>获取文件相关信息。导出时需要文件地址<strong>assetURL</strong>。</p>

<pre><code class="c">NSMutableArray&lt;MPMediaItem *&gt; mediaItems = [NSMutableArray array];
for (MPMediaItemCollection *collection in mediaCollections) {
  //  mediaItem
  MPMediaItem *mediaItem = [collection representativeItem];
  //  歌曲名称
  NSString *title = [mediaItem valueForProperty:MPMediaItemPropertyTitle];
  //  演唱者
  NSString *artist = [mediaItem valueForProperty:MPMediaItemPropertyArtist];
  //  歌曲封面
  MPMediaItemArtwork *artwork = [mediaItem valueForProperty:MPMediaItemPropertyArtwork];
  //  歌曲格式
  NSString *form = self.assetURL.pathExtension;
  //  歌曲地址，本地iTunes中地址，可用于导出歌曲
  NSURL *assetURL = [mediaItem valueForProperty:MPMediaItemPropertyAssetURL];
  //  add
  [mediaItems addObject:mediaItem];
}
</code></pre>

<h2>Play</h2>

<p>获取到<strong>MPMediaItemCollection</strong>后，可以选择使用iTunes直接播放该文件。</p>

<pre><code class="c">MPMediaItemCollection *mediaItemCollection = [mediaCollections firstObject];
MPMediaItem *selectedItem = [collection representativeItem];
[[MPMusicPlayerController iPodMusicPlayer] setQueueWithItemCollection:mediaItemCollection];
[[MPMusicPlayerController iPodMusicPlayer] setNowPlayingItem:selectedItem];
[[MPMusicPlayerController iPodMusicPlayer] play];
</code></pre>

<h2>Export Music to Local Sandbox</h2>

<p>导出音乐文件至本地沙盒目录下：</p>

<p>1、获取音乐文件名（title）及input地址（<strong>assetURL</strong>）；</p>

<p>2、获取沙盒目录，并创建output地址（<strong>outputURL</strong>）；</p>

<p>3、获取<strong>AVURLAsset</strong>；</p>

<p>4、使用<strong>AVAssetExportSession</strong>导出AVURLAsset。</p>

<pre><code class="c">for (MPMediaItem *musicItem in musicItems) {
    //  获取文件名及地址
    NSString *title = [mediaItem valueForProperty:MPMediaItemPropertyTitle];
    NSURL *assetURL = [mediaItem valueForProperty:MPMediaItemPropertyAssetURL];
    if (assetURL &amp;&amp; [self validIpodLibraryURL:assetURL]) {
      //  创建 output URL，存入沙盒目录下，以文件名为标识
      NSString *pathExtension = assetURL.pathExtension;
      NSArray *paths = NSSearchPathForDirectoriesInDomains(
          NSDocumentDirectory, NSUserDomainMask, YES);
      NSString *documentsDirectory = [paths firstObject];
      NSURL *outputURL =
          [[NSURL fileURLWithPath:[documentsDirectory
                                      stringByAppendingPathComponent:title]]
              URLByAppendingPathExtension:pathExtension];
      //  保证无重复路径
      [[NSFileManager defaultManager] removeItemAtURL:outputURL error:nil];
      //  获取Asset
      NSDictionary *options = [[NSDictionary alloc] init];
      AVURLAsset *asset = [AVURLAsset URLAssetWithURL:assetURL options:options];
      if (asset) {
        //  创建export session
        AVAssetExportSession *exportSession = [[AVAssetExportSession alloc]
            initWithAsset:asset
               presetName:AVAssetExportPresetPassthrough];
        if (exportSession) {
            //  导出类型
            if ([pathExtension compare:@"m4a"] == NSOrderedSame) {
              exportSession.outputFileType = AVFileTypeAppleM4A;
            } else if ([pathExtension compare:@"wav"] == NSOrderedSame) {
              exportSession.outputFileType = AVFileTypeWAVE;
            } else if ([pathExtension compare:@"aif"] == NSOrderedSame) {
              exportSession.outputFileType = AVFileTypeAIFF;
            } else if ([pathExtension compare:@"m4v"] == NSOrderedSame) {
              exportSession.outputFileType = AVFileTypeAppleM4V;
            }
            //  导出地址
            exportSession.outputURL = outputURL;
            //  导出
            [exportSession exportAsynchronouslyWithCompletionHandler:^{
              //  状态回调
              if (completion) {
                switch (exportSession.status) {
                case AVAssetExportSessionStatusFailed:
                  NSLog(@"Failed");
                  break;
                case AVAssetExportSessionStatusCancelled:
                  NSLog(@"Cancelled");
                  break;
                case AVAssetExportSessionStatusCompleted:
                  NSLog(@"Completed");
                  break;
                default:
                  break;
                }
              }
            }];
        }
      }
    }
  }
</code></pre>

<pre><code class="c">- (BOOL)validIpodLibraryURL:(NSURL *)url {
  NSString *IPOD_SCHEME = @"ipod-library";
  if (nil == url)
    return NO;
  if (nil == url.scheme)
    return NO;
  if ([url.scheme compare:IPOD_SCHEME] != NSOrderedSame)
    return NO;
  if ([url.pathExtension compare:@"aif"] != NSOrderedSame &amp;&amp;
      [url.pathExtension compare:@"m4a"] != NSOrderedSame &amp;&amp;
      [url.pathExtension compare:@"wav"] != NSOrderedSame &amp;&amp;
      [url.pathExtension compare:@"m4v"] != NSOrderedSame) {
    return NO;
  }
  return YES;
}
</code></pre>

<p class='post-footer'>
  原始地址：
  <a href='http://sxgfxm.github.io/blog/2017/02/10/export-music-from-itunes-to-local-apps-sandbox-on-iphone/'>http://sxgfxm.github.io/blog/2017/02/10/export-music-from-itunes-to-local-apps-sandbox-on-iphone/</a><br/>
  written by <a href='http://sxgfxm.github.io'>Light</a>
  &nbsp;posted at <a href='http://sxgfxm.github.io'>http://sxgfxm.github.io</a>
  </p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Core Data Tutorial iOS 10]]></title>
    <link href="http://sxgfxm.github.io/blog/2017/01/23/core-data-tutorial-ios-10/"/>
    <updated>2017-01-23T16:40:01+08:00</updated>
    <id>http://sxgfxm.github.io/blog/2017/01/23/core-data-tutorial-ios-10</id>
    <content type="html"><![CDATA[<p>iOS 10 CoreData使用总结。</p>

<!--more-->


<h2>Include Core Data</h2>

<p>创建工程时选择包含CoreData，系统会自动生成相关文件。</p>

<h2>Add Entity</h2>

<p>在xcdatamodeld文件中，添加Entity。<br/>
Entity相当于表，其中Attributes相当于表中的记录，对应需要存储的数据。</p>

<h2>Create NSManagedObject Subclass</h2>

<p>创建Entity对应的model。<br/>
在Xcode8中，创建方式为Editor ———— Create NSManagedObject Subclass。<br/>
注意，创建之前需要将数据库的Codegen设置为Manual/None，否则会报duplicate错误。</p>

<h2>Get NSPersistentContainer Object</h2>

<p>iOS 10 对Core Data做了很大的优化和改进，大大简化了Core Data的使用。<br/>
NSPersistentContainer是新添加的类，从此大部分情况下无需再和NSManagedObjectContext、NSPersistentStoreCoordinator打交道。<br/>
获取NSPersistentContainer</p>

<pre><code class="objective-c">#import 'AppDelegate.h'

@interface ViewController ()

@property(nonatomic, strong) NSPersistentContainer *container;

@end

@implementation ViewController

-(void)viewDidLoad{
  [super viewDidLoad];
  self.container = ((AppDelegate *)[UIApplication sharedApplication].delegate).persistentContainer;
}

@end
</code></pre>

<h2>Add Record</h2>

<p>导入通过系统创建的Create NSManagedObject Subclass，通过NSEntityDescription增添记录。</p>

<pre><code class="objective-c">#import "People+CoreDataProperties.h"

#define kEntityName @"People"

-(void)addRecord{
  People *people = [NSEntityDescription insertNewObjectForEntityForName:kEntityName inManagedObjectContext:self.container.viewContext];
  people.name = @"Tom";
  people.sex = YES;
  people.age = 23;
}
</code></pre>

<h2>Fetch Record</h2>

<p>通过NSFetchRequest查询记录。</p>

<pre><code class="objective-c">-(void)fetchRecord{
  NSFetchRequest *fetchRequest = [NSFetchRequest fetchRequestWithEntityName:kEntityName];
  NSArray&lt;People *&gt; *results = [self.container.viewContext executeFetchRequest:fetchRequest error:nil];
  for (People *people in results) {
    NSLog(@"name %@", people.name);
    NSLog(@"sex  %@", people.sex);
    NSLog(@"age  %@", people.age);
  }
}
</code></pre>

<h2>Update Record</h2>

<p>先fetch需要修改的记录，然后直接修改即可。</p>

<pre><code class="objective-c">-(void)updateRecord{
  NSFetchRequest *fetchRequest = [NSFetchRequest fetchRequestWithEntityName:kEntityName];
  NSPredicate *predicate = [NSPredicate predicateWithFormat:@"name == %@", @"Tom"];
  fetchRequest.predicate = predicate;
  NSArray&lt;People *&gt; *results = [self.container.viewContext executeFetchRequest:fetchRequest error:nil];
  for (People *people in results) {
    people.name = @"Lily";
  }
}
</code></pre>

<h2>Delete Record</h2>

<p>先fetch需要删除的记录，然后通过NSManagedObjectContext删除即可。</p>

<pre><code class="objective-c">-(void)deleteRecord{
  NSFetchRequest *fetchRequest = [NSFetchRequest fetchRequestWithEntityName:kEntityName];
  NSPredicate *predicate = [NSPredicate predicateWithFormat:@"name == %@", @"Lily"];
  fetchRequest.predicate = predicate;
  NSArray&lt;People *&gt; *results = [self.container.viewContext executeFetchRequest:fetchRequest error:nil];
  for (People *people in results) {
    [self.container.viewContext deleteObject:people];
  }
}
</code></pre>

<h2>GitHub源码</h2>

<p><a href="https://github.com/sxgfxm/CoreDataDemo">CoreDataDemo</a></p>

<p class='post-footer'>
  原始地址：
  <a href='http://sxgfxm.github.io/blog/2017/01/23/core-data-tutorial-ios-10/'>http://sxgfxm.github.io/blog/2017/01/23/core-data-tutorial-ios-10/</a><br/>
  written by <a href='http://sxgfxm.github.io'>Light</a>
  &nbsp;posted at <a href='http://sxgfxm.github.io'>http://sxgfxm.github.io</a>
  </p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Prevent Duplicate Clicks]]></title>
    <link href="http://sxgfxm.github.io/blog/2017/01/17/prevent-duplicate-clicks/"/>
    <updated>2017-01-17T16:19:36+08:00</updated>
    <id>http://sxgfxm.github.io/blog/2017/01/17/prevent-duplicate-clicks</id>
    <content type="html"><![CDATA[<p>在应用开发过程中，点击事件为耗时操作或者延时响应，例如请求服务器数据，push至下一个界面，如果不处理用户重复点击事件，将会重复触发事件。下面介绍几种简单的处理方法。</p>

<!--more-->


<h2>Button</h2>

<p>点击后button状态置为disabled；
操作完成后button状态置为enabled；</p>

<h2>View</h2>

<p>根据处理状态设置userInteractiveEnable。</p>

<h2>Push</h2>

<p>方法一：
    点击后button状态置为disabled；
    viewDidDisappear置为enabled；</p>

<p>方法二：在push前添加判断：如果和上一个视图控制器一样，隔绝此次操作。</p>

<pre><code class="objective-c">if ([self.navigationController.topViewController isKindOfClass:[MyViewController class]]) {
    return;
}
</code></pre>

<h2>时间监听类</h2>

<p>用一个静态变量记录上一次点击的时间，每次点击check时间间隔是否达到要求。</p>

<h2>Runtime</h2>

<p>使用Runtime监听点击事件，忽略重复点击。
添加一个eventTimeInterval属性，使其规定时间内只能响应一次点击事件。</p>

<p>参考<a href="http://www.cnblogs.com/wanxudong/p/5984941.html">iOS防止重复点击button</a></p>

<p>.h</p>

<pre><code>#import &lt;UIKit/UIKit.h&gt;

@interface UIButton (WXD)

/**
*  为按钮添加点击间隔 eventTimeInterval秒
*/
@property (nonatomic, assign) NSTimeInterval eventTimeInterval;

@end
</code></pre>

<p>.m</p>

<pre><code class="objective-c">#import "UIButton+WXD.h"
#import &lt;objc/runtime.h&gt;
#define defaultInterval 1  //默认时间间隔

@interface UIButton ()

/**
*  bool YES 忽略点击事件   NO 允许点击事件
*/
@property (nonatomic, assign) BOOL isIgnoreEvent;

@end

@implementation UIButton (WXD)

static const char *UIControl_eventTimeInterval = "UIControl_eventTimeInterval";
static const char *UIControl_enventIsIgnoreEvent = "UIControl_enventIsIgnoreEvent";


// runtime 动态绑定 属性
- (void)setIsIgnoreEvent:(BOOL)isIgnoreEvent
{
    objc_setAssociatedObject(self, UIControl_enventIsIgnoreEvent, @(isIgnoreEvent), OBJC_ASSOCIATION_RETAIN_NONATOMIC);
}
- (BOOL)isIgnoreEvent{
    return [objc_getAssociatedObject(self, UIControl_enventIsIgnoreEvent) boolValue];
}

- (NSTimeInterval)eventTimeInterval
{
  return [objc_getAssociatedObject(self, UIControl_eventTimeInterval) doubleValue];
}

- (void)setEventTimeInterval:(NSTimeInterval)eventTimeInterval
{
 objc_setAssociatedObject(self, UIControl_eventTimeInterval, @(eventTimeInterval), OBJC_ASSOCIATION_RETAIN_NONATOMIC);
}

+ (void)load
{
  // Method Swizzling
 static dispatch_once_t onceToken;
 dispatch_once(&amp;onceToken, ^{
       SEL selA = @selector(sendAction:to:forEvent:);
       SEL selB = @selector(_wxd_sendAction:to:forEvent:);
       Method methodA = class_getInstanceMethod(self,selA);
       Method methodB = class_getInstanceMethod(self, selB);

       BOOL isAdd = class_addMethod(self, selA, method_getImplementation(methodB), method_getTypeEncoding(methodB));

       if (isAdd) {
           class_replaceMethod(self, selB, method_getImplementation(methodA), method_getTypeEncoding(methodA));
       }else{
           //添加失败了 说明本类中有methodB的实现，此时只需要将methodA和methodB的IMP互换一下即可。
          method_exchangeImplementations(methodA, methodB);
      }
 });
}

- (void)_wxd_sendAction:(SEL)action to:(id)target forEvent:(UIEvent *)event
{
  self.eventTimeInterval = self.eventTimeInterval == 0 ? defaultInterval : self.eventTimeInterval;
  if (self.isIgnoreEvent){
      return;
  }else if (self.eventTimeInterval &gt; 0){
      dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(self.eventTimeInterval * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{
       [self setIsIgnoreEvent:NO];
       });
  }

  self.isIgnoreEvent = YES;
  // 这里看上去会陷入递归调用死循环，但在运行期此方法是和sendAction:to:forEvent:互换的，相当于执行sendAction:to:forEvent:方法，所以并不会陷入死循环。
  [self _wxd_sendAction:action to:target forEvent:event];
}  
</code></pre>

<p class='post-footer'>
  原始地址：
  <a href='http://sxgfxm.github.io/blog/2017/01/17/prevent-duplicate-clicks/'>http://sxgfxm.github.io/blog/2017/01/17/prevent-duplicate-clicks/</a><br/>
  written by <a href='http://sxgfxm.github.io'>Light</a>
  &nbsp;posted at <a href='http://sxgfxm.github.io'>http://sxgfxm.github.io</a>
  </p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Smooth Gradient Polyline]]></title>
    <link href="http://sxgfxm.github.io/blog/2016/10/27/smooth-gradient-polyline/"/>
    <updated>2016-10-27T15:47:23+08:00</updated>
    <id>http://sxgfxm.github.io/blog/2016/10/27/smooth-gradient-polyline</id>
    <content type="html"><![CDATA[<h2>Introduction</h2>

<p>近年来，人们越来越注重运动锻炼，运动相关App层出不穷。其中运动路径追踪是一个重要的功能点。可以很容易的使用<strong>MKPolyline</strong>实现单色路径追踪。更进一步，如果想通过路径的不同颜色反映出运动过程中的速度变化，如<strong>Nike+</strong>类似的效果，需要更多的工作。本文主要讨论如何绘制<strong>平滑渐变</strong>的运动路径。</p>

<!-- more -->


<p><img src="http://ofj92itlz.bkt.clouddn.com/GradientPolyline:nike+.jpeg" alt="" /></p>

<p><img src="http://ofj92itlz.bkt.clouddn.com/GradientPolyline:ditongfilter.jpeg" alt="" /></p>

<p>上图为优化后的渐变色路径，图下方红色曲线为运动过程的速度曲线。</p>

<h2>主要流程</h2>

<ol>
<li>获取运动过程中GPS信息及对应的速度值；</li>
<li>使用<strong>低通滤波</strong>处理速度数据；</li>
<li>通过<strong>MKMapView</strong>转换坐标至对应大小的UIView；</li>
<li>使用<strong>CAGradientLayer</strong>及<strong>CAShaperLayer</strong>分段绘制渐变路径；</li>
</ol>


<h2>获取运动过程中GPS信息及对应的速度值</h2>

<p>可以使用<strong>CoreLocation</strong>获取GPS信息并计算对应的速度值。关于GPS坐标在中国大陆偏移及GPS坐标是否在中国大陆的判断方法，请参考<a href="https://sxgfxm.github.io/blog/2016/10/19/iospan-duan-gpszuo-biao-shi-fou-zai-zhong-guo/">另一篇博文</a>。本文着重探讨路径的绘制，所以模拟产生随机的GPS和速度数据。</p>

<h2>使用<strong>低通滤波</strong>处理速度数据</h2>

<p>因为所绘路径的颜色不同，所以只能分段绘制。</p>

<p>如果各分段为纯色，则绘制出的路径略显生硬，无法体现出过渡效果（如下图）。</p>

<p><img src="http://ofj92itlz.bkt.clouddn.com/GradientPolyline:pure.jpeg" alt="" /></p>

<p>如果根据速度直接绘制成渐变色，因为速度波动的原因，渐变效果并不理想（如下图）。</p>

<p><img src="http://ofj92itlz.bkt.clouddn.com/GradientPolyline:Gradient.jpeg" alt="" /></p>

<p>所以需要预先处理速度数据，使速度数据变得平滑，渐变的效果才好。本人分别使用了<strong>滑动窗口滤波</strong>和<strong>低通滤波</strong>，对比之下，<strong>低通滤波</strong>表现更好。</p>

<p><img src="http://ofj92itlz.bkt.clouddn.com/GradientPolyline:origin.jpeg" alt="" /></p>

<p>上图为原数据效果。</p>

<p><img src="http://ofj92itlz.bkt.clouddn.com/GradientPolyline:smoothwindow.jpeg" alt="" /></p>

<p>上图为滑动窗口平滑效果。</p>

<p><img src="http://ofj92itlz.bkt.clouddn.com/GradientPolyline:ditongfilter.jpeg" alt="" /></p>

<p>上图为低通滤波平滑效果，滤波参数可以根据需要调整。</p>

<h2>通过<strong>MKMapView</strong>转换坐标至对应大小的UIView</h2>

<p>首先需要说明的是，本文的方法将路径绘制在与MKMapView大小一致的UIView上，而非直接以MKOverlay的形式绘制在MKMapView上，所以只能看到路径大致的轮廓而不能像地图一样缩放。如果想要在地图上直接绘制渐变路径，需要自定义<strong>MKOverlayPathRenderer</strong>，如有需要我再放出来。</p>

<p>坐标转换方法，调用MKMapView的<code>convertCoordinate:toPointToView:</code>方法，即可把地图上的GPS坐标，转换为与地图大小相同的CGPoint，为绘制路径做准备。</p>

<h2>使用<strong>CAGradientLayer</strong>及<strong>CAShaperLayer</strong>分段绘制渐变路径</h2>

<h3>在<strong>CAGradientLayer</strong>上绘制对应的渐变颜色；</h3>

<p>1、渐变方向需要根据路径方向计算；</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='objective-c'><span class='line'><span class="n">gradientLayer</span><span class="p">.</span><span class="n">startPoint</span> <span class="o">=</span>
</span><span class='line'>        <span class="n">CGPointMake</span><span class="p">(</span><span class="n">lastPoint</span><span class="p">.</span><span class="n">x</span> <span class="o">/</span> <span class="n">gradientView</span><span class="p">.</span><span class="n">frame</span><span class="p">.</span><span class="n">size</span><span class="p">.</span><span class="n">width</span><span class="p">,</span>
</span><span class='line'>                    <span class="n">lastPoint</span><span class="p">.</span><span class="n">y</span> <span class="o">/</span> <span class="n">gradientView</span><span class="p">.</span><span class="n">frame</span><span class="p">.</span><span class="n">size</span><span class="p">.</span><span class="n">height</span><span class="p">);</span>
</span><span class='line'><span class="n">gradientLayer</span><span class="p">.</span><span class="n">endPoint</span> <span class="o">=</span>
</span><span class='line'>        <span class="n">CGPointMake</span><span class="p">(</span><span class="n">newPoint</span><span class="p">.</span><span class="n">x</span> <span class="o">/</span> <span class="n">gradientView</span><span class="p">.</span><span class="n">frame</span><span class="p">.</span><span class="n">size</span><span class="p">.</span><span class="n">width</span><span class="p">,</span>
</span><span class='line'>                    <span class="n">newPoint</span><span class="p">.</span><span class="n">y</span> <span class="o">/</span> <span class="n">gradientView</span><span class="p">.</span><span class="n">frame</span><span class="p">.</span><span class="n">size</span><span class="p">.</span><span class="n">height</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>2、渐变颜色为路径两端速度值映射后的颜色，推荐使用HSB颜色值映射；</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='objective-c'><span class='line'><span class="n">CGFloat</span> <span class="n">hue</span> <span class="o">=</span> <span class="n">points</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">speed</span> <span class="o">/</span> <span class="nb">self</span><span class="p">.</span><span class="n">maxSpeed</span> <span class="o">*</span> <span class="nb">self</span><span class="p">.</span><span class="n">maxHue</span><span class="p">;</span>
</span><span class='line'><span class="bp">UIColor</span> <span class="o">*</span><span class="n">newColor</span> <span class="o">=</span>
</span><span class='line'>        <span class="p">[</span><span class="bp">UIColor</span> <span class="nl">colorWithHue</span><span class="p">:</span><span class="n">hue</span> <span class="nl">saturation</span><span class="p">:</span><span class="mi">1</span> <span class="nl">brightness</span><span class="p">:</span><span class="mi">1</span> <span class="nl">alpha</span><span class="p">:</span><span class="mi">1</span><span class="p">];</span>
</span><span class='line'><span class="n">gradientLayer</span><span class="p">.</span><span class="n">colors</span> <span class="o">=</span>
</span><span class='line'>        <span class="l">@[</span> <span class="p">(</span><span class="k">__bridge</span> <span class="kt">id</span><span class="p">)(</span><span class="n">lastColor</span><span class="p">.</span><span class="bp">CGColor</span><span class="p">),</span> <span class="p">(</span><span class="k">__bridge</span> <span class="kt">id</span><span class="p">)(</span><span class="n">newColor</span><span class="p">.</span><span class="bp">CGColor</span><span class="p">)</span> <span class="l">]</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>3、渐变起止可按需要自行控制；</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objective-c'><span class='line'><span class="n">gradientLayer</span><span class="p">.</span><span class="n">locations</span> <span class="o">=</span> <span class="l">@[</span> <span class="l">@(</span><span class="mf">0.2</span><span class="l">)</span><span class="p">,</span> <span class="l">@(</span><span class="mf">0.8</span><span class="l">)</span> <span class="l">]</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<h3>在<strong>CAShapeLayer</strong>上绘制对应的路径；</h3>

<p>1、路径的起止坐标为转换后的CGPoint；</p>

<p>2、注意设置<code>shapeLayer.lineCap = kCALineCapRound;</code>，否则路径会断；</p>

<p>3、注意<code>shapeLayer.strokeColor</code>不能为透明色，否则无法mask；</p>

<h3>设置<code>gradientLayer.mask = shapeLayer</code>；</h3>

<h2>总结</h2>

<p>绘制平滑渐变路径的关键在于速度数据的处理，大家可以尝试不同的滤波算法改进绘制效果。绘制路径的技巧也在文中列出，如有问题可以和我交流，大家共同探讨学习。</p>

<h2>Github源码</h2>

<p><a href="https://github.com/sxgfxm/SmoothGradientPolyline">SmoothGradientPolyline</a></p>

<p class='post-footer'>
  原始地址：
  <a href='http://sxgfxm.github.io/blog/2016/10/27/smooth-gradient-polyline/'>http://sxgfxm.github.io/blog/2016/10/27/smooth-gradient-polyline/</a><br/>
  written by <a href='http://sxgfxm.github.io'>Light</a>
  &nbsp;posted at <a href='http://sxgfxm.github.io'>http://sxgfxm.github.io</a>
  </p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[XGChart_README]]></title>
    <link href="http://sxgfxm.github.io/blog/2016/10/25/xgchart-readme/"/>
    <updated>2016-10-25T19:52:46+08:00</updated>
    <id>http://sxgfxm.github.io/blog/2016/10/25/xgchart-readme</id>
    <content type="html"><![CDATA[<h2>Introduction</h2>

<p><a href="https://github.com/sxgfxm/XGChart">XGChart</a>是一个简洁的iOS 图表库，可以快速集成自定义折线图，曲线图和条形图。</p>

<!-- more -->


<h2>Install</h2>

<p>首先，下载<strong>XGChart</strong>，将<strong>XGChart</strong>文件夹拖入工程。</p>

<p><img src="http://ofj92itlz.bkt.clouddn.com/XGChart:import2.jpeg" alt="import" /></p>

<p>然后，导入<strong>XGChart.h</strong>头文件，配置参数，创建即可。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objective-c'><span class='line'><span class="cp">#import &quot;XGChart.h&quot;</span>
</span></code></pre></td></tr></table></div></figure>




<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
</pre></td><td class='code'><pre><code class='objective-c'><span class='line'> <span class="c1">//  configuration</span>
</span><span class='line'>  <span class="n">XGChartConfiguration</span> <span class="o">*</span><span class="n">configuration</span> <span class="o">=</span> <span class="p">[[</span><span class="n">XGChartConfiguration</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];</span>
</span><span class='line'>  <span class="n">configuration</span><span class="p">.</span><span class="n">chartType</span> <span class="o">=</span> <span class="n">XGChartTypeLineChart</span><span class="p">;</span>
</span><span class='line'>  <span class="n">configuration</span><span class="p">.</span><span class="n">paddingTop</span> <span class="o">=</span> <span class="mi">20</span><span class="p">;</span>
</span><span class='line'>  <span class="n">configuration</span><span class="p">.</span><span class="n">paddingLeft</span> <span class="o">=</span> <span class="mi">20</span><span class="p">;</span>
</span><span class='line'>  <span class="n">configuration</span><span class="p">.</span><span class="n">paddingBottom</span> <span class="o">=</span> <span class="mi">20</span><span class="p">;</span>
</span><span class='line'>  <span class="n">configuration</span><span class="p">.</span><span class="n">paddingRight</span> <span class="o">=</span> <span class="mi">20</span><span class="p">;</span>
</span><span class='line'>  <span class="n">configuration</span><span class="p">.</span><span class="n">xGridCount</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
</span><span class='line'>  <span class="n">configuration</span><span class="p">.</span><span class="n">yGridCount</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
</span><span class='line'>  <span class="n">configuration</span><span class="p">.</span><span class="n">gridColor</span> <span class="o">=</span> <span class="p">[</span><span class="bp">UIColor</span> <span class="n">grayColor</span><span class="p">];</span>
</span><span class='line'>  <span class="n">configuration</span><span class="p">.</span><span class="n">xAxisLabelColor</span> <span class="o">=</span> <span class="p">[</span><span class="bp">UIColor</span> <span class="n">whiteColor</span><span class="p">];</span>
</span><span class='line'>  <span class="n">configuration</span><span class="p">.</span><span class="n">xAxisLabelFontSize</span> <span class="o">=</span> <span class="mi">12</span><span class="p">;</span>
</span><span class='line'>  <span class="n">configuration</span><span class="p">.</span><span class="n">yAxisLabelColor</span> <span class="o">=</span> <span class="p">[</span><span class="bp">UIColor</span> <span class="n">whiteColor</span><span class="p">];</span>
</span><span class='line'>  <span class="n">configuration</span><span class="p">.</span><span class="n">yAxisLabelFontSize</span> <span class="o">=</span> <span class="mi">12</span><span class="p">;</span>
</span><span class='line'>  <span class="bp">NSMutableArray</span><span class="o">&lt;</span><span class="n">XGChartPoint</span> <span class="o">*&gt;</span> <span class="o">*</span><span class="n">chartPoints</span> <span class="o">=</span> <span class="p">[[</span><span class="bp">NSMutableArray</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];</span>
</span><span class='line'>  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">31</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">XGChartPoint</span> <span class="o">*</span><span class="n">point</span> <span class="o">=</span>
</span><span class='line'>        <span class="p">[[</span><span class="n">XGChartPoint</span> <span class="n">alloc</span><span class="p">]</span> <span class="nl">initWithX</span><span class="p">:</span><span class="n">i</span> <span class="nl">andY</span><span class="p">:</span><span class="n">arc4random_uniform</span><span class="p">(</span><span class="mi">100</span><span class="p">)];</span>
</span><span class='line'>    <span class="p">[</span><span class="n">chartPoints</span> <span class="nl">addObject</span><span class="p">:</span><span class="n">point</span><span class="p">];</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>  <span class="n">configuration</span><span class="p">.</span><span class="n">chartPoints</span> <span class="o">=</span> <span class="n">chartPoints</span><span class="p">;</span>
</span><span class='line'>  <span class="n">configuration</span><span class="p">.</span><span class="n">strokeColor</span> <span class="o">=</span> <span class="p">[</span><span class="bp">UIColor</span> <span class="n">redColor</span><span class="p">];</span>
</span><span class='line'>  <span class="n">configuration</span><span class="p">.</span><span class="n">fillColor</span> <span class="o">=</span> <span class="p">[</span><span class="bp">UIColor</span> <span class="n">redColor</span><span class="p">];</span>
</span><span class='line'>  <span class="n">configuration</span><span class="p">.</span><span class="n">lineWidth</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
</span><span class='line'>  <span class="c1">//  line chart</span>
</span><span class='line'>  <span class="n">XGChart</span> <span class="o">*</span><span class="n">lineChart</span> <span class="o">=</span> <span class="p">[[</span><span class="n">XGChart</span> <span class="n">alloc</span><span class="p">]</span>
</span><span class='line'>      <span class="nl">initWithFrame</span><span class="p">:</span><span class="n">CGRectMake</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">64</span><span class="p">,</span> <span class="nb">self</span><span class="p">.</span><span class="n">view</span><span class="p">.</span><span class="n">bounds</span><span class="p">.</span><span class="n">size</span><span class="p">.</span><span class="n">width</span><span class="p">,</span>
</span><span class='line'>                               <span class="p">(</span><span class="nb">self</span><span class="p">.</span><span class="n">view</span><span class="p">.</span><span class="n">bounds</span><span class="p">.</span><span class="n">size</span><span class="p">.</span><span class="n">height</span> <span class="o">-</span> <span class="mi">64</span><span class="p">)</span> <span class="o">/</span> <span class="mi">3</span><span class="p">)</span>
</span><span class='line'>      <span class="nl">configuration</span><span class="p">:</span><span class="n">configuration</span><span class="p">];</span>
</span><span class='line'>  <span class="n">lineChart</span><span class="p">.</span><span class="n">backgroundColor</span> <span class="o">=</span> <span class="p">[</span><span class="bp">UIColor</span> <span class="n">blackColor</span><span class="p">];</span>
</span><span class='line'>  <span class="p">[</span><span class="nb">self</span><span class="p">.</span><span class="n">view</span> <span class="nl">addSubview</span><span class="p">:</span><span class="n">lineChart</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure>


<h2>Result</h2>

<p><img src="http://ofj92itlz.bkt.clouddn.com/XGChart:result2.png" alt="" /></p>

<p class='post-footer'>
  原始地址：
  <a href='http://sxgfxm.github.io/blog/2016/10/25/xgchart-readme/'>http://sxgfxm.github.io/blog/2016/10/25/xgchart-readme/</a><br/>
  written by <a href='http://sxgfxm.github.io'>Light</a>
  &nbsp;posted at <a href='http://sxgfxm.github.io'>http://sxgfxm.github.io</a>
  </p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ShareSDK接入]]></title>
    <link href="http://sxgfxm.github.io/blog/2016/10/21/sharesdkjie-ru/"/>
    <updated>2016-10-21T14:12:36+08:00</updated>
    <id>http://sxgfxm.github.io/blog/2016/10/21/sharesdkjie-ru</id>
    <content type="html"><![CDATA[<h2>iOS接入ShareSDK实现第三方分享</h2>

<p>因为<strong>友盟</strong>被阿里收购在Android平台的各种令人不悦的后台操作，改用<strong>ShareSDK</strong>实现第三方分享。以下为简单接入流程。详情可参考官方文档<a href="http://wiki.mob.com/ios%E7%AE%80%E6%B4%81%E7%89%88%E5%BF%AB%E9%80%9F%E9%9B%86%E6%88%90/">http://wiki.mob.com/ios%E7%AE%80%E6%B4%81%E7%89%88%E5%BF%AB%E9%80%9F%E9%9B%86%E6%88%90/</a></p>

<!--more-->


<h2>获取AppKey</h2>

<p>在官网注册，并按要求创建应用，获取AppKey，比如为<strong>182947e7afac0</strong>。</p>

<h2>下载所需版本的ShareSDK</h2>

<p>解压后，将<strong>ShareSDK</strong>导入工程中，记得勾选<strong>Copy items into destination group&rsquo;s folder(if needed)</strong>。</p>

<h2>添加依赖库</h2>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>//   ShareSDK
</span><span class='line'>libicucore.dylib
</span><span class='line'>libz.dylib
</span><span class='line'>libstdc++.dylib
</span><span class='line'>JavaScriptCore.framework
</span><span class='line'>
</span><span class='line'>//    新浪微博SDK
</span><span class='line'>ImageIO.framework
</span><span class='line'>libsqlite3.dylib
</span><span class='line'>
</span><span class='line'>//    QQ空间SDK
</span><span class='line'>libsqlite3.dylib
</span><span class='line'>
</span><span class='line'>//    微信SDK
</span><span class='line'>libsqlite3.dylib
</span><span class='line'>
</span><span class='line'>//    根据需要添加</span></code></pre></td></tr></table></div></figure>


<h2>初始化对应的第三方平台</h2>

<p>在<strong>AppDelegate.m</strong>中，导入所需头文件。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='objective-c'><span class='line'><span class="cp">#import &lt;ShareSDK/ShareSDK.h&gt;</span>
</span><span class='line'><span class="cp">#import &lt;ShareSDKConnector/ShareSDKConnector.h&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="c1">//腾讯开放平台（对应QQ和QQ空间）SDK头文件</span>
</span><span class='line'><span class="cp">#import &lt;TencentOpenAPI/TencentOAuth.h&gt;</span>
</span><span class='line'><span class="cp">#import &lt;TencentOpenAPI/QQApiInterface.h&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="c1">//微信SDK头文件</span>
</span><span class='line'><span class="cp">#import &quot;WXApi.h&quot;</span>
</span><span class='line'>
</span><span class='line'><span class="c1">//新浪微博SDK头文件</span>
</span><span class='line'><span class="cp">#import &quot;WeiboSDK.h&quot;</span>
</span><span class='line'><span class="c1">//新浪微博SDK需要在项目Build Settings中的Other Linker Flags添加&quot;-ObjC&quot;</span>
</span></code></pre></td></tr></table></div></figure>


<p>在<code>application:didFinishLaunchingWithOptions:</code>方法中初始化。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
</pre></td><td class='code'><pre><code class='objective-c'><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">BOOL</span><span class="p">)</span><span class="nf">application:</span><span class="p">(</span><span class="bp">UIApplication</span> <span class="o">*</span><span class="p">)</span><span class="nv">application</span>
</span><span class='line'>    <span class="nf">didFinishLaunchingWithOptions:</span><span class="p">(</span><span class="bp">NSDictionary</span> <span class="o">*</span><span class="p">)</span><span class="nv">launchOptions</span> <span class="p">{</span>
</span><span class='line'>
</span><span class='line'>  <span class="cm">/**</span>
</span><span class='line'><span class="cm">   *  设置ShareSDK的appKey，如果尚未在ShareSDK官网注册过App，请移步到http://mob.com/login</span>
</span><span class='line'><span class="cm">   * 登录后台进行应用注册</span>
</span><span class='line'><span class="cm">   *  在将生成的AppKey传入到此方法中。</span>
</span><span class='line'><span class="cm">   *  方法中的第二个第三个参数为需要连接社交平台SDK时触发，</span>
</span><span class='line'><span class="cm">   *  在此事件中写入连接代码。第四个参数则为配置本地社交平台时触发，根据返回的平台类型来配置平台信息。</span>
</span><span class='line'><span class="cm">   *  如果您使用的时服务端托管平台信息时，第二、四项参数可以传入nil，第三项参数则根据服务端托管平台来决定要连接的社交SDK。</span>
</span><span class='line'><span class="cm">   */</span>
</span><span class='line'>  <span class="p">[</span><span class="n">ShareSDK</span> <span class="nl">registerApp</span><span class="p">:</span><span class="s">@&quot;182947e7afac0&quot;</span>
</span><span class='line'>
</span><span class='line'>      <span class="nl">activePlatforms</span><span class="p">:</span><span class="l">@[</span>
</span><span class='line'>        <span class="l">@(</span><span class="n">SSDKPlatformTypeSinaWeibo</span><span class="l">)</span><span class="p">,</span>
</span><span class='line'>        <span class="l">@(</span><span class="n">SSDKPlatformTypeWechat</span><span class="l">)</span><span class="p">,</span>
</span><span class='line'>        <span class="l">@(</span><span class="n">SSDKPlatformTypeQQ</span><span class="l">)</span><span class="p">,</span>
</span><span class='line'>      <span class="l">]</span>
</span><span class='line'>      <span class="nl">onImport</span><span class="p">:</span><span class="o">^</span><span class="p">(</span><span class="n">SSDKPlatformType</span> <span class="n">platformType</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">switch</span> <span class="p">(</span><span class="n">platformType</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">case</span> <span class="nl">SSDKPlatformTypeWechat</span><span class="p">:</span>
</span><span class='line'>          <span class="p">[</span><span class="n">ShareSDKConnector</span> <span class="nl">connectWeChat</span><span class="p">:[</span><span class="n">WXApi</span> <span class="k">class</span><span class="p">]];</span>
</span><span class='line'>          <span class="k">break</span><span class="p">;</span>
</span><span class='line'>        <span class="k">case</span> <span class="nl">SSDKPlatformTypeQQ</span><span class="p">:</span>
</span><span class='line'>          <span class="p">[</span><span class="n">ShareSDKConnector</span> <span class="nl">connectQQ</span><span class="p">:[</span><span class="n">QQApiInterface</span> <span class="k">class</span><span class="p">]</span>
</span><span class='line'>                     <span class="nl">tencentOAuthClass</span><span class="p">:[</span><span class="n">TencentOAuth</span> <span class="k">class</span><span class="p">]];</span>
</span><span class='line'>          <span class="k">break</span><span class="p">;</span>
</span><span class='line'>        <span class="k">case</span> <span class="nl">SSDKPlatformTypeSinaWeibo</span><span class="p">:</span>
</span><span class='line'>          <span class="p">[</span><span class="n">ShareSDKConnector</span> <span class="nl">connectWeibo</span><span class="p">:[</span><span class="n">WeiboSDK</span> <span class="k">class</span><span class="p">]];</span>
</span><span class='line'>          <span class="k">break</span><span class="p">;</span>
</span><span class='line'>        <span class="k">default</span><span class="o">:</span>
</span><span class='line'>          <span class="k">break</span><span class="p">;</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>      <span class="p">}</span>
</span><span class='line'>      <span class="nl">onConfiguration</span><span class="p">:</span><span class="o">^</span><span class="p">(</span><span class="n">SSDKPlatformType</span> <span class="n">platformType</span><span class="p">,</span>
</span><span class='line'>                        <span class="bp">NSMutableDictionary</span> <span class="o">*</span><span class="n">appInfo</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>
</span><span class='line'>        <span class="k">switch</span> <span class="p">(</span><span class="n">platformType</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">case</span> <span class="nl">SSDKPlatformTypeSinaWeibo</span><span class="p">:</span>
</span><span class='line'>          <span class="c1">//设置新浪微博应用信息,其中authType设置为使用SSO＋Web形式授权</span>
</span><span class='line'>          <span class="p">[</span><span class="n">appInfo</span>
</span><span class='line'>              <span class="nl">SSDKSetupSinaWeiboByAppKey</span><span class="p">:</span><span class="s">@&quot;3144028685&quot;</span>
</span><span class='line'>                               <span class="nl">appSecret</span><span class="p">:</span><span class="s">@&quot;11abfe456bc8eefbab49fe7bbcd90bf0&quot;</span>
</span><span class='line'>                             <span class="nl">redirectUri</span><span class="p">:</span><span class="s">@&quot;http://www.sharesdk.cn&quot;</span>
</span><span class='line'>                                <span class="nl">authType</span><span class="p">:</span><span class="n">SSDKAuthTypeBoth</span><span class="p">];</span>
</span><span class='line'>          <span class="k">break</span><span class="p">;</span>
</span><span class='line'>        <span class="k">case</span> <span class="nl">SSDKPlatformTypeWechat</span><span class="p">:</span>
</span><span class='line'>          <span class="p">[</span><span class="n">appInfo</span> <span class="nl">SSDKSetupWeChatByAppId</span><span class="p">:</span><span class="s">@&quot;wx4868b35061f87885&quot;</span>
</span><span class='line'>                                <span class="nl">appSecret</span><span class="p">:</span><span class="s">@&quot;64020361b8ec4c99936c0e3999a9f249&quot;</span><span class="p">];</span>
</span><span class='line'>          <span class="k">break</span><span class="p">;</span>
</span><span class='line'>        <span class="k">case</span> <span class="nl">SSDKPlatformTypeQQ</span><span class="p">:</span>
</span><span class='line'>          <span class="p">[</span><span class="n">appInfo</span> <span class="nl">SSDKSetupQQByAppId</span><span class="p">:</span><span class="s">@&quot;100371282&quot;</span>
</span><span class='line'>                               <span class="nl">appKey</span><span class="p">:</span><span class="s">@&quot;aed9b0303e3ed1e27bae87c33761161d&quot;</span>
</span><span class='line'>                             <span class="nl">authType</span><span class="p">:</span><span class="n">SSDKAuthTypeBoth</span><span class="p">];</span>
</span><span class='line'>          <span class="k">break</span><span class="p">;</span>
</span><span class='line'>        <span class="k">default</span><span class="o">:</span>
</span><span class='line'>          <span class="k">break</span><span class="p">;</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>      <span class="p">}];</span>
</span><span class='line'>  <span class="k">return</span> <span class="nb">YES</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>接入不同的平台均需要注册并获取<strong>AppKey</strong>和<strong>AppSecret</strong>值。</p>

<h2>添加分享实现代码</h2>

<p>在<strong>ViewController.m</strong>中触发分享的方法中，添加分享代码。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
</pre></td><td class='code'><pre><code class='objective-c'><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">shareAction</span> <span class="p">{</span>
</span><span class='line'>  <span class="p">[</span><span class="nb">self</span><span class="p">.</span><span class="n">tf</span> <span class="nl">endEditing</span><span class="p">:</span><span class="nb">YES</span><span class="p">];</span>
</span><span class='line'>  <span class="c1">// 1、创建分享参数</span>
</span><span class='line'>  <span class="bp">NSArray</span> <span class="o">*</span><span class="n">imageArray</span> <span class="o">=</span> <span class="l">@[</span> <span class="p">[</span><span class="bp">UIImage</span> <span class="nl">imageNamed</span><span class="p">:</span><span class="s">@&quot;junxi5.jpg&quot;</span><span class="p">]</span> <span class="l">]</span><span class="p">;</span>
</span><span class='line'>  <span class="k">if</span> <span class="p">(</span><span class="n">imageArray</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>
</span><span class='line'>    <span class="bp">NSMutableDictionary</span> <span class="o">*</span><span class="n">shareParams</span> <span class="o">=</span> <span class="p">[</span><span class="bp">NSMutableDictionary</span> <span class="n">dictionary</span><span class="p">];</span>
</span><span class='line'>    <span class="p">[</span><span class="n">shareParams</span> <span class="nl">SSDKSetupShareParamsByText</span><span class="p">:</span><span class="nb">self</span><span class="p">.</span><span class="n">tf</span><span class="p">.</span><span class="n">text</span>
</span><span class='line'>                                     <span class="nl">images</span><span class="p">:</span><span class="n">imageArray</span>
</span><span class='line'>                                        <span class="nl">url</span><span class="p">:</span><span class="nb">nil</span>
</span><span class='line'>                                      <span class="nl">title</span><span class="p">:</span><span class="s">@&quot;Ticwatch Sport&quot;</span>
</span><span class='line'>                                       <span class="nl">type</span><span class="p">:</span><span class="n">SSDKContentTypeAuto</span><span class="p">];</span>
</span><span class='line'>    <span class="c1">// 2、分享（可以弹出我们的分享菜单和编辑界面）</span>
</span><span class='line'>    <span class="p">[</span><span class="n">ShareSDK</span> <span class="nl">showShareActionSheet</span><span class="p">:</span><span class="nb">nil</span>
</span><span class='line'>                             <span class="nl">items</span><span class="p">:</span><span class="nb">nil</span>
</span><span class='line'>                       <span class="nl">shareParams</span><span class="p">:</span><span class="n">shareParams</span>
</span><span class='line'>               <span class="nl">onShareStateChanged</span><span class="p">:</span><span class="o">^</span><span class="p">(</span>
</span><span class='line'>                   <span class="n">SSDKResponseState</span> <span class="n">state</span><span class="p">,</span> <span class="n">SSDKPlatformType</span> <span class="n">platformType</span><span class="p">,</span>
</span><span class='line'>                   <span class="bp">NSDictionary</span> <span class="o">*</span><span class="n">userData</span><span class="p">,</span> <span class="n">SSDKContentEntity</span> <span class="o">*</span><span class="n">contentEntity</span><span class="p">,</span>
</span><span class='line'>                   <span class="bp">NSError</span> <span class="o">*</span><span class="n">error</span><span class="p">,</span> <span class="kt">BOOL</span> <span class="n">end</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>
</span><span class='line'>                 <span class="k">switch</span> <span class="p">(</span><span class="n">state</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>                 <span class="k">case</span> <span class="nl">SSDKResponseStateSuccess</span><span class="p">:</span> <span class="p">{</span>
</span><span class='line'>                   <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;分享成功&quot;</span><span class="p">);</span>
</span><span class='line'>                   <span class="k">break</span><span class="p">;</span>
</span><span class='line'>                 <span class="p">}</span>
</span><span class='line'>                 <span class="k">case</span> <span class="nl">SSDKResponseStateFail</span><span class="p">:</span> <span class="p">{</span>
</span><span class='line'>                   <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;分享失败&quot;</span><span class="p">);</span>
</span><span class='line'>                   <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;%@&quot;</span><span class="p">,</span> <span class="n">error</span><span class="p">);</span>
</span><span class='line'>                   <span class="k">break</span><span class="p">;</span>
</span><span class='line'>                 <span class="p">}</span>
</span><span class='line'>                 <span class="k">default</span><span class="o">:</span>
</span><span class='line'>                   <span class="k">break</span><span class="p">;</span>
</span><span class='line'>                 <span class="p">}</span>
</span><span class='line'>               <span class="p">}];</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h2>添加URL Schemes</h2>

<p> <img src="http://ofj92itlz.bkt.clouddn.com/ShareSDK:WhiteList.jpeg" alt="urlscheme" /></p>

<h2>适配iOS 9问题</h2>

<h3>退回http协议，并设置域</h3>

<p><img src="http://ofj92itlz.bkt.clouddn.com/ShareSDK:Https.jpeg" alt="http" /></p>

<h3>添加scheme白名单</h3>

<p><img src="http://ofj92itlz.bkt.clouddn.com/ShareSDK:UrlScheme.jpeg" alt="白名单" /></p>

<h2>分享平台title为英文问题</h2>

<p>默认语言为英文，需要在项目中添加中文本地化。</p>

<p><img src="http://ofj92itlz.bkt.clouddn.com/ShareSDK:Localization.jpeg" alt="localization" /></p>

<p>如需修改标题可以修改对应的本地化文件。</p>

<p> <img src="http://ofj92itlz.bkt.clouddn.com/ShareSDK:CustomLocalization.jpeg" alt="customLocalization" /></p>

<h2>Github源码</h2>

<p><a href="https://github.com/sxgfxm/ShareSDKDemo">ShareSDKDemo</a></p>

<p class='post-footer'>
  原始地址：
  <a href='http://sxgfxm.github.io/blog/2016/10/21/sharesdkjie-ru/'>http://sxgfxm.github.io/blog/2016/10/21/sharesdkjie-ru/</a><br/>
  written by <a href='http://sxgfxm.github.io'>Light</a>
  &nbsp;posted at <a href='http://sxgfxm.github.io'>http://sxgfxm.github.io</a>
  </p>

]]></content>
  </entry>
  
</feed>
